{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Substrait: Cross-Language Serialization for Relational Algebra","text":""},{"location":"#what-is-substrait","title":"What is Substrait?","text":"<p>Substrait is a format for describing compute operations on structured data. It is designed for interoperability across different languages and systems.</p>"},{"location":"#how-does-it-work","title":"How does it work?","text":"<p>Substrait provides a well-defined, cross-language specification for data compute operations.  This includes a consistent declaration of common operations, custom operations and one or more serialized representations of this specification.  The spec focuses on the semantics of each operation.  In addition to the specification the Substrait ecosystem also includes a number of libraries and useful tools.</p> <p>We highly recommend the tutorial to learn how a Substrait plan is constructed.</p>"},{"location":"#benefits","title":"Benefits","text":"<ul> <li>Avoids every system needing to create a communication method between every other system \u2013 each system merely supports ingesting and producing Substrait and it instantly becomes a part of the greater ecosystem.</li> <li>Makes every part of the system upgradable.  There\u2019s a new query engine that\u2019s ten times faster?  Just plug it in!</li> <li>Enables heterogeneous environments \u2013 run on a cluster of an unknown set of execution engines!</li> <li>The text version of the Substrait plan allows you to quickly see how a plan functions without needing a visualizer (although there are Substrait visualizers as well!).</li> </ul>"},{"location":"#example-use-cases","title":"Example Use Cases","text":"<ul> <li>Communicate a compute plan between a SQL parser and an execution engine (e.g. Calcite SQL parsing to Arrow C++ compute kernel)</li> <li>Serialize a plan that represents a SQL view for consistent use in multiple systems (e.g. Iceberg views in Spark and Trino)</li> <li>Submit a plan to different execution engines (e.g. Datafusion and Postgres) and get a consistent interpretation of the semantics.</li> <li>Create an alternative plan generation implementation that can connect an existing end-user compute expression system to an existing end-user processing engine (e.g. Pandas operations executed inside SingleStore)</li> <li>Build a pluggable plan visualization tool (e.g. D3 based plan visualizer)</li> </ul>"},{"location":"about/","title":"Substrait: Cross-Language Serialization for Relational Algebra","text":""},{"location":"about/#project-vision","title":"Project Vision","text":"<p>The Substrait project aims to create a well-defined, cross-language specification for data compute operations. The specification declares a set of common operations, defines their semantics, and describes their behavior unambiguously. The project also defines extension points and serialized representations of the specification.</p> <p>In many ways, the goal of this project is similar to that of the Apache Arrow project. Arrow is focused on a standardized memory representation of columnar data. Substrait is focused on what should be done to data.</p>"},{"location":"about/#why-not-use-sql","title":"Why not use SQL?","text":"<p>SQL is a well known language for describing queries against relational data.  It is designed to be simple and allow reading and writing by humans.  Substrait is not intended as a replacement for SQL and works alongside SQL to provide capabilities that SQL lacks.  SQL is not a great fit for systems that actually satisfy the query because it does not provide sufficient detail and is not represented in a format that is easy for processing.  Because of this, most modern systems will first translate the SQL query into a query plan, sometimes called the execution plan.  There can be multiple levels of a query plan (e.g. physical and logical), a query plan may be split up and distributed across multiple systems, and a query plan often undergoes simplifying or optimizing transformations. The SQL standard does not define the format of the query or execution plan and there is no open format that is supported by a broad set of systems.  Substrait was created to provide a standard and open format for these query plans.</p>"},{"location":"about/#why-not-just-do-this-within-an-existing-oss-project","title":"Why not just do this within an existing OSS project?","text":"<p>A key goal of the Substrait project is to not be coupled to any single existing technology. Trying to get people involved in something can be difficult when it seems to be primarily driven by the opinions and habits of a single community. In many ways, this situation is similar to the early situation with Arrow. The precursor to Arrow was the Apache Drill ValueVectors concepts. As part of creating Arrow, Wes and Jacques recognized the need to create a new community to build a fresh consensus (beyond just what the Apache Drill community wanted). This separation and new independent community was a key ingredient to Arrow\u2019s current success. The needs here are much the same: many separate communities could benefit from Substrait, but each have their own pain points, type systems, development processes and timelines. To help resolve these tensions, one of the approaches proposed in Substrait is to set a bar that at least two of the top four OSS data technologies (Arrow, Spark, Iceberg, Trino) supports something before incorporating it directly into the Substrait specification. (Another goal is to support strong extension points at key locations to avoid this bar being a limiter to broad adoption.)</p>"},{"location":"about/#related-technologies","title":"Related Technologies","text":"<ul> <li>Apache Calcite: Many ideas in Substrait are inspired by the Calcite project. Calcite is a great JVM-based SQL query parsing and optimization framework. A key goal of the Substrait project is to expose Calcite capabilities more easily to non-JVM technologies as well as expose query planning operations as microservices.</li> <li>Apache Arrow: The Arrow format for data is what the Substrait specification attempts to be for compute expressions. A key goal of Substrait is to enable Substrait producers to execute work within the Arrow Rust and C++ compute kernels.</li> </ul>"},{"location":"about/#why-the-name-substrait","title":"Why the name Substrait?","text":"<p>A strait is a narrow connector of water between two other pieces of water. In analytics, data is often thought of as water. Substrait is focused on instructions related to the data. In other words, what defines or supports the movement of water between one or more larger systems. Thus, the underlayment for the strait connecting different pools of water =&gt; sub-strait.</p>"},{"location":"faq/","title":"Frequently Asked Question","text":""},{"location":"faq/#what-is-the-purpose-of-the-post-join-filter-field-on-join-relations","title":"What is the purpose of the post-join filter field on Join relations?","text":"<p>The post-join filter on the various Join relations is not always equivalent to an explicit Filter relation AFTER the Join.</p> <p>See the example here that highlights how the post-join filter behaves differently than a Filter relation in the case of a left join.</p>"},{"location":"governance/","title":"Substrait Project Governance","text":"<p>The Substrait project is run by volunteers in a collaborative and open way. Its governance is inspired by the Apache Software Foundation. In most cases, people familiar with the ASF model can work with Substrait in the same way. The biggest differences between the models are:</p> <ul> <li>Substrait does not have a separate infrastructure governing body that gatekeeps the adoption of new developer tools and technologies.</li> <li>Substrait Management Committee (SMC) members are responsible for recognizing the corporate relationship of its members and ensuring diverse representation and corporate independence.</li> <li>Substrait does not condone private mailing lists. All project business should be discussed in public The only exceptions to this are security escalations (security@substrait.io) and harassment (harassment@substrait.io).</li> <li>Substrait has an automated continuous release process with no formal voting process per release.</li> </ul> <p>More details about concrete things Substrait looks to avoid can be found below.</p>"},{"location":"governance/#the-substrait-project","title":"The Substrait Project","text":"<p>The Substrait project consists of the code and repositories that reside in the substrait-io GitHub organization, the Substrait.io website, the Substrait mailing list, MS-hosted teams community calls and the Substrait Slack workspace. (All are open to everyone and recordings/transcripts are made where technology supports it.)</p>"},{"location":"governance/#substrait-volunteers","title":"Substrait Volunteers","text":"<p>We recognize four groups of individuals related to the project.</p>"},{"location":"governance/#user","title":"User","text":"<p>A user is someone who uses Substrait. They may contribute to Substrait by providing feedback to developers in the form of bug reports and feature suggestions. Users participate in the Substrait community by helping other users on mailing lists and user support forums.</p>"},{"location":"governance/#contributors","title":"Contributors","text":"<p>A contributor is a user who contributes to the project in the form of code or documentation. They take extra steps to participate in the project (loosely defined as the set of repositories under the github substrait-io organization) , are active on the developer mailing list, participate in discussions, and provide patches, documentation, suggestions, and criticism.</p>"},{"location":"governance/#committer","title":"Committer","text":"<p>A committer is a developer who has write access to the code repositories and has a signed Contributor License Agreement (CLA) on file. Not needing to depend on other people to make patches to the code or documentation, they are actually making short-term decisions for the project. The SMC can (even tacitly) agree and approve the changes into permanency, or they can reject them. Remember that the SMC makes the decisions, not the individual committers.</p>"},{"location":"governance/#smc-member","title":"SMC Member","text":"<p>A SMC member is a committer who was elected due to merit for the evolution of the project. They have write access to the code repository, the right to cast binding votes on all proposals on community-related decisions,the right to propose other active contributors for committership, and the right to invite active committers to the SMC. The SMC as a whole is the entity that controls the project, nobody else. They are responsible for the continued shaping of this governance model.</p>"},{"location":"governance/#substrait-management-and-collaboration","title":"Substrait Management and Collaboration","text":"<p>The Substrait project is managed using a collaborative, consensus-based process. We do not have a hierarchical structure; rather, different groups of contributors have different rights and responsibilities in the organization.</p>"},{"location":"governance/#communication","title":"Communication","text":"<p>Communication must be done via mailing lists, Slack, and/or Github. Communication is always done publicly. There are no private lists and all decisions related to the project are made in public. Communication is frequently done asynchronously since members of the community are distributed across many time zones.</p>"},{"location":"governance/#substrait-management-committee","title":"Substrait Management Committee","text":"<p>The Substrait Management Committee is responsible for the active management of Substrait. The main role of the SMC is to further the long-term development and health of the community as a whole, and to ensure that balanced and wide scale peer review and collaboration takes place. As part of this, the SMC is the primary approver of specification changes, ensuring that proposed changes represent a balanced and thorough examination of possibilities. This doesn\u2019t mean that the SMC has to be involved in the minutiae of a particular specification change but should always shepard a healthy process around specification changes.</p>"},{"location":"governance/#substrait-voting-process","title":"Substrait Voting Process","text":"<p>Because one of the fundamental aspects of accomplishing things is doing so by consensus, we need a way to tell whether we have reached consensus. We do this by voting. There are several different types of voting. In all cases, it is recommended that all community members vote. The number of binding votes required to move forward and the community members who have \u201cbinding\u201d votes differs depending on the type of proposal made. In all cases, a veto of a binding voter results in an inability to move forward.</p> <p>The rules require that a community member registering a negative vote must include an alternative proposal or a detailed explanation of the reasons for the negative vote. The community then tries to gather consensus on an alternative proposal that can resolve the issue. In the great majority of cases, the concerns leading to the negative vote can be addressed. This process is called \u201cconsensus gathering\u201d and we consider it a very important indication of a healthy community.</p> +1 votes required Binding voters Voting Location Process/Governance modifications &amp; actions. This includes promoting new contributors to committer or SMC. 3 SMC Mailing List Format/Specification Modifications (including breaking extension changes) 2 SMC Github PR Documentation Updates (formatting, moves) 1 SMC Github PR Typos 1 Committers Github PR Non-breaking function introductions 1 (not including proposer) Committers Github PR Non-breaking extension additions &amp; non-format code modifications 1 (not including proposer) Committers Github PR Changes (non-breaking or breaking) to a Substrait library (i.e. substrait-java, substrait-validator) 1 (not including proposer) Committers Github PR"},{"location":"governance/#review-then-commit","title":"Review-Then-Commit","text":"<p>Substrait follows a review-then-commit policy. This requires that all changes receive consensus approval before being committed to the code base. The specific vote requirements follow the table above.</p>"},{"location":"governance/#expressing-votes","title":"Expressing Votes","text":"<p>The voting process may seem more than a little weird if you\u2019ve never encountered it before. Votes are represented as numbers between -1 and +1, with \u2018-1\u2019 meaning \u2018no\u2019 and \u2018+1\u2019 meaning \u2018yes.\u2019</p> <p>The in-between values indicate how strongly the voting individual feels. Here are some examples of fractional votes and what the voter might be communicating with them:</p> <ul> <li>+0: \u2018I don\u2019t feel strongly about it, but I\u2019m okay with this.\u2019</li> <li>-0: \u2018I won\u2019t get in the way, but I\u2019d rather we didn\u2019t do this.\u2019</li> <li>-0.5: \u2018I don\u2019t like this idea, but I can\u2019t find any rational justification for my feelings.\u2019</li> <li>++1: \u2018Wow! I like this! Let\u2019s do it!\u2019</li> <li>-0.9: \u2018I really don\u2019t like this, but I\u2019m not going to stand in the way if everyone else wants to go ahead with it.\u2019</li> <li>+0.9: \u2018This is a cool idea and I like it, but I don\u2019t have time/the skills necessary to help out.\u2019</li> </ul>"},{"location":"governance/#votes-on-code-modification","title":"Votes on Code Modification","text":"<p>For code-modification votes, +1 votes (review approvals in Github are considered equivalent to a +1) are in favor of the proposal, but -1 votes are vetoes and kill the proposal dead until all vetoers withdraw their -1 votes.</p>"},{"location":"governance/#vetoes","title":"Vetoes","text":"<p>A -1 (or an unaddressed PR request for changes) vote by a qualified voter stops a code-modification proposal in its tracks. This constitutes a veto, and it cannot be overruled nor overridden by anyone. Vetoes stand until and unless the individual withdraws their veto.</p> <p>To prevent vetoes from being used capriciously, the voter must provide with the veto a technical or community justification showing why the change is bad.</p>"},{"location":"governance/#why-do-we-vote","title":"Why do we vote?","text":"<p>Votes help us to openly resolve conflicts. Without a process, people tend to avoid conflict and thrash around. Votes help to make sure we do the hard work of resolving the conflict.</p>"},{"location":"governance/#substrait-is-non-commercial-but-commercially-aware","title":"Substrait is non-commercial but commercially-aware","text":"<p>Substrait\u2019s mission is to produce software for the public good. All Substrait software is always available for free, and solely under the Apache License.</p> <p>We\u2019re happy to have third parties, including for-profit corporations, take our software and use it for their own purposes. However it is important in these cases to ensure that the third party does not misuse the brand and reputation of the Substrait project for its own purposes. It is important for the longevity and community health of Substrait that the community gets the appropriate credit for producing freely available software.</p> <p>The SMC actively track the corporate allegiances of community members and strives to ensure influence around any particular aspect of the project isn\u2019t overly skewed towards a single corporate entity.</p>"},{"location":"governance/#substrait-trademark","title":"Substrait Trademark","text":"<p>The SMC is responsible for protecting the Substrait name and brand. TBD what action is taken to support this.</p>"},{"location":"governance/#project-roster","title":"Project Roster","text":""},{"location":"governance/#substrait-management-committee-smc","title":"Substrait Management Committee (SMC)","text":"Name Association Phillip Cloud Voltron Data Weston Pace LanceDB Jacques Nadeau Sundeck Victor Barua Datadog David Sisson Voltron Data"},{"location":"governance/#substrait-committers","title":"Substrait Committers","text":"Name Association Jeroen van Straten Qblox Carlo Curino Microsoft James Taylor Sundeck Sutou Kouhei Clearcode Micah Kornfeld Google Jinfeng Ni Sundeck Andy Grove Nvidia Jesus Camacho Rodriguez Microsoft Rich Tia Voltron Data Vibhatha Abeykoon Voltron Data Nic Crane Recast Gil Forsyth Voltron Data ChaoJun Zhang Intel Matthijs Brobbel Voltron Data Matt Topol Voltron Data"},{"location":"governance/#additional-detail-about-differences-from-asf","title":"Additional detail about differences from ASF","text":"<p>Corporate Awareness: The ASF takes a blind-eye approach that has proven to be too slow to correct corporate influence which has substantially undermined many OSS projects. In contrast, Substrait SMC members are responsible for identifying corporate risks and over-representation and adjusting inclusion in the project based on that (limiting committership, SMC membership, etc). Each member of the SMC shares responsibility to expand the community and seek out corporate diversity.</p> <p>Infrastructure: The ASF shows its age wrt to infrastructure, having been originally built on SVN. Some examples of requirements that Substrait is eschewing that exist in ASF include: custom git infrastructure, release process that is manual, project external gatekeeping around the use of new tools/technologies.</p>"},{"location":"community/","title":"Community","text":"<p>Substrait is developed as a consensus-driven open source product under the Apache 2.0 license. Development is done in the open leveraging GitHub issues and PRs.</p>"},{"location":"community/#get-in-touch","title":"Get In Touch","text":"Mailing List/Google Group We use the mailing list to discuss questions, formulate plans and collaborate asynchronously. Slack Channel The developers of Substrait frequent the Slack channel. You can get an   invite to the channel by following this link. GitHub Issues Substrait is developed via GitHub issues and pull requests. If you see a problem   or want to enhance the product, we suggest you file a GitHub issue for developers to   review. Twitter The @substrait_io account on Twitter is our official account. Follow-up to keep   to date on what is happening with Substrait! Docs Our website is all maintained in our source repository. If there is something you think   can be improved, feel free to fork our repository and post a pull request. Meetings Our community meets every other week on Wednesday."},{"location":"community/#talks","title":"Talks","text":"<p>Want to learn more about Substrait? Try the following presentations and slide decks.</p> <ul> <li>Substrait: A Common Representation for Data Compute Plans (Jacques Nadeau, April 2022) [slides]</li> </ul>"},{"location":"community/#citation","title":"Citation","text":"<p>If you use Substrait in your research, please cite it using the following BibTeX entry:</p> <pre><code>@misc{substrait,\n  author = {substrait-io},\n  title = {Substrait: Cross-Language Serialization for Relational Algebra},\n  year = {2021},\n  month = {8},\n  day = {31},\n  publisher = {GitHub},\n  journal = {GitHub repository},\n  howpublished = {\\url{https://github.com/substrait-io/substrait}}\n}\n</code></pre>"},{"location":"community/#contribution","title":"Contribution","text":"<p>All contributors are welcome to Substrait.   If you want to join the project, open a PR or get in touch with us as above.</p>"},{"location":"community/#principles","title":"Principles","text":"<ul> <li>Be inclusive and open to all.</li> <li>Ensure a diverse set of contributors that come from multiple data backgrounds to maximize general utility.</li> <li>Build a specification based on open consensus.</li> <li>Avoid over-reliance/coupling to any single technology.</li> <li>Make the specification and all tools freely available on a permissive license (ApacheV2)</li> </ul>"},{"location":"community/powered_by/","title":"Powered by Substrait","text":"<p>In addition to the work maintained in repositories within the substrait-io GitHub organization, a growing list of other open source projects have adopted Substrait.</p> Acero Acero is a query execution engine implemented as a part of the Apache Arrow   C++ library. Acero provides a Substrait consumer interface. ADBC ADBC (Arrow Database Connectivity) is an API specification for Apache   Arrow-based database access. ADBC allows applications to pass queries either   as SQL strings or Substrait plans. Arrow Flight SQL Arrow Flight SQL is a client-server protocol for interacting with databases   and query engines using the Apache Arrow in-memory columnar format and the   Arrow Flight RPC   framework. Arrow Flight SQL allows clients to send queries as SQL strings or   Substrait plans. DataFusion DataFusion is an extensible query planning, optimization, and execution   framework, written in Rust, that uses Apache Arrow as its in-memory format.   DataFusion provides a Substrait producer and consumer that can convert   DataFusion logical plans to and from Substrait plans. It can be used through the   DataFusion Python bindings. DuckDB DuckDB is an in-process SQL OLAP database management system. DuckDB provides   a Substrait extension   that allows users to produce and consume Substrait plans through DuckDB\u2019s   SQL, Python, and R APIs. Gluten Gluten is a plugin for Apache Spark that allows computation to be offloaded   to engines that have better performance or efficiency than Spark\u2019s built-in   JVM-based engine. Gluten converts Spark physical plans to Substrait plans. Ibis Ibis is a Python library that provides a lightweight, universal interface    for data wrangling. It includes a dataframe API for Python with support for   more than 10 query execution engines, plus a    Substrait producer   to enable support for Substrait-consuming execution engines. Substrait R Interface The Substrait R interface package allows users to construct Substrait plans   from R for evaluation by Substrait-consuming execution engines. The package   provides a dplyr backend as well as   lower-level interfaces for creating Substrait plans and integrations with   Acero and DuckDB. Velox Velox is a unified execution engine aimed at accelerating data management   systems and streamlining their development. Velox provides a Substrait   consumer interface. <p>To add your project to this list, please open a pull request.</p>"},{"location":"expressions/aggregate_functions/","title":"Aggregate Functions","text":"<p>Aggregate functions are functions that define an operation which consumes values from multiple records to a produce a single output. Aggregate functions in SQL are typically used in GROUP BY functions. Aggregate functions are similar to scalar functions and function signatures with a small set of different properties.</p> <p>Aggregate function signatures contain all the properties defined for scalar functions. Additionally, they contain the properties below:</p> Property Description Required Inherits All properties defined for scalar function. N/A Ordered Whether the result of this function is sensitive to sort order. Optional, defaults to false Maximum set size Maximum allowed set size as an unsigned integer. Optional, defaults to unlimited Decomposable Whether the function can be executed in one or more intermediate steps. Valid options are: <code>NONE</code>, <code>ONE</code>, <code>MANY</code>, describing how intermediate steps can be taken. Optional, defaults to <code>NONE</code> Intermediate Output Type If the function is decomposable, represents the intermediate output type that is used, if the function is defined as either <code>ONE</code> or <code>MANY</code> decomposable. Will be a struct in many cases. Required for <code>ONE</code> and <code>MANY</code>. Invocation Whether the function uses all or only distinct values in the aggregation calculation. Valid options are: <code>ALL</code>, <code>DISTINCT</code>. Optional, defaults to <code>ALL</code>"},{"location":"expressions/aggregate_functions/#aggregate-binding","title":"Aggregate Binding","text":"<p>When binding an aggregate function, the binding must include the following additional properties beyond the standard scalar binding properties:</p> Property Description Phase Describes the input type of the data: [INITIAL_TO_INTERMEDIATE, INTERMEDIATE_TO_INTERMEDIATE, INITIAL_TO_RESULT, INTERMEDIATE_TO_RESULT] describing what portion of the operation is required. For functions that are NOT decomposable, the only valid option will be INITIAL_TO_RESULT. Ordering Zero or more ordering keys along with key order (ASC|DESC|NULL FIRST, etc.), declared similar to the sort keys in an <code>ORDER BY</code> relational operation. If no sorts are specified, the records are not sorted prior to being passed to the aggregate function."},{"location":"expressions/embedded_functions/","title":"Embedded Functions","text":"<p>Embedded functions are a special kind of function where the implementation is embedded within the actual plan. They are commonly used in tools where a user intersperses business logic within a data pipeline. This is more common in data science workflows than traditional SQL workflows.</p> <p>Embedded functions are not pre-registered. Embedded functions require that data be consumed and produced with a standard API, may require memory allocation and have determinate error reporting behavior. They may also have specific runtime dependencies. For example, a Python pickle function may depend on pyarrow 5.0 and pynessie 1.0.</p> <p>Properties for an embedded function include:</p> Property Description Required Function Type The type of embedded function presented. Required Function Properties Function properties, one of those items defined below. Required Output Type The fully resolved output type for this embedded function. Required <p>The binary representation of an embedded function is:</p> Binary RepresentationHuman Readable Representation <pre><code>message EmbeddedFunction {\n  repeated Expression arguments = 1;\n  Type output_type = 2;\n  oneof kind {\n    PythonPickleFunction python_pickle_function = 3;\n    WebAssemblyFunction web_assembly_function = 4;\n  }\n\n  message PythonPickleFunction {\n    bytes function = 1;\n    repeated string prerequisite = 2;\n  }\n\n  message WebAssemblyFunction {\n    bytes script = 1;\n    repeated string prerequisite = 2;\n  }\n}\n</code></pre> <p>As the bytes are opaque to Substrait there is no equivalent human readable form.</p>"},{"location":"expressions/embedded_functions/#function-details","title":"Function Details","text":"<p>There are many types of possible stored functions. For each, Substrait works to expose the function in as descriptive a way as possible to support the largest number of consumers.</p>"},{"location":"expressions/embedded_functions/#python-pickle-function-type","title":"Python Pickle Function Type","text":"Property Description Required Pickle Body binary pickle encoded function using [TBD] API representation to access arguments. True Prereqs A list of specific Python conda packages that are prerequisites for access (a structured version of a requirements.txt file). Optional, defaults to none"},{"location":"expressions/embedded_functions/#webassembly-function-type","title":"WebAssembly Function Type","text":"Property Description Required Script WebAssembly function True Prereqs A list of AssemblyScript prerequisites required to compile the assemblyscript function using NPM coordinates. Optional, defaults to none Discussion Points <ul> <li>What are the common embedded function formats?</li> <li>How do we expose the data for a function?</li> <li>How do we express batching capabilities?</li> <li>How do we ensure/declare containerization?</li> </ul>"},{"location":"expressions/extended_expression/","title":"Extended Expression","text":"<p>Extended Expression messages are provided for expression-level protocols as an alternative to using a Plan. They mainly target expression-only evaluations, such as those computed in Filter/Project/Aggregation rels. Unlike the original Expression defined in the substrait protocol, Extended Expression messages require more information to completely describe the computation context including: input data schema, referred function signatures, and output schema. </p> <p>Since Extended Expression will be used seperately from the Plan rel representation, it will need to include basic fields like Version.</p> ExtendedExpression Message <pre><code>message ExtendedExpression {\n  // Substrait version of the expression. Optional up to 0.17.0, required for later\n  // versions.\n  Version version = 7;\n\n  // a list of yaml specifications this expression may depend on\n  repeated substrait.extensions.SimpleExtensionURI extension_uris = 1;\n\n  // a list of extensions this expression may depend on\n  repeated substrait.extensions.SimpleExtensionDeclaration extensions = 2;\n\n  // one or more expression trees with same order in plan rel\n  repeated ExpressionReference referred_expr = 3;\n\n  NamedStruct base_schema = 4;\n  // additional extensions associated with this expression.\n  substrait.extensions.AdvancedExtension advanced_extensions = 5;\n\n  // A list of com.google.Any entities that this plan may use. Can be used to\n  // warn if some embedded message types are unknown. Note that this list may\n  // include message types that are ignorable (optimizations) or that are\n  // unused. In many cases, a consumer may be able to work with a plan even if\n  // one or more message types defined here are unknown.\n  repeated string expected_type_urls = 6;\n\n}\n</code></pre>"},{"location":"expressions/extended_expression/#input-and-output-data-schema","title":"Input and output data schema","text":"<p>Similar to <code>base_schema</code> defined in ReadRel, the input data schema describes the name/type/nullibilty and layout info of input data for the target expression evalutation. It also has a field <code>name</code> to define the name of the output data.</p>"},{"location":"expressions/extended_expression/#referred-expression","title":"Referred expression","text":"<p>An Extended Exression will have one or more referred expressions, which can be either Expression or AggregateFunction. Additional types of expressions may be added in the future.</p> <p>For a message with multiple expressions, users may produce each Extended Expression in the same order as they occur in the original Plan rel. But, the consumer does NOT have to handle them in this order. A consumer needs only to ensure that the columns in the final output are organized in the same order as defined in the message.</p>"},{"location":"expressions/extended_expression/#function-extensions","title":"Function extensions","text":"<p>Function extensions work the same for both Extended Expression and the original Expression defined in the Substrait protocol.</p>"},{"location":"expressions/field_references/","title":"Field References","text":"<p>In Substrait, all fields are dealt with on a positional basis. Field names are only used at the edge of a plan, for the purposes of naming fields for the outside world. Each operation returns a simple or compound data type. Additional operations can refer to data within that initial operation using field references. To reference a field, you use a reference based on the type of field position you want to reference.</p> Reference Type Properties Type Applicability Type return Struct Field Ordinal position. Zero-based. Only legal within the range of possible fields within a struct. Selecting an ordinal outside the applicable field range results in an invalid plan. struct Type of field referenced Array Value Array offset. Zero-based. Negative numbers can be used to describe an offset relative to the end of the array. For example, -1 means the last element in an array. Negative and positive overflows return null values (no wrapping). list type of list Array Slice Array offset and element count. Zero-based. Negative numbers can be used to describe an offset relative to the end of the array. For example, -1 means the last element in an array. Position does not wrap, nor does length. list Same type as original list Map Key A map value that is matched exactly against available map keys and returned. map Value type of map Map KeyExpression A wildcard string that is matched against a simplified form of regular expressions. Requires the key type of the map to be a character type. [Format detail needed, intention to include basic regex concepts such as greedy/non-greedy.] map List of map value type Masked Complex Expression An expression that provides a mask over a schema declaring which portions of the schema should be presented. This allows a user to select a portion of a complex object but mask certain subsections of that same object. any any"},{"location":"expressions/field_references/#compound-references","title":"Compound References","text":"<p>References are typically constructed as a sequence. For example: [struct position 0, struct position 1, array offset 2, array slice 1..3].</p> <p>Field references are in the same order they are defined in their schema. For example, let\u2019s consider the following schema:</p> <pre><code>column a:\n  struct&lt;\n    b: list&lt;\n      struct&lt;\n        c: map&lt;string, \n          struct&lt;\n            x: i32&gt;&gt;&gt;&gt;&gt;\n</code></pre> <p>If we want to represent the SQL expression:</p> <pre><code>a.b[2].c['my_map_key'].x\n</code></pre> <p>We will need to declare the nested field such that:</p> <pre><code>Struct field reference a\nStruct field b\nList offset 2\nStruct field c\nMap key my_map_key\nStruct field x\n</code></pre> <p>Or more formally in Protobuf Text, we get:</p> <pre><code>selection {\n  direct_reference {\n    struct_field {\n      field: 0 # .a\n      child {\n        struct_field {\n          field: 0 # .b\n          child {\n            list_element {\n              offset: 2\n              child {\n                struct_field {\n                  field: 0 # .c\n                  child {\n                    map_key {\n                      map_key {\n                        string: \"my_map_key\" # ['my_map_key']\n                      }\n                      child {\n                        struct_field {\n                          field: 0 # .x\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  root_reference { }\n}\n</code></pre>"},{"location":"expressions/field_references/#validation","title":"Validation","text":"<p>References must validate against the schema of the record being referenced. If not, an error is expected.</p>"},{"location":"expressions/field_references/#masked-complex-expression","title":"Masked Complex Expression","text":"<p>A masked complex expression is used to do a subselection of a portion of a complex record. It allows a user to specify the portion of the complex object to consume. Imagine you have a schema of (note that structs are lists of fields here, as they are in general in Substrait as field names are not used internally in Substrait):</p> <pre><code>struct:\n  - struct:\n    - integer\n    - list:\n      struct:\n        - i32\n        - string\n        - string\n     - i32\n  - i16\n  - i32\n  - i64\n</code></pre> <p>Given this schema, you could declare a mask of fields to include in pseudocode, such as:</p> <pre><code>0:[0,1:[..5:[0,2]]],2,3\n\nOR\n\n0:\n  - 0\n  - 1:\n    ..5:\n      -0\n      -2\n2\n3\n</code></pre> <p>This mask states that we would like to include fields 0 2 and 3 at the top-level. Within field 0, we want to include subfields 0 and 1. For subfield 0.1, we want to include up to only the first 5 records in the array and only includes fields 0 and 2 within the struct within that array. The resulting schema would be:</p> <pre><code>struct:\n  - struct:\n    - integer\n    - list:\n      struct: \n        - i32\n        - string\n  - i32\n  - i64\n</code></pre>"},{"location":"expressions/field_references/#unwrapping-behavior","title":"Unwrapping Behavior","text":"<p>By default, when only a single field is selected from a struct, that struct is removed. When only a single element is removed from a list, the list is removed. A user can also configure the mask to avoid unwrapping in these cases. [TBD how we express this in the serialization formats.]</p> Discussion Points <ul> <li>Should we support column reordering/positioning using a masked complex expression? (Right now, you can only mask things out.)</li> </ul>"},{"location":"expressions/scalar_functions/","title":"Scalar Functions","text":"<p>A function is a scalar function if that function takes in values from a single record and produces an output value. To clearly specify the definition of functions, Substrait declares an extensible specification plus binding approach to function resolution. A scalar function signature includes the following properties:</p> Property Description Required Name One or more user-friendly UTF-8 strings that are used to reference this function. At least one value is required. List of arguments Argument properties are defined below. Arguments can be fully defined or calculated with a type expression. See further details below. Optional, defaults to niladic. Deterministic Whether this function is expected to reproduce the same output when it is invoked multiple times with the same input. This informs a plan consumer on whether it can constant-reduce the defined function. An example would be a random() function, which is typically expected to be evaluated repeatedly despite having the same set of inputs. Optional, defaults to true. Session Dependent Whether this function is influenced by the session context it is invoked within. For example, a function may be influenced by a user who is invoking the function, the time zone of a session, or some other non-obvious parameter. This can inform caching systems on whether a particular function is cacheable. Optional, defaults to false. Variadic Behavior Whether the last argument of the function is variadic or a single argument.  If variadic, the argument can optionally have a lower bound (minimum number of instances) and an upper bound (maximum number of instances). Optional, defaults to single value. Nullability Handling Describes how nullability of input arguments maps to nullability of output arguments. Three options are: <code>MIRROR</code>, <code>DECLARED_OUTPUT</code> and <code>DISCRETE</code>. More details about nullability handling are listed below. Optional, defaults to <code>MIRROR</code> Description Additional description of function for implementers or users. Should be written human-readable to allow exposure to end users. Presented as a map with language =&gt; description mappings. E.g. <code>{ \"en\": \"This adds two numbers together.\", \"fr\": \"cela ajoute deux nombres\"}</code>. Optional Return Value The output type of the expression.  Return types can be expressed as a fully-defined type or a type expression. See below for more on type expressions. Required Implementation Map A map of implementation locations for one or more implementations of the given function. Each key is a function implementation type. Implementation types include examples such as: AthenaArrowLambda, TrinoV361Jar, ArrowCppKernelEnum, GandivaEnum, LinkedIn Transport Jar, etc. [Definition TBD]. Implementation type has one or more properties associated with retrieval of that implementation. Optional"},{"location":"expressions/scalar_functions/#argument-types","title":"Argument Types","text":"<p>There are three main types of arguments: value arguments, type arguments, and enumerations.  Every defined arguments must be specified in every invocation of the function.  When specified, the position of these arguments in the function invocation must match the position of the arguments as defined in the YAML function definition.</p> <ul> <li>Value arguments: arguments that refer to a data value. These could be constants (literal expressions defined in the plan) or variables (a reference expression that references data being processed by the plan). This is the most common type of argument. The value of a value argument is not available in output derivation, but its type is. Value arguments can be declared in one of two ways: concrete or parameterized. Concrete types are either simple types or compound types with all parameters fully defined (without referencing any type arguments). Examples include <code>i32</code>, <code>fp32</code>, <code>VARCHAR&lt;20&gt;</code>, <code>List&lt;fp32&gt;</code>, etc. Parameterized types are discussed further below.</li> <li>Type arguments: arguments that are used only to inform the evaluation and/or type derivation of the function. For example, you might have a function which is <code>truncate(&lt;type&gt; DECIMAL&lt;P0,S0&gt;, &lt;value&gt; DECIMAL&lt;P1, S1&gt;, &lt;value&gt; i32)</code>. This function declares two value arguments and a type argument. The difference between them is that the type argument has no value at runtime, while the value arguments do.</li> <li>Enumeration: arguments that support a fixed set of declared values as constant arguments. These arguments must be specified as part of an expression. While these could also have been implemented as constant string value arguments, they are formally included to improve validation/contextual help/etc. for frontend processors and IDEs. An example might be <code>extract([DAY|YEAR|MONTH], &lt;date value&gt;)</code>. In this example, a producer must specify a type of date part to extract. Note, the value of a required enumeration cannot be used in type derivation.</li> </ul>"},{"location":"expressions/scalar_functions/#value-argument-properties","title":"Value Argument Properties","text":"Property Description Required Name A human-readable name for this argument to help clarify use. Optional, defaults to a name based on position (e.g. <code>arg0</code>) Description Additional description of this argument. Optional Value A fully defined type or a type expression. Required Constant Whether this argument is required to be a constant for invocation. For example, in some system a regular expression pattern would only be accepted as a literal and not a column value reference. Optional, defaults to false"},{"location":"expressions/scalar_functions/#type-argument-properties","title":"Type Argument Properties","text":"Property Description Required Type A partially or completely parameterized type. E.g. <code>List&lt;K&gt;</code> or <code>K</code> Required Name A human-readable name for this argument to help clarify use. Optional, defaults to a name based on position (e.g. <code>arg0</code>) Description Additional description of this argument. Optional"},{"location":"expressions/scalar_functions/#required-enumeration-properties","title":"Required Enumeration Properties","text":"Property Description Required Options List of valid string options for this argument Required Name A human-readable name for this argument to help clarify use. Optional, defaults to a name based on position (e.g. <code>arg0</code>) Description Additional description of this argument. Optional"},{"location":"expressions/scalar_functions/#options","title":"Options","text":"<p>In addition to arguments each call may specify zero or more options.  These are similar to a required enumeration but more focused on supporting alternative behaviors. Options can be left unspecified and the consumer is free to choose which implementation to use. An example use case might be <code>OVERFLOW_BEHAVIOR:[OVERFLOW, SATURATE, ERROR]</code> If unspecified, an engine is free to use any of the three choices or even some alternative behavior (e.g. setting the value to null on overflow). If specified, the engine would be expected to behave as specified or fail. Note, the value of an optional enumeration cannot be used in type derivation.</p>"},{"location":"expressions/scalar_functions/#option-preference","title":"Option Preference","text":"<p>A producer may specify multiple values for an option.  If the producer does so then the consumer must deliver the first behavior in the list of values that the consumer is capable of delivering.  For example, considering overflow as defined above, if a producer specified <code>[ERROR, SATURATE]</code> then the consumer must deliver <code>ERROR</code> if it is capable of doing so.  If it is not then it may deliver <code>SATURATE</code>.  If the consumer cannot deliver either behavior then it is an error and the consumer must reject the plan.</p>"},{"location":"expressions/scalar_functions/#optional-properties","title":"Optional Properties","text":"Property Description Required Values A list of valid strings for this option. Required Name A human-readable name for this option. Required"},{"location":"expressions/scalar_functions/#nullability-handling","title":"Nullability Handling","text":"Mode Description MIRROR This means that the function has the behavior that if at least one of the input arguments are nullable, the return type is also nullable. If all arguments are non-nullable, the return type will be non-nullable.  An example might be the <code>+</code> function. DECLARED_OUTPUT Input arguments are accepted of any mix of nullability. The nullability of the output function is whatever the return type expression states. Example use might be the function <code>is_null()</code> where the output is always <code>boolean</code> independent of the nullability of the input. DISCRETE The input and arguments all define concrete nullability and can only be bound to the types that have those nullability. For example, if a type input is declared <code>i64?</code> and one has an <code>i64</code> literal, the <code>i64</code> literal must be specifically cast to <code>i64?</code> to allow the operation to bind."},{"location":"expressions/scalar_functions/#parameterized-types","title":"Parameterized Types","text":"<p>Types are parameterized by two types of values: by inner types (e.g. <code>List&lt;K&gt;</code>) and numeric values (e.g. <code>DECIMAL&lt;P,S&gt;</code>). Parameter names are simple strings (frequently a single character). There are two types of parameters: integer parameters and type parameters.</p> <p>When the same parameter name is used multiple times in a function definition, the function can only bind if the exact same value is used for all parameters of that name. For example, if one had a function with a signature of <code>fn(VARCHAR&lt;N&gt;, VARCHAR&lt;N&gt;)</code>, the function would be only be usable if both <code>VARCHAR</code> types had the same length value <code>N</code>. This necessitates that all instances of the same parameter name must be of the same parameter type (all instances are a type parameter or all instances are an integer parameter).</p>"},{"location":"expressions/scalar_functions/#type-parameter-resolution-in-variadic-functions","title":"Type Parameter Resolution in Variadic Functions","text":"<p>When the last argument of a function is variadic and declares a type parameter e.g. <code>fn(A, B, C...)</code>, the C parameter can be marked as either consistent or inconsistent. If marked as consistent, the function can only be bound to arguments where all the C types are the same concrete type. If marked as inconsistent, each unique C can be bound to a different type within the constraints of what T allows.</p>"},{"location":"expressions/scalar_functions/#output-type-derivation","title":"Output Type Derivation","text":""},{"location":"expressions/scalar_functions/#concrete-return-types","title":"Concrete Return Types","text":"<p>A concrete return type is one that is fully known at function definition time. Examples of simple concrete return types would be things such as <code>i32</code>, <code>fp32</code>. For compound types, a concrete return type must be fully declared. Example of fully defined compound types: <code>VARCHAR&lt;20&gt;</code>, <code>DECIMAL&lt;25,5&gt;</code></p>"},{"location":"expressions/scalar_functions/#return-type-expressions","title":"Return Type Expressions","text":"<p>Any function can declare a return type expression. A return type expression uses a simplified set of expressions to describe how the return type should be returned. For example, a return expression could be as simple as the return of parameter declared in the arguments. For example <code>f(List&lt;K&gt;) =&gt; K</code> or can be a simple mathematical or conditional expression such as <code>add(decimal&lt;a,b&gt;, decimal&lt;c,d&gt;) =&gt; decimal&lt;a+c, b+d&gt;</code>. For the simple expression language, there is a very narrow set of types:</p> <ul> <li>Integer: 64-bit signed integer (can be a literal or a parameter value)</li> <li>Boolean: True and False</li> <li>Type: A Substrait type (with possibly additional embedded expressions)</li> </ul> <p>These types are evaluated using a small set of operations to support common scenarios. List of valid operations:</p> <pre><code>Math: +, -, *, /, min, max\nBoolean: &amp;&amp;, ||, !, &lt;, &gt;, ==\nParameters: type, integer\nLiterals: type, integer\n</code></pre> <p>Fully defined with argument types:</p> <ul> <li><code>type_parameter(string name) =&gt; type</code></li> <li><code>integer_parameter(string name) =&gt; integer</code></li> <li><code>not(boolean x) =&gt; boolean</code> </li> <li><code>and(boolean a, boolean b) =&gt; boolean</code> </li> <li><code>or(boolean a, boolean b) =&gt; boolean</code> </li> <li><code>multiply(integer a, integer b) =&gt; integer</code></li> <li><code>divide(integer a, integer b) =&gt; integer</code></li> <li><code>add(integer a, integer b) =&gt; integer</code></li> <li><code>subtract(integer a, integer b) =&gt; integer</code></li> <li><code>min(integer a, integer b) =&gt; integer</code></li> <li><code>max(integer a, integer b) =&gt; integer</code></li> <li><code>equal(integer a, integer b) =&gt; boolean</code></li> <li><code>greater_than(integer a, integer b) =&gt; boolean</code></li> <li><code>less_than(integer a, integer b) =&gt; boolean</code></li> <li><code>covers(Type a, Type b) =&gt; boolean</code> Covers means that type b matches type A for as much as type B is defined. For example, if type A is <code>VARCHAR&lt;20&gt;</code> and type B is <code>VARCHAR&lt;N&gt;</code>, type B would be considered covering. Similarlily if type A was <code>List&lt;Struct&lt;a:f32, b:f32&gt;&gt;</code>and type B was <code>List&lt;Struct&lt;&gt;&gt;</code>, it would be considered covering. Note that this is directional \u201cas in B covers A\u201d or \u201cB can be further enhanced to match the definition A\u201d.</li> <li><code>if(boolean a) then (integer) else (integer)</code></li> <li><code>if(boolean a) then (type) else (type)</code></li> </ul>"},{"location":"expressions/scalar_functions/#example-type-expressions","title":"Example Type Expressions","text":"<p>For reference, here are are some common output type derivations and how they can be expressed with a return type expression:</p> Operation Definition Add item to list <code>add(List&lt;T&gt;, T) =&gt; List&lt;T&gt;</code> Decimal Division <code>divide(Decimal&lt;P1,S1&gt;, Decimal&lt;P2,S2&gt;) =&gt; Decimal&lt;P1 -S1 + S2 + MAX(6, S1 + P2 + 1), MAX(6, S1 + P2 + 1)&gt;</code> Select a subset of map keys based on a regular expression (requires stringlike keys) <code>extract_values(regex:string, map:Map&lt;K,V&gt;) =&gt; List&lt;V&gt; WHERE K IN [STRING, VARCHAR&lt;N&gt;, FIXEDCHAR&lt;N&gt;]</code> Concatenate two fixed sized character strings <code>concat(FIXEDCHAR&lt;A&gt;, FIXEDCHAR&lt;B&gt;) =&gt; FIXEDCHAR&lt;A+B&gt;</code> Make a struct of a set of fields and a struct definition. <code>make_struct(&lt;type&gt; T, K...) =&gt; T</code>"},{"location":"expressions/specialized_record_expressions/","title":"Specialized Record Expressions","text":"<p>While all types of operations could be reduced to functions, in some cases this would be overly simplistic. Instead, it is helpful to construct some other expression constructs.</p> <p>These constructs should be focused on different expression types as opposed to something that directly related to syntactic sugar. For example, CAST and EXTRACT or SQL operations that are presented using specialized syntax. However, they can easily be modeled using a function paradigm with minimal complexity.</p>"},{"location":"expressions/specialized_record_expressions/#literal-expressions","title":"Literal Expressions","text":"<p>For each data type, it is possible to create a literal value for that data type. The representation depends on the serialization format. Literal expressions include both a type literal and a possibly null value.</p>"},{"location":"expressions/specialized_record_expressions/#nested-type-constructor-expressions","title":"Nested Type Constructor Expressions","text":"<p>These expressions allow structs, lists, and maps to be constructed from a set of expressions. For example, they allow a struct expression like <code>(field 0 - field 1, field 0 + field 1)</code> to be represented.</p>"},{"location":"expressions/specialized_record_expressions/#cast-expression","title":"Cast Expression","text":"<p>To convert a value from one type to another, Substrait defines a cast expression. Cast expressions declare an expected type, an input argument and an enumeration specifying failure behavior, indicating whether cast should return null on failure or throw an exception.</p> <p>Note that Substrait always requires a cast expression whenever the current type is not exactly equal to (one of) the expected types. For example, it is illegal to directly pass a value of type <code>i8[0]</code> to a function that only supports an <code>i8?[0]</code> argument.</p>"},{"location":"expressions/specialized_record_expressions/#if-expression","title":"If Expression","text":"<p>An if value expression is an expression composed of one if clause, zero or more else if clauses and an else clause. In pseudocode, they are envisioned as:</p> <pre><code>if &lt;boolean expression&gt; then &lt;result expression 1&gt;\nelse if &lt;boolean expression&gt; then &lt;result expression 2&gt; (zero or more times)\nelse &lt;result expression 3&gt;\n</code></pre> <p>When an if expression is declared, all return expressions must be the same identical type.</p>"},{"location":"expressions/specialized_record_expressions/#shortcut-behavior","title":"Shortcut Behavior","text":"<p>An if expression is expected to logically short-circuit on a positive outcome. This means that a skipped else/elseif expression cannot cause an error. For example, this should not actually throw an error despite the fact that the cast operation should fail.</p> <pre><code>if 'value' = 'value' then 0\nelse cast('hello' as integer) \n</code></pre>"},{"location":"expressions/specialized_record_expressions/#switch-expression","title":"Switch Expression","text":"<p>Switch expression allow a selection of alternate branches based on the value of a given expression. They are an optimized form of a generic if expression where all conditions are equality to the same value. In pseudocode:</p> <pre><code>switch(value)\n&lt;value 1&gt; =&gt; &lt;return 1&gt; (1 or more times)\n&lt;else&gt; =&gt; &lt;return default&gt;\n</code></pre> <p>Return values for a switch expression must all be of identical type.</p>"},{"location":"expressions/specialized_record_expressions/#shortcut-behavior_1","title":"Shortcut Behavior","text":"<p>As in if expressions, switch expression evaluation should not be interrupted by \u201croads not taken\u201d.</p>"},{"location":"expressions/specialized_record_expressions/#or-list-equality-expression","title":"Or List Equality Expression","text":"<p>A specialized structure that is often used is a large list of possible values. In SQL, these are typically large IN lists. They can be composed from one or more fields. There are two common patterns, single value and multi value. In pseudocode they are represented as:</p> <pre><code>Single Value:\nexpression, [&lt;value1&gt;, &lt;value2&gt;, ... &lt;valueN&gt;]\n\nMulti Value:\n[expressionA, expressionB], [[value1a, value1b], [value2a, value2b].. [valueNa, valueNb]]\n</code></pre> <p>For single value expressions, these are a compact equivalent of <code>expression = value1 OR expression = value2 OR .. OR expression = valueN</code>. When using an expression of this type, two things are required; the types of the test expression and all value expressions that are related must be of the same type. Additionally, a function signature for equality must be available for the expression type used.</p>"},{"location":"expressions/subqueries/","title":"Subqueries","text":"<p>Subqueries are scalar expressions comprised of another query.</p>"},{"location":"expressions/subqueries/#forms","title":"Forms","text":""},{"location":"expressions/subqueries/#scalar","title":"Scalar","text":"<p>Scalar subqueries are subqueries that return one row and one column.</p> Property Description Required Input Input relation Yes"},{"location":"expressions/subqueries/#in-predicate","title":"<code>IN</code> predicate","text":"<p>An <code>IN</code> subquery predicate checks that the left expression is contained in the right subquery.</p>"},{"location":"expressions/subqueries/#examples","title":"Examples","text":"<pre><code>SELECT *\nFROM t1\nWHERE x IN (SELECT * FROM t2)\n</code></pre> <pre><code>SELECT *\nFROM t1\nWHERE (x, y) IN (SELECT a, b FROM t2)\n</code></pre> Property Description Required Needles Expressions whose existence will be checked Yes Haystack Subquery to check Yes"},{"location":"expressions/subqueries/#set-predicates","title":"Set predicates","text":"<p>A set predicate is a predicate over a set of rows in the form of a subquery.</p> <p><code>EXISTS</code> and <code>UNIQUE</code> are common SQL spellings of these kinds of predicates.</p> Property Description Required Operation The operation to perform over the set Yes Tuples Set of tuples to check using the operation Yes"},{"location":"expressions/subqueries/#set-comparisons","title":"Set comparisons","text":"<p>A set comparison subquery is a subquery comparison using <code>ANY</code> or <code>ALL</code> operations.</p>"},{"location":"expressions/subqueries/#examples_1","title":"Examples","text":"<pre><code>SELECT *\nFROM t1\nWHERE x &lt; ANY(SELECT y from t2)\n</code></pre> Property Description Required Reduction operation The kind of reduction to use over the subquery Yes Comparison operation The kind of comparison operation to use Yes Expression Left-hand side expression to check Yes Subquery Subquery to check Yes Protobuf Representation <pre><code>message Subquery {\n  oneof subquery_type {\n    // Scalar subquery\n    Scalar scalar = 1;\n    // x IN y predicate\n    InPredicate in_predicate = 2;\n    // EXISTS/UNIQUE predicate\n    SetPredicate set_predicate = 3;\n    // ANY/ALL predicate\n    SetComparison set_comparison = 4;\n  }\n\n  // A subquery with one row and one column. This is often an aggregate\n  // though not required to be.\n  message Scalar {\n    Rel input = 1;\n  }\n\n  // Predicate checking that the left expression is contained in the right\n  // subquery\n  //\n  // Examples:\n  //\n  // x IN (SELECT * FROM t)\n  // (x, y) IN (SELECT a, b FROM t)\n  message InPredicate {\n    repeated Expression needles = 1;\n    Rel haystack = 2;\n  }\n\n  // A predicate over a set of rows in the form of a subquery\n  // EXISTS and UNIQUE are common SQL forms of this operation.\n  message SetPredicate {\n    enum PredicateOp {\n      PREDICATE_OP_UNSPECIFIED = 0;\n      PREDICATE_OP_EXISTS = 1;\n      PREDICATE_OP_UNIQUE = 2;\n    }\n    // TODO: should allow expressions\n    PredicateOp predicate_op = 1;\n    Rel tuples = 2;\n  }\n\n  // A subquery comparison using ANY or ALL.\n  // Examples:\n  //\n  // SELECT *\n  // FROM t1\n  // WHERE x &lt; ANY(SELECT y from t2)\n  message SetComparison {\n    enum ComparisonOp {\n      COMPARISON_OP_UNSPECIFIED = 0;\n      COMPARISON_OP_EQ = 1;\n      COMPARISON_OP_NE = 2;\n      COMPARISON_OP_LT = 3;\n      COMPARISON_OP_GT = 4;\n      COMPARISON_OP_LE = 5;\n      COMPARISON_OP_GE = 6;\n    }\n\n    enum ReductionOp {\n      REDUCTION_OP_UNSPECIFIED = 0;\n      REDUCTION_OP_ANY = 1;\n      REDUCTION_OP_ALL = 2;\n    }\n\n    // ANY or ALL\n    ReductionOp reduction_op = 1;\n    // A comparison operator\n    ComparisonOp comparison_op = 2;\n    // left side of the expression\n    Expression left = 3;\n    // right side of the expression\n    Rel right = 4;\n  }\n}\n</code></pre>"},{"location":"expressions/table_functions/","title":"Table Functions","text":"<p>Table functions produce zero or more records for each input record. Table functions use a signature similar to scalar functions. However, they are not allowed in the same contexts. </p> <p>to be completed\u2026</p>"},{"location":"expressions/user_defined_functions/","title":"User-Defined Functions","text":"<p>Substrait supports the creation of custom functions using simple extensions, using the facilities described in scalar functions. The functions defined by Substrait use the same mechanism. The extension files for standard functions can be found here.</p> <p>Here\u2019s an example function that doubles its input:</p> <p>Implementation Note</p> <p>This implementation is only defined on 32-bit floats and integers but could be defined on all numbers (and even lists and strings).  The user of the implementation can specify what happens when the resulting value falls outside of the valid range for a 32-bit float (either return NAN or raise an error).</p> <pre><code>%YAML 1.2\n---\nscalar_functions:\n  -\n    name: \"double\"\n    description: \"Double the value\"\n    impls:\n      - args:\n          - name: x\n            value: fp32\n        options:\n          on_domain_error:\n            values: [ NAN, ERROR ]\n        return: fp32\n      - args:\n          - name: x\n            value: i32\n        options:\n          on_domain_error:\n            values: [ NAN, ERROR ]\n        return: i32\n</code></pre>"},{"location":"expressions/window_functions/","title":"Window Functions","text":"<p>Window functions are functions which consume values from multiple records to produce a single output. They are similar to aggregate functions, but also have a focused window of analysis to compare to their partition window. Window functions are similar to scalar values to an end user, producing a single value for each input record. However, the consumption visibility for the production of each single record can be many records.</p> <p>Window function signatures contain all the properties defined for aggregate functions. Additionally, they contain the properties below</p> Property Description Required Inherits All properties defined for aggregate functions. N/A Window Type STREAMING or PARTITION. Describes whether the function needs to see all data for the specific partition operation simultaneously. Operations like SUM can produce values in a streaming manner with no complete visibility of the partition. NTILE requires visibility of the entire partition before it can start producing values. Optional, defaults to PARTITION <p>When binding an aggregate function, the binding must include the following additional properties beyond the standard scalar binding properties:</p> Property Description Required Partition A list of partitioning expressions. False, defaults to a single partition for the entire dataset Lower Bound Bound Following(int64), Bound Trailing(int64) or CurrentRow. False, defaults to start of partition Upper Bound Bound Following(int64), Bound Trailing(int64) or CurrentRow. False, defaults to end of partition"},{"location":"expressions/window_functions/#aggregate-functions-as-window-functions","title":"Aggregate Functions as Window Functions","text":"<p>Aggregate functions can be treated as a window functions with Window Type set to STREAMING.</p> <p>AVG, COUNT, MAX, MIN and SUM are examples of aggregate functions that are commonly allowed in window contexts.</p>"},{"location":"extensions/","title":"Extensions","text":"<p>In many cases, the existing objects in Substrait will be sufficient to accomplish a particular use case. However, it is sometimes helpful to create a new data type, scalar function signature or some other custom representation within a system. For that, Substrait provides a number of extension points.</p>"},{"location":"extensions/#simple-extensions","title":"Simple Extensions","text":"<p>Some kinds of primitives are so frequently extended that Substrait defines a standard YAML format that describes how the extended functionality can be interpreted. This allows different projects/systems to use the YAML definition as a specification so that interoperability isn\u2019t constrained to the base Substrait specification. The main types of extensions that are defined in this manner include the following:</p> <ul> <li>Data types</li> <li>Type variations</li> <li>Scalar Functions</li> <li>Aggregate Functions</li> <li>Window Functions</li> <li>Table Functions</li> </ul> <p>To extend these items, developers can create one or more YAML files at a defined URI that describes the properties of each of these extensions. The YAML file is constructed according to the YAML Schema. Each definition in the file corresponds to the YAML-based serialization of the relevant data structure. If a user only wants to extend one of these types of objects (e.g. types), a developer does not have to provide definitions for the other extension points.</p> <p>A Substrait plan can reference one or more YAML files via URI for extension. In the places where these entities are referenced, they will be referenced using a URI + name reference. The name scheme per type works as follows:</p> Category Naming scheme Type The name as defined on the type object. Type Variation The name as defined on the type variation object. Function Signature A function signature compound name as described below. <p>A YAML file can also reference types and type variations defined in another YAML file. To do this, it must declare the YAML file it depends on using a key-value pair in the <code>dependencies</code> key, where the value is the URI to the YAML file, and the key is a valid identifier that can then be used as an identifier-safe alias for the URI. This alias can then be used as a <code>.</code>-separated namespace prefix wherever a type class or type variation name is expected.</p> <p>For example, if the YAML file at <code>file:///extension_types.yaml</code> defines a type called <code>point</code>, a different YAML file can use the type in a function declaration as follows:</p> <pre><code>dependencies:\n  ext: file:///extension_types.yaml\nscalar_functions:\n- name: distance\n  description: The distance between two points.\n  impls:\n  - args:\n    - name: a\n      value: ext.point\n    - name: b\n      value: ext.point\n    return: f64\n</code></pre> <p>Here, the choice for the name <code>ext</code> is arbitrary, as long as it does not conflict with anything else in the YAML file.</p>"},{"location":"extensions/#function-signature-compound-names","title":"Function Signature Compound Names","text":"<p>A YAML file may contain one or more functions by the same name. The key used in the function extension declaration to reference a function is a combination of the name of the function along with a list of the required input argument types. The format is as follows:</p> <pre><code>&lt;function name&gt;:&lt;short_arg_type0&gt;_&lt;short_arg_type1&gt;_..._&lt;short_arg_typeN&gt;\n</code></pre> <p>Rather than using a full data type representation, the input argument types (<code>short_arg_type</code>) are mapped to single-level short name. The mappings are listed in the table below.</p> <p>Note</p> <p>Every compound function signature must be unique.  If two function implementations in a YAML file would generate the same compound function signature, then the YAML file is invalid and behavior is undefined.</p> Argument Type Signature Name Required Enumeration req i8 i8 i16 i16 i32 i32 i64 i64 fp32 fp32 fp64 fp64 string str binary vbin boolean bool timestamp ts timestamp_tz tstz date date time time interval_year iyear interval_day iday uuid uuid fixedchar&lt;N&gt; fchar varchar&lt;N&gt; vchar fixedbinary&lt;N&gt; fbin decimal&lt;P,S&gt; dec precision_timestamp&lt;P&gt; pts precision_timestamp_tz&lt;P&gt; ptstz struct&lt;T1,T2,\u2026,TN&gt; struct list&lt;T&gt; list map&lt;K,V&gt; map any[\\d]? any user defined type u!name"},{"location":"extensions/#examples","title":"Examples","text":"Function Signature Function Name <code>add(optional enumeration, i8, i8) =&gt; i8</code> <code>add:i8_i8</code> <code>avg(fp32) =&gt; fp32</code> <code>avg:fp32</code> <code>extract(required enumeration, timestamp) =&gt; i64</code> <code>extract:req_ts</code> <code>sum(any1) =&gt; any1</code> <code>sum:any</code>"},{"location":"extensions/#any-types","title":"Any Types","text":"<pre><code>scalar_functions:\n- name: foo\n  impls:\n  - args:\n    - name: a\n      value: any\n    - name: b\n      value: any\n    return: int64\n</code></pre> <p>The <code>any</code> type indicates that the argument can take any possible type. In the <code>foo</code> function above, arguments <code>a</code> and <code>b</code> can be of any type, even different ones in the same function invocation.</p> <p><pre><code>scalar_functions:\n- name: bar\n  impls:\n  - args:\n    - name: a\n      value: any1\n    - name: b\n      value: any1\n    return: int64\n</code></pre> The <code>any[\\d]</code> types (i.e. <code>any1</code>, <code>any2</code>, \u2026, <code>any9</code>) impose an additional restriction. Within a single function invocation, all any types with same numeric suffix must be of the same type. In the <code>bar</code> function above, arguments <code>a</code> and <code>b</code> can have any type as long as both types are the same.</p>"},{"location":"extensions/#advanced-extensions","title":"Advanced Extensions","text":"<p>Less common extensions can be extended using customization support at the serialization level. This includes the following kinds of extensions:</p> Extension Type Description Relation Modification (semantic) Extensions to an existing relation that will alter the semantics of that relation. These kinds of extensions require that any plan consumer understand the extension to be able to manipulate or execute that operator. Ignoring these extensions will result in an incorrect interpretation of the plan. An example extension might be creating a customized version of Aggregate that can optionally apply a filter before aggregating the data. Note: Semantic-changing extensions shouldn\u2019t change the core characteristics of the underlying relation. For example, they should not change the default direct output field ordering, change the number of fields output or change the behavior of physical property characteristics. If one needs to change one of these behaviors, one should define a new relation as described below. Relation Modification (optimization) Extensions to an existing relation that can improve the efficiency of a plan consumer but don\u2019t fundamentally change the behavior of the operation. An example might be an estimated amount of memory the relation is expected to use or a particular algorithmic pattern that is perceived to be optimal. New Relations Creates an entirely new kind of relation. It is the most flexible way to extend Substrait but also make the Substrait plan the least interoperable. In most cases it is better to use a semantic changing relation as oppposed to a new relation as it means existing code patterns can easily be extended to work with the additional properties. New Read Types Defines a new subcategory of read that can be used in a ReadRel. One of Substrait is to provide a fairly extensive set of read patterns within the project as opposed to requiring people to define new types externally. As such, we suggest that you first talk with the Substrait community to determine whether you read type can be incorporated directly in the core specification. New Write Types Similar to a read type but for writes. As with reads, the community recommends that interested extenders first discuss with the community about developing new write types in the community before using the extension mechanisms. Plan Extensions Semantic and/or optimization based additions at the plan level. <p>Because extension mechanisms are different for each serialization format, please refer to the corresponding serialization sections to understand how these extensions are defined in more detail.</p>"},{"location":"extensions/functions_aggregate_approx/","title":"functions_aggregate_approx.yaml","text":"<p>This document file is generated for functions_aggregate_approx.yaml</p>"},{"location":"extensions/functions_aggregate_approx/#aggregate-functions","title":"Aggregate Functions","text":""},{"location":"extensions/functions_aggregate_approx/#approx_count_distinct","title":"approx_count_distinct","text":"<p>Implementations: approx_count_distinct(<code>x</code>): -&gt; <code>return_type</code>  0. approx_count_distinct(<code>any</code>): -&gt; <code>i64</code></p> <p>Calculates the approximate number of rows that contain distinct values of the expression argument using HyperLogLog. This function provides an alternative to the COUNT (DISTINCT expression) function, which returns the exact number of rows that contain distinct values of an expression. APPROX_COUNT_DISTINCT processes large amounts of data significantly faster than COUNT, with negligible deviation from the exact result.</p>"},{"location":"extensions/functions_aggregate_decimal_output/","title":"functions_aggregate_decimal_output.yaml","text":"<p>This document file is generated for functions_aggregate_decimal_output.yaml</p>"},{"location":"extensions/functions_aggregate_decimal_output/#aggregate-functions","title":"Aggregate Functions","text":""},{"location":"extensions/functions_aggregate_decimal_output/#count","title":"count","text":"<p>Implementations: count(<code>x</code>, <code>option:overflow</code>): -&gt; <code>return_type</code>  0. count(<code>any</code>, <code>option:overflow</code>): -&gt; <code>decimal&lt;38,0&gt;</code></p> <p>Count a set of values. Result is returned as a decimal instead of i64.</p> Options: <li>overflow ['SILENT', 'SATURATE', 'ERROR'] </li>"},{"location":"extensions/functions_aggregate_decimal_output/#count_1","title":"count","text":"<p>Implementations:</p> <p>Count a set of records (not field referenced). Result is returned as a decimal instead of i64.</p>"},{"location":"extensions/functions_aggregate_decimal_output/#approx_count_distinct","title":"approx_count_distinct","text":"<p>Implementations: approx_count_distinct(<code>x</code>): -&gt; <code>return_type</code>  0. approx_count_distinct(<code>any</code>): -&gt; <code>decimal&lt;38,0&gt;</code></p> <p>Calculates the approximate number of rows that contain distinct values of the expression argument using HyperLogLog. This function provides an alternative to the COUNT (DISTINCT expression) function, which returns the exact number of rows that contain distinct values of an expression. APPROX_COUNT_DISTINCT processes large amounts of data significantly faster than COUNT, with negligible deviation from the exact result. Result is returned as a decimal instead of i64.</p>"},{"location":"extensions/functions_aggregate_generic/","title":"functions_aggregate_generic.yaml","text":"<p>This document file is generated for functions_aggregate_generic.yaml</p>"},{"location":"extensions/functions_aggregate_generic/#aggregate-functions","title":"Aggregate Functions","text":""},{"location":"extensions/functions_aggregate_generic/#count","title":"count","text":"<p>Implementations: count(<code>x</code>, <code>option:overflow</code>): -&gt; <code>return_type</code>  0. count(<code>any</code>, <code>option:overflow</code>): -&gt; <code>i64</code></p> <p>Count a set of values</p> Options: <li>overflow ['SILENT', 'SATURATE', 'ERROR'] </li>"},{"location":"extensions/functions_aggregate_generic/#count_1","title":"count","text":"<p>Implementations:</p> <p>Count a set of records (not field referenced)</p>"},{"location":"extensions/functions_aggregate_generic/#any_value","title":"any_value","text":"<p>Implementations: any_value(<code>x</code>, <code>option:ignore_nulls</code>): -&gt; <code>return_type</code>  0. any_value(<code>any1</code>, <code>option:ignore_nulls</code>): -&gt; <code>any1?</code></p> <p>*Selects an arbitrary value from a group of values. If the input is empty, the function returns null. *</p> Options: <li>ignore_nulls ['TRUE', 'FALSE'] </li>"},{"location":"extensions/functions_arithmetic/","title":"functions_arithmetic.yaml","text":"<p>This document file is generated for functions_arithmetic.yaml</p>"},{"location":"extensions/functions_arithmetic/#scalar-functions","title":"Scalar Functions","text":""},{"location":"extensions/functions_arithmetic/#add","title":"add","text":"<p>Implementations: add(<code>x</code>, <code>y</code>, <code>option:overflow</code>): -&gt; <code>return_type</code>  0. add(<code>i8</code>, <code>i8</code>, <code>option:overflow</code>): -&gt; <code>i8</code> 1. add(<code>i16</code>, <code>i16</code>, <code>option:overflow</code>): -&gt; <code>i16</code> 2. add(<code>i32</code>, <code>i32</code>, <code>option:overflow</code>): -&gt; <code>i32</code> 3. add(<code>i64</code>, <code>i64</code>, <code>option:overflow</code>): -&gt; <code>i64</code> 4. add(<code>fp32</code>, <code>fp32</code>, <code>option:rounding</code>): -&gt; <code>fp32</code> 5. add(<code>fp64</code>, <code>fp64</code>, <code>option:rounding</code>): -&gt; <code>fp64</code></p> <p>Add two values.</p> Options: <li>overflow ['SILENT', 'SATURATE', 'ERROR'] </li> <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li>"},{"location":"extensions/functions_arithmetic/#subtract","title":"subtract","text":"<p>Implementations: subtract(<code>x</code>, <code>y</code>, <code>option:overflow</code>): -&gt; <code>return_type</code>  0. subtract(<code>i8</code>, <code>i8</code>, <code>option:overflow</code>): -&gt; <code>i8</code> 1. subtract(<code>i16</code>, <code>i16</code>, <code>option:overflow</code>): -&gt; <code>i16</code> 2. subtract(<code>i32</code>, <code>i32</code>, <code>option:overflow</code>): -&gt; <code>i32</code> 3. subtract(<code>i64</code>, <code>i64</code>, <code>option:overflow</code>): -&gt; <code>i64</code> 4. subtract(<code>fp32</code>, <code>fp32</code>, <code>option:rounding</code>): -&gt; <code>fp32</code> 5. subtract(<code>fp64</code>, <code>fp64</code>, <code>option:rounding</code>): -&gt; <code>fp64</code></p> <p>Subtract one value from another.</p> Options: <li>overflow ['SILENT', 'SATURATE', 'ERROR'] </li> <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li>"},{"location":"extensions/functions_arithmetic/#multiply","title":"multiply","text":"<p>Implementations: multiply(<code>x</code>, <code>y</code>, <code>option:overflow</code>): -&gt; <code>return_type</code>  0. multiply(<code>i8</code>, <code>i8</code>, <code>option:overflow</code>): -&gt; <code>i8</code> 1. multiply(<code>i16</code>, <code>i16</code>, <code>option:overflow</code>): -&gt; <code>i16</code> 2. multiply(<code>i32</code>, <code>i32</code>, <code>option:overflow</code>): -&gt; <code>i32</code> 3. multiply(<code>i64</code>, <code>i64</code>, <code>option:overflow</code>): -&gt; <code>i64</code> 4. multiply(<code>fp32</code>, <code>fp32</code>, <code>option:rounding</code>): -&gt; <code>fp32</code> 5. multiply(<code>fp64</code>, <code>fp64</code>, <code>option:rounding</code>): -&gt; <code>fp64</code></p> <p>Multiply two values.</p> Options: <li>overflow ['SILENT', 'SATURATE', 'ERROR'] </li> <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li>"},{"location":"extensions/functions_arithmetic/#divide","title":"divide","text":"<p>Implementations: divide(<code>x</code>, <code>y</code>, <code>option:overflow</code>, <code>option:on_domain_error</code>, <code>option:on_division_by_zero</code>): -&gt; <code>return_type</code>  0. divide(<code>i8</code>, <code>i8</code>, <code>option:overflow</code>, <code>option:on_domain_error</code>, <code>option:on_division_by_zero</code>): -&gt; <code>i8</code> 1. divide(<code>i16</code>, <code>i16</code>, <code>option:overflow</code>, <code>option:on_domain_error</code>, <code>option:on_division_by_zero</code>): -&gt; <code>i16</code> 2. divide(<code>i32</code>, <code>i32</code>, <code>option:overflow</code>, <code>option:on_domain_error</code>, <code>option:on_division_by_zero</code>): -&gt; <code>i32</code> 3. divide(<code>i64</code>, <code>i64</code>, <code>option:overflow</code>, <code>option:on_domain_error</code>, <code>option:on_division_by_zero</code>): -&gt; <code>i64</code> 4. divide(<code>fp32</code>, <code>fp32</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_division_by_zero</code>): -&gt; <code>fp32</code> 5. divide(<code>fp64</code>, <code>fp64</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_division_by_zero</code>): -&gt; <code>fp64</code></p> <p>*Divide x by y. In the case of integer division, partial values are truncated (i.e. rounded towards 0). The <code>on_division_by_zero</code> option governs behavior in cases where y is 0.  If the option is IEEE then the IEEE754 standard is followed: all values except \u00b1infinity return NaN and \u00b1infinity are unchanged. If the option is LIMIT then the result is \u00b1infinity in all cases. If either x or y are NaN then behavior will be governed by <code>on_domain_error</code>. If x and y are both \u00b1infinity, behavior will be governed by <code>on_domain_error</code>. *</p> Options: <li>overflow ['SILENT', 'SATURATE', 'ERROR'] </li> <li>on_domain_error ['NULL', 'ERROR'] </li> <li>on_division_by_zero ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li> <li>rounding ['NAN', 'NULL', 'ERROR'] </li> <li>overflow ['IEEE', 'LIMIT', 'NULL', 'ERROR'] </li>"},{"location":"extensions/functions_arithmetic/#negate","title":"negate","text":"<p>Implementations: negate(<code>x</code>, <code>option:overflow</code>): -&gt; <code>return_type</code>  0. negate(<code>i8</code>, <code>option:overflow</code>): -&gt; <code>i8</code> 1. negate(<code>i16</code>, <code>option:overflow</code>): -&gt; <code>i16</code> 2. negate(<code>i32</code>, <code>option:overflow</code>): -&gt; <code>i32</code> 3. negate(<code>i64</code>, <code>option:overflow</code>): -&gt; <code>i64</code> 4. negate(<code>fp32</code>): -&gt; <code>fp32</code> 5. negate(<code>fp64</code>): -&gt; <code>fp64</code></p> <p>Negation of the value</p> Options: <li>overflow ['SILENT', 'SATURATE', 'ERROR'] </li>"},{"location":"extensions/functions_arithmetic/#modulus","title":"modulus","text":"<p>Implementations: modulus(<code>x</code>, <code>y</code>, <code>option:division_type</code>, <code>option:overflow</code>, <code>option:on_domain_error</code>): -&gt; <code>return_type</code>  0. modulus(<code>i8</code>, <code>i8</code>, <code>option:division_type</code>, <code>option:overflow</code>, <code>option:on_domain_error</code>): -&gt; <code>i8</code> 1. modulus(<code>i16</code>, <code>i16</code>, <code>option:division_type</code>, <code>option:overflow</code>, <code>option:on_domain_error</code>): -&gt; <code>i16</code> 2. modulus(<code>i32</code>, <code>i32</code>, <code>option:division_type</code>, <code>option:overflow</code>, <code>option:on_domain_error</code>): -&gt; <code>i32</code> 3. modulus(<code>i64</code>, <code>i64</code>, <code>option:division_type</code>, <code>option:overflow</code>, <code>option:on_domain_error</code>): -&gt; <code>i64</code></p> <p>*Calculate the remainder \u00ae when dividing dividend (x) by divisor (y). In mathematics, many conventions for the modulus (mod) operation exists. The result of a mod operation depends on the software implementation and underlying hardware. Substrait is a format for describing compute operations on structured data and designed for interoperability. Therefore the user is responsible for determining a definition of division as defined by the quotient (q). The following basic conditions of division are satisfied: (1) q \u2208 \u2124 (the quotient is an integer) (2) x = y * q + r (division rule) (3) abs\u00ae &lt; abs(y) where q is the quotient. The <code>division_type</code> option determines the mathematical definition of quotient to use in the above definition of division. When <code>division_type</code>=TRUNCATE, q = trunc(x/y). When <code>division_type</code>=FLOOR, q = floor(x/y). In the cases of TRUNCATE and FLOOR division: remainder r = x - round_func(x/y) The <code>on_domain_error</code> option governs behavior in cases where y is 0, y is \u00b1inf, or x is \u00b1inf. In these cases the mod is undefined. The <code>overflow</code> option governs behavior when integer overflow occurs. If x and y are both 0 or both \u00b1infinity, behavior will be governed by <code>on_domain_error</code>. *</p> Options: <li>division_type ['TRUNCATE', 'FLOOR'] </li> <li>overflow ['SILENT', 'SATURATE', 'ERROR'] </li> <li>on_domain_error ['NULL', 'ERROR'] </li>"},{"location":"extensions/functions_arithmetic/#power","title":"power","text":"<p>Implementations: power(<code>x</code>, <code>y</code>, <code>option:overflow</code>): -&gt; <code>return_type</code>  0. power(<code>i64</code>, <code>i64</code>, <code>option:overflow</code>): -&gt; <code>i64</code> 1. power(<code>fp32</code>, <code>fp32</code>): -&gt; <code>fp32</code> 2. power(<code>fp64</code>, <code>fp64</code>): -&gt; <code>fp64</code></p> <p>Take the power with x as the base and y as exponent.</p> Options: <li>overflow ['SILENT', 'SATURATE', 'ERROR'] </li>"},{"location":"extensions/functions_arithmetic/#sqrt","title":"sqrt","text":"<p>Implementations: sqrt(<code>x</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>): -&gt; <code>return_type</code>  0. sqrt(<code>i64</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>): -&gt; <code>fp64</code> 1. sqrt(<code>fp32</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>): -&gt; <code>fp32</code> 2. sqrt(<code>fp64</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>): -&gt; <code>fp64</code></p> <p>Square root of the value</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li> <li>on_domain_error ['NAN', 'ERROR'] </li>"},{"location":"extensions/functions_arithmetic/#exp","title":"exp","text":"<p>Implementations: exp(<code>x</code>, <code>option:rounding</code>): -&gt; <code>return_type</code>  0. exp(<code>i64</code>, <code>option:rounding</code>): -&gt; <code>fp64</code> 1. exp(<code>fp32</code>, <code>option:rounding</code>): -&gt; <code>fp32</code> 2. exp(<code>fp64</code>, <code>option:rounding</code>): -&gt; <code>fp64</code></p> <p>The mathematical constant e, raised to the power of the value.</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li>"},{"location":"extensions/functions_arithmetic/#cos","title":"cos","text":"<p>Implementations: cos(<code>x</code>, <code>option:rounding</code>): -&gt; <code>return_type</code>  0. cos(<code>fp32</code>, <code>option:rounding</code>): -&gt; <code>fp32</code> 1. cos(<code>fp64</code>, <code>option:rounding</code>): -&gt; <code>fp64</code></p> <p>Get the cosine of a value in radians.</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li>"},{"location":"extensions/functions_arithmetic/#sin","title":"sin","text":"<p>Implementations: sin(<code>x</code>, <code>option:rounding</code>): -&gt; <code>return_type</code>  0. sin(<code>fp32</code>, <code>option:rounding</code>): -&gt; <code>fp32</code> 1. sin(<code>fp64</code>, <code>option:rounding</code>): -&gt; <code>fp64</code></p> <p>Get the sine of a value in radians.</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li>"},{"location":"extensions/functions_arithmetic/#tan","title":"tan","text":"<p>Implementations: tan(<code>x</code>, <code>option:rounding</code>): -&gt; <code>return_type</code>  0. tan(<code>fp32</code>, <code>option:rounding</code>): -&gt; <code>fp32</code> 1. tan(<code>fp64</code>, <code>option:rounding</code>): -&gt; <code>fp64</code></p> <p>Get the tangent of a value in radians.</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li>"},{"location":"extensions/functions_arithmetic/#cosh","title":"cosh","text":"<p>Implementations: cosh(<code>x</code>, <code>option:rounding</code>): -&gt; <code>return_type</code>  0. cosh(<code>fp32</code>, <code>option:rounding</code>): -&gt; <code>fp32</code> 1. cosh(<code>fp64</code>, <code>option:rounding</code>): -&gt; <code>fp64</code></p> <p>Get the hyperbolic cosine of a value in radians.</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li>"},{"location":"extensions/functions_arithmetic/#sinh","title":"sinh","text":"<p>Implementations: sinh(<code>x</code>, <code>option:rounding</code>): -&gt; <code>return_type</code>  0. sinh(<code>fp32</code>, <code>option:rounding</code>): -&gt; <code>fp32</code> 1. sinh(<code>fp64</code>, <code>option:rounding</code>): -&gt; <code>fp64</code></p> <p>Get the hyperbolic sine of a value in radians.</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li>"},{"location":"extensions/functions_arithmetic/#tanh","title":"tanh","text":"<p>Implementations: tanh(<code>x</code>, <code>option:rounding</code>): -&gt; <code>return_type</code>  0. tanh(<code>fp32</code>, <code>option:rounding</code>): -&gt; <code>fp32</code> 1. tanh(<code>fp64</code>, <code>option:rounding</code>): -&gt; <code>fp64</code></p> <p>Get the hyperbolic tangent of a value in radians.</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li>"},{"location":"extensions/functions_arithmetic/#acos","title":"acos","text":"<p>Implementations: acos(<code>x</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>): -&gt; <code>return_type</code>  0. acos(<code>fp32</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>): -&gt; <code>fp32</code> 1. acos(<code>fp64</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>): -&gt; <code>fp64</code></p> <p>Get the arccosine of a value in radians.</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li> <li>on_domain_error ['NAN', 'ERROR'] </li>"},{"location":"extensions/functions_arithmetic/#asin","title":"asin","text":"<p>Implementations: asin(<code>x</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>): -&gt; <code>return_type</code>  0. asin(<code>fp32</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>): -&gt; <code>fp32</code> 1. asin(<code>fp64</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>): -&gt; <code>fp64</code></p> <p>Get the arcsine of a value in radians.</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li> <li>on_domain_error ['NAN', 'ERROR'] </li>"},{"location":"extensions/functions_arithmetic/#atan","title":"atan","text":"<p>Implementations: atan(<code>x</code>, <code>option:rounding</code>): -&gt; <code>return_type</code>  0. atan(<code>fp32</code>, <code>option:rounding</code>): -&gt; <code>fp32</code> 1. atan(<code>fp64</code>, <code>option:rounding</code>): -&gt; <code>fp64</code></p> <p>Get the arctangent of a value in radians.</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li>"},{"location":"extensions/functions_arithmetic/#acosh","title":"acosh","text":"<p>Implementations: acosh(<code>x</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>): -&gt; <code>return_type</code>  0. acosh(<code>fp32</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>): -&gt; <code>fp32</code> 1. acosh(<code>fp64</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>): -&gt; <code>fp64</code></p> <p>Get the hyperbolic arccosine of a value in radians.</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li> <li>on_domain_error ['NAN', 'ERROR'] </li>"},{"location":"extensions/functions_arithmetic/#asinh","title":"asinh","text":"<p>Implementations: asinh(<code>x</code>, <code>option:rounding</code>): -&gt; <code>return_type</code>  0. asinh(<code>fp32</code>, <code>option:rounding</code>): -&gt; <code>fp32</code> 1. asinh(<code>fp64</code>, <code>option:rounding</code>): -&gt; <code>fp64</code></p> <p>Get the hyperbolic arcsine of a value in radians.</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li>"},{"location":"extensions/functions_arithmetic/#atanh","title":"atanh","text":"<p>Implementations: atanh(<code>x</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>): -&gt; <code>return_type</code>  0. atanh(<code>fp32</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>): -&gt; <code>fp32</code> 1. atanh(<code>fp64</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>): -&gt; <code>fp64</code></p> <p>Get the hyperbolic arctangent of a value in radians.</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li> <li>on_domain_error ['NAN', 'ERROR'] </li>"},{"location":"extensions/functions_arithmetic/#atan2","title":"atan2","text":"<p>Implementations: atan2(<code>x</code>, <code>y</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>): -&gt; <code>return_type</code>  0. atan2(<code>fp32</code>, <code>fp32</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>): -&gt; <code>fp32</code> 1. atan2(<code>fp64</code>, <code>fp64</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>): -&gt; <code>fp64</code></p> <p>Get the arctangent of values given as x/y pairs.</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li> <li>on_domain_error ['NAN', 'ERROR'] </li>"},{"location":"extensions/functions_arithmetic/#radians","title":"radians","text":"<p>Implementations: radians(<code>x</code>, <code>option:rounding</code>): -&gt; <code>return_type</code>  0. radians(<code>fp32</code>, <code>option:rounding</code>): -&gt; <code>fp32</code> 1. radians(<code>fp64</code>, <code>option:rounding</code>): -&gt; <code>fp64</code></p> <p>*Converts angle <code>x</code> in degrees to radians. *</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li>"},{"location":"extensions/functions_arithmetic/#degrees","title":"degrees","text":"<p>Implementations: degrees(<code>x</code>, <code>option:rounding</code>): -&gt; <code>return_type</code>  0. degrees(<code>fp32</code>, <code>option:rounding</code>): -&gt; <code>fp32</code> 1. degrees(<code>fp64</code>, <code>option:rounding</code>): -&gt; <code>fp64</code></p> <p>*Converts angle <code>x</code> in radians to degrees. *</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li>"},{"location":"extensions/functions_arithmetic/#abs","title":"abs","text":"<p>Implementations: abs(<code>x</code>, <code>option:overflow</code>): -&gt; <code>return_type</code>  0. abs(<code>i8</code>, <code>option:overflow</code>): -&gt; <code>i8</code> 1. abs(<code>i16</code>, <code>option:overflow</code>): -&gt; <code>i16</code> 2. abs(<code>i32</code>, <code>option:overflow</code>): -&gt; <code>i32</code> 3. abs(<code>i64</code>, <code>option:overflow</code>): -&gt; <code>i64</code> 4. abs(<code>fp32</code>): -&gt; <code>fp32</code> 5. abs(<code>fp64</code>): -&gt; <code>fp64</code></p> <p>*Calculate the absolute value of the argument. Integer values allow the specification of overflow behavior to handle the unevenness of the twos complement, e.g. Int8 range [-128 : 127]. *</p> Options: <li>overflow ['SILENT', 'SATURATE', 'ERROR'] </li>"},{"location":"extensions/functions_arithmetic/#sign","title":"sign","text":"<p>Implementations: sign(<code>x</code>): -&gt; <code>return_type</code>  0. sign(<code>i8</code>): -&gt; <code>i8</code> 1. sign(<code>i16</code>): -&gt; <code>i16</code> 2. sign(<code>i32</code>): -&gt; <code>i32</code> 3. sign(<code>i64</code>): -&gt; <code>i64</code> 4. sign(<code>fp32</code>): -&gt; <code>fp32</code> 5. sign(<code>fp64</code>): -&gt; <code>fp64</code></p> <p>*Return the signedness of the argument. Integer values return signedness with the same type as the input. Possible return values are [-1, 0, 1] Floating point values return signedness with the same type as the input. Possible return values are [-1.0, -0.0, 0.0, 1.0, NaN] *</p>"},{"location":"extensions/functions_arithmetic/#factorial","title":"factorial","text":"<p>Implementations: factorial(<code>n</code>, <code>option:overflow</code>): -&gt; <code>return_type</code>  0. factorial(<code>i32</code>, <code>option:overflow</code>): -&gt; <code>i32</code> 1. factorial(<code>i64</code>, <code>option:overflow</code>): -&gt; <code>i64</code></p> <p>*Return the factorial of a given integer input. The factorial of 0! is 1 by convention. Negative inputs will raise an error. *</p> Options: <li>overflow ['SILENT', 'SATURATE', 'ERROR'] </li>"},{"location":"extensions/functions_arithmetic/#bitwise_not","title":"bitwise_not","text":"<p>Implementations: bitwise_not(<code>x</code>): -&gt; <code>return_type</code>  0. bitwise_not(<code>i8</code>): -&gt; <code>i8</code> 1. bitwise_not(<code>i16</code>): -&gt; <code>i16</code> 2. bitwise_not(<code>i32</code>): -&gt; <code>i32</code> 3. bitwise_not(<code>i64</code>): -&gt; <code>i64</code></p> <p>*Return the bitwise NOT result for one integer input. *</p>"},{"location":"extensions/functions_arithmetic/#bitwise_and","title":"bitwise_and","text":"<p>Implementations: bitwise_and(<code>x</code>, <code>y</code>): -&gt; <code>return_type</code>  0. bitwise_and(<code>i8</code>, <code>i8</code>): -&gt; <code>i8</code> 1. bitwise_and(<code>i16</code>, <code>i16</code>): -&gt; <code>i16</code> 2. bitwise_and(<code>i32</code>, <code>i32</code>): -&gt; <code>i32</code> 3. bitwise_and(<code>i64</code>, <code>i64</code>): -&gt; <code>i64</code></p> <p>*Return the bitwise AND result for two integer inputs. *</p>"},{"location":"extensions/functions_arithmetic/#bitwise_or","title":"bitwise_or","text":"<p>Implementations: bitwise_or(<code>x</code>, <code>y</code>): -&gt; <code>return_type</code>  0. bitwise_or(<code>i8</code>, <code>i8</code>): -&gt; <code>i8</code> 1. bitwise_or(<code>i16</code>, <code>i16</code>): -&gt; <code>i16</code> 2. bitwise_or(<code>i32</code>, <code>i32</code>): -&gt; <code>i32</code> 3. bitwise_or(<code>i64</code>, <code>i64</code>): -&gt; <code>i64</code></p> <p>*Return the bitwise OR result for two given integer inputs. *</p>"},{"location":"extensions/functions_arithmetic/#bitwise_xor","title":"bitwise_xor","text":"<p>Implementations: bitwise_xor(<code>x</code>, <code>y</code>): -&gt; <code>return_type</code>  0. bitwise_xor(<code>i8</code>, <code>i8</code>): -&gt; <code>i8</code> 1. bitwise_xor(<code>i16</code>, <code>i16</code>): -&gt; <code>i16</code> 2. bitwise_xor(<code>i32</code>, <code>i32</code>): -&gt; <code>i32</code> 3. bitwise_xor(<code>i64</code>, <code>i64</code>): -&gt; <code>i64</code></p> <p>*Return the bitwise XOR result for two integer inputs. *</p>"},{"location":"extensions/functions_arithmetic/#aggregate-functions","title":"Aggregate Functions","text":""},{"location":"extensions/functions_arithmetic/#sum","title":"sum","text":"<p>Implementations: sum(<code>x</code>, <code>option:overflow</code>): -&gt; <code>return_type</code>  0. sum(<code>i8</code>, <code>option:overflow</code>): -&gt; <code>i64?</code> 1. sum(<code>i16</code>, <code>option:overflow</code>): -&gt; <code>i64?</code> 2. sum(<code>i32</code>, <code>option:overflow</code>): -&gt; <code>i64?</code> 3. sum(<code>i64</code>, <code>option:overflow</code>): -&gt; <code>i64?</code> 4. sum(<code>fp32</code>, <code>option:overflow</code>): -&gt; <code>fp64?</code> 5. sum(<code>fp64</code>, <code>option:overflow</code>): -&gt; <code>fp64?</code></p> <p>Sum a set of values. The sum of zero elements yields null.</p> Options: <li>overflow ['SILENT', 'SATURATE', 'ERROR'] </li>"},{"location":"extensions/functions_arithmetic/#sum0","title":"sum0","text":"<p>Implementations: sum0(<code>x</code>, <code>option:overflow</code>): -&gt; <code>return_type</code>  0. sum0(<code>i8</code>, <code>option:overflow</code>): -&gt; <code>i64</code> 1. sum0(<code>i16</code>, <code>option:overflow</code>): -&gt; <code>i64</code> 2. sum0(<code>i32</code>, <code>option:overflow</code>): -&gt; <code>i64</code> 3. sum0(<code>i64</code>, <code>option:overflow</code>): -&gt; <code>i64</code> 4. sum0(<code>fp32</code>, <code>option:overflow</code>): -&gt; <code>fp64</code> 5. sum0(<code>fp64</code>, <code>option:overflow</code>): -&gt; <code>fp64</code></p> <p>*Sum a set of values. The sum of zero elements yields zero. Null values are ignored. *</p> Options: <li>overflow ['SILENT', 'SATURATE', 'ERROR'] </li>"},{"location":"extensions/functions_arithmetic/#avg","title":"avg","text":"<p>Implementations: avg(<code>x</code>, <code>option:overflow</code>): -&gt; <code>return_type</code>  0. avg(<code>i8</code>, <code>option:overflow</code>): -&gt; <code>i8?</code> 1. avg(<code>i16</code>, <code>option:overflow</code>): -&gt; <code>i16?</code> 2. avg(<code>i32</code>, <code>option:overflow</code>): -&gt; <code>i32?</code> 3. avg(<code>i64</code>, <code>option:overflow</code>): -&gt; <code>i64?</code> 4. avg(<code>fp32</code>, <code>option:overflow</code>): -&gt; <code>fp32?</code> 5. avg(<code>fp64</code>, <code>option:overflow</code>): -&gt; <code>fp64?</code></p> <p>Average a set of values. For integral types, this truncates partial values.</p> Options: <li>overflow ['SILENT', 'SATURATE', 'ERROR'] </li>"},{"location":"extensions/functions_arithmetic/#min","title":"min","text":"<p>Implementations: min(<code>x</code>): -&gt; <code>return_type</code>  0. min(<code>i8</code>): -&gt; <code>i8?</code> 1. min(<code>i16</code>): -&gt; <code>i16?</code> 2. min(<code>i32</code>): -&gt; <code>i32?</code> 3. min(<code>i64</code>): -&gt; <code>i64?</code> 4. min(<code>fp32</code>): -&gt; <code>fp32?</code> 5. min(<code>fp64</code>): -&gt; <code>fp64?</code></p> <p>Min a set of values.</p>"},{"location":"extensions/functions_arithmetic/#max","title":"max","text":"<p>Implementations: max(<code>x</code>): -&gt; <code>return_type</code>  0. max(<code>i8</code>): -&gt; <code>i8?</code> 1. max(<code>i16</code>): -&gt; <code>i16?</code> 2. max(<code>i32</code>): -&gt; <code>i32?</code> 3. max(<code>i64</code>): -&gt; <code>i64?</code> 4. max(<code>fp32</code>): -&gt; <code>fp32?</code> 5. max(<code>fp64</code>): -&gt; <code>fp64?</code></p> <p>Max a set of values.</p>"},{"location":"extensions/functions_arithmetic/#product","title":"product","text":"<p>Implementations: product(<code>x</code>, <code>option:overflow</code>): -&gt; <code>return_type</code>  0. product(<code>i8</code>, <code>option:overflow</code>): -&gt; <code>i8</code> 1. product(<code>i16</code>, <code>option:overflow</code>): -&gt; <code>i16</code> 2. product(<code>i32</code>, <code>option:overflow</code>): -&gt; <code>i32</code> 3. product(<code>i64</code>, <code>option:overflow</code>): -&gt; <code>i64</code> 4. product(<code>fp32</code>, <code>option:rounding</code>): -&gt; <code>fp32</code> 5. product(<code>fp64</code>, <code>option:rounding</code>): -&gt; <code>fp64</code></p> <p>Product of a set of values. Returns 1 for empty input.</p> Options: <li>overflow ['SILENT', 'SATURATE', 'ERROR'] </li> <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li>"},{"location":"extensions/functions_arithmetic/#std_dev","title":"std_dev","text":"<p>Implementations: std_dev(<code>x</code>, <code>option:rounding</code>, <code>option:distribution</code>): -&gt; <code>return_type</code>  0. std_dev(<code>fp32</code>, <code>option:rounding</code>, <code>option:distribution</code>): -&gt; <code>fp32?</code> 1. std_dev(<code>fp64</code>, <code>option:rounding</code>, <code>option:distribution</code>): -&gt; <code>fp64?</code></p> <p>Calculates standard-deviation for a set of values.</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li> <li>distribution ['SAMPLE', 'POPULATION'] </li>"},{"location":"extensions/functions_arithmetic/#variance","title":"variance","text":"<p>Implementations: variance(<code>x</code>, <code>option:rounding</code>, <code>option:distribution</code>): -&gt; <code>return_type</code>  0. variance(<code>fp32</code>, <code>option:rounding</code>, <code>option:distribution</code>): -&gt; <code>fp32?</code> 1. variance(<code>fp64</code>, <code>option:rounding</code>, <code>option:distribution</code>): -&gt; <code>fp64?</code></p> <p>Calculates variance for a set of values.</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li> <li>distribution ['SAMPLE', 'POPULATION'] </li>"},{"location":"extensions/functions_arithmetic/#corr","title":"corr","text":"<p>Implementations: corr(<code>x</code>, <code>y</code>, <code>option:rounding</code>): -&gt; <code>return_type</code>  0. corr(<code>fp32</code>, <code>fp32</code>, <code>option:rounding</code>): -&gt; <code>fp32?</code> 1. corr(<code>fp64</code>, <code>fp64</code>, <code>option:rounding</code>): -&gt; <code>fp64?</code></p> <p>*Calculates the value of Pearson\u2019s correlation coefficient between <code>x</code> and <code>y</code>. If there is no input, null is returned. *</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li>"},{"location":"extensions/functions_arithmetic/#mode","title":"mode","text":"<p>Implementations: mode(<code>x</code>): -&gt; <code>return_type</code>  0. mode(<code>i8</code>): -&gt; <code>i8?</code> 1. mode(<code>i16</code>): -&gt; <code>i16?</code> 2. mode(<code>i32</code>): -&gt; <code>i32?</code> 3. mode(<code>i64</code>): -&gt; <code>i64?</code> 4. mode(<code>fp32</code>): -&gt; <code>fp32?</code> 5. mode(<code>fp64</code>): -&gt; <code>fp64?</code></p> <p>*Calculates mode for a set of values. If there is no input, null is returned. *</p>"},{"location":"extensions/functions_arithmetic/#median","title":"median","text":"<p>Implementations: median(<code>precision</code>, <code>x</code>, <code>option:rounding</code>): -&gt; <code>return_type</code>  0. median(<code>precision</code>, <code>i8</code>, <code>option:rounding</code>): -&gt; <code>i8?</code> 1. median(<code>precision</code>, <code>i16</code>, <code>option:rounding</code>): -&gt; <code>i16?</code> 2. median(<code>precision</code>, <code>i32</code>, <code>option:rounding</code>): -&gt; <code>i32?</code> 3. median(<code>precision</code>, <code>i64</code>, <code>option:rounding</code>): -&gt; <code>i64?</code> 4. median(<code>precision</code>, <code>fp32</code>, <code>option:rounding</code>): -&gt; <code>fp32?</code> 5. median(<code>precision</code>, <code>fp64</code>, <code>option:rounding</code>): -&gt; <code>fp64?</code></p> <p>*Calculate the median for a set of values. Returns null if applied to zero records. For the integer implementations, the rounding option determines how the median should be rounded if it ends up midway between two values. For the floating point implementations, they specify the usual floating point rounding mode. *</p> Options: <li>precision ['EXACT', 'APPROXIMATE'] </li> <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li>"},{"location":"extensions/functions_arithmetic/#quantile","title":"quantile","text":"<p>Implementations: quantile(<code>boundaries</code>, <code>precision</code>, <code>n</code>, <code>distribution</code>, <code>option:rounding</code>): -&gt; <code>return_type</code> </p> <li>n: A positive integer which defines the number of quantile partitions. </li> <li>distribution: The data for which the quantiles should be computed. </li> <p>0. quantile(<code>boundaries</code>, <code>precision</code>, <code>i64</code>, <code>any</code>, <code>option:rounding</code>): -&gt; <code>LIST?&lt;any&gt;</code></p> <p>*Calculates quantiles for a set of values. This function will divide the aggregated values (passed via the distribution argument) over N equally-sized bins, where N is passed via a constant argument. It will then return the values at the boundaries of these bins in list form. If the input is appropriately sorted, this computes the quantiles of the distribution. The function can optionally return the first and/or last element of the input, as specified by the <code>boundaries</code> argument. If the input is appropriately sorted, this will thus be the minimum and/or maximum values of the distribution. When the boundaries do not lie exactly on elements of the incoming distribution, the function will interpolate between the two nearby elements. If the interpolated value cannot be represented exactly, the <code>rounding</code> option controls how the value should be selected or computed. The function fails and returns null in the following cases:   - <code>n</code> is null or less than one;   - any value in <code>distribution</code> is null.</p> <p>The function returns an empty list if <code>n</code> equals 1 and <code>boundaries</code> is set to <code>NEITHER</code>. *</p> Options: <li>boundaries ['NEITHER', 'MINIMUM', 'MAXIMUM', 'BOTH'] </li> <li>precision ['EXACT', 'APPROXIMATE'] </li> <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li>"},{"location":"extensions/functions_arithmetic/#window-functions","title":"Window Functions","text":""},{"location":"extensions/functions_arithmetic/#row_number","title":"row_number","text":"<p>Implementations: 0. row_number(): -&gt; <code>i64?</code></p> <p>the number of the current row within its partition.</p>"},{"location":"extensions/functions_arithmetic/#rank","title":"rank","text":"<p>Implementations: 0. rank(): -&gt; <code>i64?</code></p> <p>the rank of the current row, with gaps.</p>"},{"location":"extensions/functions_arithmetic/#dense_rank","title":"dense_rank","text":"<p>Implementations: 0. dense_rank(): -&gt; <code>i64?</code></p> <p>the rank of the current row, without gaps.</p>"},{"location":"extensions/functions_arithmetic/#percent_rank","title":"percent_rank","text":"<p>Implementations: 0. percent_rank(): -&gt; <code>fp64?</code></p> <p>the relative rank of the current row.</p>"},{"location":"extensions/functions_arithmetic/#cume_dist","title":"cume_dist","text":"<p>Implementations: 0. cume_dist(): -&gt; <code>fp64?</code></p> <p>the cumulative distribution.</p>"},{"location":"extensions/functions_arithmetic/#ntile","title":"ntile","text":"<p>Implementations: ntile(<code>x</code>): -&gt; <code>return_type</code>  0. ntile(<code>i32</code>): -&gt; <code>i32?</code> 1. ntile(<code>i64</code>): -&gt; <code>i64?</code></p> <p>Return an integer ranging from 1 to the argument value,dividing the partition as equally as possible.</p>"},{"location":"extensions/functions_arithmetic/#first_value","title":"first_value","text":"<p>Implementations: first_value(<code>expression</code>): -&gt; <code>return_type</code>  0. first_value(<code>any1</code>): -&gt; <code>any1</code></p> <p>*Returns the first value in the window. *</p>"},{"location":"extensions/functions_arithmetic/#last_value","title":"last_value","text":"<p>Implementations: last_value(<code>expression</code>): -&gt; <code>return_type</code>  0. last_value(<code>any1</code>): -&gt; <code>any1</code></p> <p>*Returns the last value in the window. *</p>"},{"location":"extensions/functions_arithmetic/#nth_value","title":"nth_value","text":"<p>Implementations: nth_value(<code>expression</code>, <code>window_offset</code>, <code>option:on_domain_error</code>): -&gt; <code>return_type</code>  0. nth_value(<code>any1</code>, <code>i32</code>, <code>option:on_domain_error</code>): -&gt; <code>any1?</code></p> <p>*Returns a value from the nth row based on the <code>window_offset</code>. <code>window_offset</code> should be a positive integer. If the value of the <code>window_offset</code> is outside the range of the window, <code>null</code> is returned. The <code>on_domain_error</code> option governs behavior in cases where <code>window_offset</code> is not a positive integer or <code>null</code>. *</p> Options: <li>on_domain_error ['NAN', 'ERROR'] </li>"},{"location":"extensions/functions_arithmetic/#lead","title":"lead","text":"<p>Implementations: lead(<code>expression</code>): -&gt; <code>return_type</code>  0. lead(<code>any1</code>): -&gt; <code>any1?</code> 1. lead(<code>any1</code>, <code>i32</code>): -&gt; <code>any1?</code> 2. lead(<code>any1</code>, <code>i32</code>, <code>any1</code>): -&gt; <code>any1?</code></p> <p>*Return a value from a following row based on a specified physical offset. This allows you to compare a value in the current row against a following row. The <code>expression</code> is evaluated against a row that comes after the current row based on the <code>row_offset</code>.  The <code>row_offset</code> should be a positive integer and is set to 1 if not specified explicitly. If the <code>row_offset</code> is negative, the expression will be evaluated against a row coming before the current row, similar to the <code>lag</code> function. A <code>row_offset</code> of <code>null</code> will return <code>null</code>. The function returns the <code>default</code> input value if <code>row_offset</code> goes beyond the scope of the window. If a <code>default</code> value is not specified, it is set to <code>null</code>. Example comparing the sales of the current year to the following year. <code>row_offset</code> of 1. | year | sales  | next_year_sales | | 2019 | 20.50  | 30.00           | | 2020 | 30.00  | 45.99           | | 2021 | 45.99  | null            | *</p>"},{"location":"extensions/functions_arithmetic/#lag","title":"lag","text":"<p>Implementations: lag(<code>expression</code>): -&gt; <code>return_type</code>  0. lag(<code>any1</code>): -&gt; <code>any1?</code> 1. lag(<code>any1</code>, <code>i32</code>): -&gt; <code>any1?</code> 2. lag(<code>any1</code>, <code>i32</code>, <code>any1</code>): -&gt; <code>any1?</code></p> <p>*Return a column value from a previous row based on a specified physical offset. This allows you to compare a value in the current row against a previous row. The <code>expression</code> is evaluated against a row that comes before the current row based on the <code>row_offset</code>.  The <code>expression</code> can be a column, expression or subquery that evaluates to a single value. The <code>row_offset</code> should be a positive integer and is set to 1 if not specified explicitly. If the <code>row_offset</code> is negative, the expression will be evaluated against a row coming after the current row, similar to the <code>lead</code> function. A <code>row_offset</code> of <code>null</code> will return <code>null</code>. The function returns the <code>default</code> input value if <code>row_offset</code> goes beyond the scope of the partition. If a <code>default</code> value is not specified, it is set to <code>null</code>. Example comparing the sales of the current year to the previous year. <code>row_offset</code> of 1. | year | sales  | previous_year_sales | | 2019 | 20.50  | null                | | 2020 | 30.00  | 20.50               | | 2021 | 45.99  | 30.00               | *</p>"},{"location":"extensions/functions_arithmetic_decimal/","title":"functions_arithmetic_decimal.yaml","text":"<p>This document file is generated for functions_arithmetic_decimal.yaml</p>"},{"location":"extensions/functions_arithmetic_decimal/#scalar-functions","title":"Scalar Functions","text":""},{"location":"extensions/functions_arithmetic_decimal/#add","title":"add","text":"<p>Implementations: add(<code>x</code>, <code>y</code>, <code>option:overflow</code>): -&gt; <code>return_type</code>  0. add(<code>decimal&lt;P1,S1&gt;</code>, <code>decimal&lt;P2,S2&gt;</code>, <code>option:overflow</code>): -&gt;  <pre><code>init_scale = max(S1,S2)\ninit_prec = init_scale + max(P1 - S1, P2 - S2) + 1\nmin_scale = min(init_scale, 6)\ndelta = init_prec - 38\nprec = min(init_prec, 38)\nscale_after_borrow = max(init_scale - delta, min_scale)\nscale = init_prec &gt; 38 ? scale_after_borrow : init_scale\nDECIMAL&lt;prec, scale&gt;  \n</code></pre></p> <p>Add two decimal values.</p> Options: <li>overflow ['SILENT', 'SATURATE', 'ERROR'] </li>"},{"location":"extensions/functions_arithmetic_decimal/#subtract","title":"subtract","text":"<p>Implementations: subtract(<code>x</code>, <code>y</code>, <code>option:overflow</code>): -&gt; <code>return_type</code>  0. subtract(<code>decimal&lt;P1,S1&gt;</code>, <code>decimal&lt;P2,S2&gt;</code>, <code>option:overflow</code>): -&gt;  <pre><code>init_scale = max(S1,S2)\ninit_prec = init_scale + max(P1 - S1, P2 - S2) + 1\nmin_scale = min(init_scale, 6)\ndelta = init_prec - 38\nprec = min(init_prec, 38)\nscale_after_borrow = max(init_scale - delta, min_scale)\nscale = init_prec &gt; 38 ? scale_after_borrow : init_scale\nDECIMAL&lt;prec, scale&gt;  \n</code></pre></p> Options: <li>overflow ['SILENT', 'SATURATE', 'ERROR'] </li>"},{"location":"extensions/functions_arithmetic_decimal/#multiply","title":"multiply","text":"<p>Implementations: multiply(<code>x</code>, <code>y</code>, <code>option:overflow</code>): -&gt; <code>return_type</code>  0. multiply(<code>decimal&lt;P1,S1&gt;</code>, <code>decimal&lt;P2,S2&gt;</code>, <code>option:overflow</code>): -&gt;  <pre><code>init_scale = S1 + S2\ninit_prec = P1 + P2 + 1\nmin_scale = min(init_scale, 6)\ndelta = init_prec - 38\nprec = min(init_prec, 38)\nscale_after_borrow = max(init_scale - delta, min_scale)\nscale = init_prec &gt; 38 ? scale_after_borrow : init_scale\nDECIMAL&lt;prec, scale&gt;  \n</code></pre></p> Options: <li>overflow ['SILENT', 'SATURATE', 'ERROR'] </li>"},{"location":"extensions/functions_arithmetic_decimal/#divide","title":"divide","text":"<p>Implementations: divide(<code>x</code>, <code>y</code>, <code>option:overflow</code>): -&gt; <code>return_type</code>  0. divide(<code>decimal&lt;P1,S1&gt;</code>, <code>decimal&lt;P2,S2&gt;</code>, <code>option:overflow</code>): -&gt;  <pre><code>init_scale = max(6, S1 + P2 + 1)\ninit_prec = P1 - S1 + P2 + init_scale\nmin_scale = min(init_scale, 6)\ndelta = init_prec - 38\nprec = min(init_prec, 38)\nscale_after_borrow = max(init_scale - delta, min_scale)\nscale = init_prec &gt; 38 ? scale_after_borrow : init_scale\nDECIMAL&lt;prec, scale&gt;  \n</code></pre></p> Options: <li>overflow ['SILENT', 'SATURATE', 'ERROR'] </li>"},{"location":"extensions/functions_arithmetic_decimal/#modulus","title":"modulus","text":"<p>Implementations: modulus(<code>x</code>, <code>y</code>, <code>option:overflow</code>): -&gt; <code>return_type</code>  0. modulus(<code>decimal&lt;P1,S1&gt;</code>, <code>decimal&lt;P2,S2&gt;</code>, <code>option:overflow</code>): -&gt;  <pre><code>init_scale = max(S1,S2)\ninit_prec = min(P1 - S1, P2 - S2) + init_scale\nmin_scale = min(init_scale, 6)\ndelta = init_prec - 38\nprec = min(init_prec, 38)\nscale_after_borrow = max(init_scale - delta, min_scale)\nscale = init_prec &gt; 38 ? scale_after_borrow : init_scale\nDECIMAL&lt;prec, scale&gt;  \n</code></pre></p> Options: <li>overflow ['SILENT', 'SATURATE', 'ERROR'] </li>"},{"location":"extensions/functions_arithmetic_decimal/#abs","title":"abs","text":"<p>Implementations: abs(<code>x</code>): -&gt; <code>return_type</code>  0. abs(<code>decimal&lt;P,S&gt;</code>): -&gt; <code>decimal&lt;P,S&gt;</code></p> <p>Calculate the absolute value of the argument.</p>"},{"location":"extensions/functions_arithmetic_decimal/#bitwise_and","title":"bitwise_and","text":"<p>Implementations: bitwise_and(<code>x</code>, <code>y</code>): -&gt; <code>return_type</code>  0. bitwise_and(<code>DECIMAL&lt;P1,0&gt;</code>, <code>DECIMAL&lt;P2,0&gt;</code>): -&gt;  <pre><code>max_precision = max(P1, P2)\nDECIMAL&lt;max_precision, 0&gt;  \n</code></pre></p> <p>*Return the bitwise AND result for two decimal inputs. In inputs scale must be 0 (i.e. only integer types are allowed) *</p>"},{"location":"extensions/functions_arithmetic_decimal/#bitwise_or","title":"bitwise_or","text":"<p>Implementations: bitwise_or(<code>x</code>, <code>y</code>): -&gt; <code>return_type</code>  0. bitwise_or(<code>DECIMAL&lt;P1,0&gt;</code>, <code>DECIMAL&lt;P2,0&gt;</code>): -&gt;  <pre><code>max_precision = max(P1, P2)\nDECIMAL&lt;max_precision, 0&gt;  \n</code></pre></p> <p>*Return the bitwise OR result for two given decimal inputs. In inputs scale must be 0 (i.e. only integer types are allowed) *</p>"},{"location":"extensions/functions_arithmetic_decimal/#bitwise_xor","title":"bitwise_xor","text":"<p>Implementations: bitwise_xor(<code>x</code>, <code>y</code>): -&gt; <code>return_type</code>  0. bitwise_xor(<code>DECIMAL&lt;P1,0&gt;</code>, <code>DECIMAL&lt;P2,0&gt;</code>): -&gt;  <pre><code>max_precision = max(P1, P2)\nDECIMAL&lt;max_precision, 0&gt;  \n</code></pre></p> <p>*Return the bitwise XOR result for two given decimal inputs. In inputs scale must be 0 (i.e. only integer types are allowed) *</p>"},{"location":"extensions/functions_arithmetic_decimal/#sqrt","title":"sqrt","text":"<p>Implementations: sqrt(<code>x</code>): -&gt; <code>return_type</code>  0. sqrt(<code>DECIMAL&lt;P,S&gt;</code>): -&gt; <code>fp64</code></p> <p>Square root of the value. Sqrt of 0 is 0 and sqrt of negative values will raise an error.</p>"},{"location":"extensions/functions_arithmetic_decimal/#factorial","title":"factorial","text":"<p>Implementations: factorial(<code>n</code>): -&gt; <code>return_type</code>  0. factorial(<code>DECIMAL&lt;P,0&gt;</code>): -&gt; <code>DECIMAL&lt;38,0&gt;</code></p> <p>*Return the factorial of a given decimal input. Scale should be 0 for factorial decimal input. The factorial of 0! is 1 by convention. Negative inputs will raise an error. Input which cause overflow of result will raise an error. *</p>"},{"location":"extensions/functions_arithmetic_decimal/#power","title":"power","text":"<p>Implementations: power(<code>x</code>, <code>y</code>, <code>option:overflow</code>, <code>option:complex_number_result</code>): -&gt; <code>return_type</code>  0. power(<code>DECIMAL&lt;P1,S1&gt;</code>, <code>DECIMAL&lt;P2,S2&gt;</code>, <code>option:overflow</code>, <code>option:complex_number_result</code>): -&gt; <code>fp64</code></p> <p>Take the power with x as the base and y as exponent. Behavior for complex number result is indicated by option complex_number_result</p> Options: <li>overflow ['SILENT', 'SATURATE', 'ERROR'] </li> <li>complex_number_result ['NAN', 'ERROR'] </li>"},{"location":"extensions/functions_arithmetic_decimal/#aggregate-functions","title":"Aggregate Functions","text":""},{"location":"extensions/functions_arithmetic_decimal/#sum","title":"sum","text":"<p>Implementations: sum(<code>x</code>, <code>option:overflow</code>): -&gt; <code>return_type</code>  0. sum(<code>DECIMAL&lt;P, S&gt;</code>, <code>option:overflow</code>): -&gt; <code>DECIMAL?&lt;38,S&gt;</code></p> <p>Sum a set of values.</p> Options: <li>overflow ['SILENT', 'SATURATE', 'ERROR'] </li>"},{"location":"extensions/functions_arithmetic_decimal/#avg","title":"avg","text":"<p>Implementations: avg(<code>x</code>, <code>option:overflow</code>): -&gt; <code>return_type</code>  0. avg(<code>DECIMAL&lt;P,S&gt;</code>, <code>option:overflow</code>): -&gt; <code>DECIMAL&lt;38,S&gt;</code></p> <p>Average a set of values.</p> Options: <li>overflow ['SILENT', 'SATURATE', 'ERROR'] </li>"},{"location":"extensions/functions_arithmetic_decimal/#min","title":"min","text":"<p>Implementations: min(<code>x</code>): -&gt; <code>return_type</code>  0. min(<code>DECIMAL&lt;P, S&gt;</code>): -&gt; <code>DECIMAL?&lt;P, S&gt;</code></p> <p>Min a set of values.</p>"},{"location":"extensions/functions_arithmetic_decimal/#max","title":"max","text":"<p>Implementations: max(<code>x</code>): -&gt; <code>return_type</code>  0. max(<code>DECIMAL&lt;P,S&gt;</code>): -&gt; <code>DECIMAL?&lt;P, S&gt;</code></p> <p>Max a set of values.</p>"},{"location":"extensions/functions_arithmetic_decimal/#sum0","title":"sum0","text":"<p>Implementations: sum0(<code>x</code>, <code>option:overflow</code>): -&gt; <code>return_type</code>  0. sum0(<code>DECIMAL&lt;P, S&gt;</code>, <code>option:overflow</code>): -&gt; <code>DECIMAL&lt;38,S&gt;</code></p> <p>*Sum a set of values. The sum of zero elements yields zero. Null values are ignored. *</p> Options: <li>overflow ['SILENT', 'SATURATE', 'ERROR'] </li>"},{"location":"extensions/functions_boolean/","title":"functions_boolean.yaml","text":"<p>This document file is generated for functions_boolean.yaml</p>"},{"location":"extensions/functions_boolean/#scalar-functions","title":"Scalar Functions","text":""},{"location":"extensions/functions_boolean/#or","title":"or","text":"<p>Implementations: or(<code>a</code>): -&gt; <code>return_type</code>  0. or(<code>boolean?</code>): -&gt; <code>boolean?</code></p> <p>*The boolean <code>or</code> using Kleene logic. This function behaves as follows with nulls:</p> <pre><code>true or null = true\n\nnull or true = true\n\nfalse or null = null\n\nnull or false = null\n\nnull or null = null\n</code></pre> <p>In other words, in this context a null value really means \u201cunknown\u201d, and an unknown value <code>or</code> true is always true. Behavior for 0 or 1 inputs is as follows:   or() -&gt; false   or(x) -&gt; x *</p>"},{"location":"extensions/functions_boolean/#and","title":"and","text":"<p>Implementations: and(<code>a</code>): -&gt; <code>return_type</code>  0. and(<code>boolean?</code>): -&gt; <code>boolean?</code></p> <p>*The boolean <code>and</code> using Kleene logic. This function behaves as follows with nulls:</p> <pre><code>true and null = null\n\nnull and true = null\n\nfalse and null = false\n\nnull and false = false\n\nnull and null = null\n</code></pre> <p>In other words, in this context a null value really means \u201cunknown\u201d, and an unknown value <code>and</code> false is always false. Behavior for 0 or 1 inputs is as follows:   and() -&gt; true   and(x) -&gt; x *</p>"},{"location":"extensions/functions_boolean/#and_not","title":"and_not","text":"<p>Implementations: and_not(<code>a</code>, <code>b</code>): -&gt; <code>return_type</code>  0. and_not(<code>boolean?</code>, <code>boolean?</code>): -&gt; <code>boolean?</code></p> <p>*The boolean <code>and</code> of one value and the negation of the other using Kleene logic. This function behaves as follows with nulls:</p> <pre><code>true and not null = null\n\nnull and not false = null\n\nfalse and not null = false\n\nnull and not true = false\n\nnull and not null = null\n</code></pre> <p>In other words, in this context a null value really means \u201cunknown\u201d, and an unknown value <code>and not</code> true is always false, as is false <code>and not</code> an unknown value. *</p>"},{"location":"extensions/functions_boolean/#xor","title":"xor","text":"<p>Implementations: xor(<code>a</code>, <code>b</code>): -&gt; <code>return_type</code>  0. xor(<code>boolean?</code>, <code>boolean?</code>): -&gt; <code>boolean?</code></p> <p>*The boolean <code>xor</code> of two values using Kleene logic. When a null is encountered in either input, a null is output. *</p>"},{"location":"extensions/functions_boolean/#not","title":"not","text":"<p>Implementations: not(<code>a</code>): -&gt; <code>return_type</code>  0. not(<code>boolean?</code>): -&gt; <code>boolean?</code></p> <p>*The <code>not</code> of a boolean value. When a null is input, a null is output. *</p>"},{"location":"extensions/functions_boolean/#aggregate-functions","title":"Aggregate Functions","text":""},{"location":"extensions/functions_boolean/#bool_and","title":"bool_and","text":"<p>Implementations: bool_and(<code>a</code>): -&gt; <code>return_type</code>  0. bool_and(<code>boolean</code>): -&gt; <code>boolean?</code></p> <p>*If any value in the input is false, false is returned. If the input is empty or only contains nulls, null is returned. Otherwise, true is returned. *</p>"},{"location":"extensions/functions_boolean/#bool_or","title":"bool_or","text":"<p>Implementations: bool_or(<code>a</code>): -&gt; <code>return_type</code>  0. bool_or(<code>boolean</code>): -&gt; <code>boolean?</code></p> <p>*If any value in the input is true, true is returned. If the input is empty or only contains nulls, null is returned. Otherwise, false is returned. *</p>"},{"location":"extensions/functions_comparison/","title":"functions_comparison.yaml","text":"<p>This document file is generated for functions_comparison.yaml</p>"},{"location":"extensions/functions_comparison/#scalar-functions","title":"Scalar Functions","text":""},{"location":"extensions/functions_comparison/#not_equal","title":"not_equal","text":"<p>Implementations: not_equal(<code>x</code>, <code>y</code>): -&gt; <code>return_type</code>  0. not_equal(<code>any1</code>, <code>any1</code>): -&gt; <code>boolean</code></p> <p>*Whether two values are not_equal. <code>not_equal(x, y) := (x != y)</code> If either/both of <code>x</code> and <code>y</code> are <code>null</code>, <code>null</code> is returned. *</p>"},{"location":"extensions/functions_comparison/#equal","title":"equal","text":"<p>Implementations: equal(<code>x</code>, <code>y</code>): -&gt; <code>return_type</code>  0. equal(<code>any1</code>, <code>any1</code>): -&gt; <code>boolean</code></p> <p>*Whether two values are equal. <code>equal(x, y) := (x == y)</code> If either/both of <code>x</code> and <code>y</code> are <code>null</code>, <code>null</code> is returned. *</p>"},{"location":"extensions/functions_comparison/#is_not_distinct_from","title":"is_not_distinct_from","text":"<p>Implementations: is_not_distinct_from(<code>x</code>, <code>y</code>): -&gt; <code>return_type</code>  0. is_not_distinct_from(<code>any1</code>, <code>any1</code>): -&gt; <code>boolean</code></p> <p>*Whether two values are equal. This function treats <code>null</code> values as comparable, so <code>is_not_distinct_from(null, null) == True</code> This is in contrast to <code>equal</code>, in which <code>null</code> values do not compare. *</p>"},{"location":"extensions/functions_comparison/#is_distinct_from","title":"is_distinct_from","text":"<p>Implementations: is_distinct_from(<code>x</code>, <code>y</code>): -&gt; <code>return_type</code>  0. is_distinct_from(<code>any1</code>, <code>any1</code>): -&gt; <code>boolean</code></p> <p>*Whether two values are not equal. This function treats <code>null</code> values as comparable, so <code>is_distinct_from(null, null) == False</code> This is in contrast to <code>equal</code>, in which <code>null</code> values do not compare. *</p>"},{"location":"extensions/functions_comparison/#lt","title":"lt","text":"<p>Implementations: lt(<code>x</code>, <code>y</code>): -&gt; <code>return_type</code>  0. lt(<code>any1</code>, <code>any1</code>): -&gt; <code>boolean</code></p> <p>*Less than. lt(x, y) := (x &lt; y) If either/both of <code>x</code> and <code>y</code> are <code>null</code>, <code>null</code> is returned. *</p>"},{"location":"extensions/functions_comparison/#gt","title":"gt","text":"<p>Implementations: gt(<code>x</code>, <code>y</code>): -&gt; <code>return_type</code>  0. gt(<code>any1</code>, <code>any1</code>): -&gt; <code>boolean</code></p> <p>*Greater than. gt(x, y) := (x &gt; y) If either/both of <code>x</code> and <code>y</code> are <code>null</code>, <code>null</code> is returned. *</p>"},{"location":"extensions/functions_comparison/#lte","title":"lte","text":"<p>Implementations: lte(<code>x</code>, <code>y</code>): -&gt; <code>return_type</code>  0. lte(<code>any1</code>, <code>any1</code>): -&gt; <code>boolean</code></p> <p>*Less than or equal to. lte(x, y) := (x &lt;= y) If either/both of <code>x</code> and <code>y</code> are <code>null</code>, <code>null</code> is returned. *</p>"},{"location":"extensions/functions_comparison/#gte","title":"gte","text":"<p>Implementations: gte(<code>x</code>, <code>y</code>): -&gt; <code>return_type</code>  0. gte(<code>any1</code>, <code>any1</code>): -&gt; <code>boolean</code></p> <p>*Greater than or equal to. gte(x, y) := (x &gt;= y) If either/both of <code>x</code> and <code>y</code> are <code>null</code>, <code>null</code> is returned. *</p>"},{"location":"extensions/functions_comparison/#between","title":"between","text":"<p>Implementations: between(<code>expression</code>, <code>low</code>, <code>high</code>): -&gt; <code>return_type</code> </p> <li>expression: The expression to test for in the range defined by `low` and `high`.</li> <li>low: The value to check if greater than or equal to.</li> <li>high: The value to check if less than or equal to.</li> <p>0. between(<code>any1</code>, <code>any1</code>, <code>any1</code>): -&gt; <code>boolean</code></p> <p>Whether the <code>expression</code> is greater than or equal to <code>low</code> and less than or equal to <code>high</code>. <code>expression</code> BETWEEN <code>low</code> AND <code>high</code> If <code>low</code>, <code>high</code>, or <code>expression</code> are <code>null</code>, <code>null</code> is returned.</p>"},{"location":"extensions/functions_comparison/#is_null","title":"is_null","text":"<p>Implementations: is_null(<code>x</code>): -&gt; <code>return_type</code>  0. is_null(<code>any1</code>): -&gt; <code>boolean</code></p> <p>Whether a value is null. NaN is not null.</p>"},{"location":"extensions/functions_comparison/#is_not_null","title":"is_not_null","text":"<p>Implementations: is_not_null(<code>x</code>): -&gt; <code>return_type</code>  0. is_not_null(<code>any1</code>): -&gt; <code>boolean</code></p> <p>Whether a value is not null. NaN is not null.</p>"},{"location":"extensions/functions_comparison/#is_nan","title":"is_nan","text":"<p>Implementations: is_nan(<code>x</code>): -&gt; <code>return_type</code>  0. is_nan(<code>fp32</code>): -&gt; <code>boolean</code> 1. is_nan(<code>fp64</code>): -&gt; <code>boolean</code></p> <p>*Whether a value is not a number. If <code>x</code> is <code>null</code>, <code>null</code> is returned. *</p>"},{"location":"extensions/functions_comparison/#is_finite","title":"is_finite","text":"<p>Implementations: is_finite(<code>x</code>): -&gt; <code>return_type</code>  0. is_finite(<code>fp32</code>): -&gt; <code>boolean</code> 1. is_finite(<code>fp64</code>): -&gt; <code>boolean</code></p> <p>*Whether a value is finite (neither infinite nor NaN). If <code>x</code> is <code>null</code>, <code>null</code> is returned. *</p>"},{"location":"extensions/functions_comparison/#is_infinite","title":"is_infinite","text":"<p>Implementations: is_infinite(<code>x</code>): -&gt; <code>return_type</code>  0. is_infinite(<code>fp32</code>): -&gt; <code>boolean</code> 1. is_infinite(<code>fp64</code>): -&gt; <code>boolean</code></p> <p>*Whether a value is infinite. If <code>x</code> is <code>null</code>, <code>null</code> is returned. *</p>"},{"location":"extensions/functions_comparison/#nullif","title":"nullif","text":"<p>Implementations: nullif(<code>x</code>, <code>y</code>): -&gt; <code>return_type</code>  0. nullif(<code>any1</code>, <code>any1</code>): -&gt; <code>any1</code></p> <p>If two values are equal, return null. Otherwise, return the first value.</p>"},{"location":"extensions/functions_comparison/#coalesce","title":"coalesce","text":"<p>Implementations: 0. coalesce(<code>any1</code>, <code>any1</code>): -&gt; <code>any1</code></p> <p>Evaluate arguments from left to right and return the first argument that is not null. Once a non-null argument is found, the remaining arguments are not evaluated. If all arguments are null, return null.</p>"},{"location":"extensions/functions_comparison/#least","title":"least","text":"<p>Implementations: 0. least(<code>any1</code>, <code>any1</code>): -&gt; <code>any1</code></p> <p>Evaluates each argument and returns the smallest one. The function will return null if any argument evaluates to null.</p>"},{"location":"extensions/functions_comparison/#least_skip_null","title":"least_skip_null","text":"<p>Implementations: 0. least_skip_null(<code>any1</code>, <code>any1</code>): -&gt; <code>any1</code></p> <p>Evaluates each argument and returns the smallest one. The function will return null only if all arguments evaluate to null.</p>"},{"location":"extensions/functions_comparison/#greatest","title":"greatest","text":"<p>Implementations: 0. greatest(<code>any1</code>, <code>any1</code>): -&gt; <code>any1</code></p> <p>Evaluates each argument and returns the largest one. The function will return null if any argument evaluates to null.</p>"},{"location":"extensions/functions_comparison/#greatest_skip_null","title":"greatest_skip_null","text":"<p>Implementations: 0. greatest_skip_null(<code>any1</code>, <code>any1</code>): -&gt; <code>any1</code></p> <p>Evaluates each argument and returns the largest one. The function will return null only if all arguments evaluate to null.</p>"},{"location":"extensions/functions_datetime/","title":"functions_datetime.yaml","text":"<p>This document file is generated for functions_datetime.yaml</p>"},{"location":"extensions/functions_datetime/#scalar-functions","title":"Scalar Functions","text":""},{"location":"extensions/functions_datetime/#extract","title":"extract","text":"<p>Implementations: extract(<code>component</code>, <code>x</code>, <code>timezone</code>): -&gt; <code>return_type</code> </p> <li>x: Timezone string from IANA tzdb.</li> <p>0. extract(<code>component</code>, <code>timestamp_tz</code>, <code>string</code>): -&gt; <code>i64</code> 1. extract(<code>component</code>, <code>precision_timestamp_tz&lt;P&gt;</code>, <code>string</code>): -&gt; <code>i64</code> 2. extract(<code>component</code>, <code>timestamp</code>): -&gt; <code>i64</code> 3. extract(<code>component</code>, <code>precision_timestamp&lt;P&gt;</code>): -&gt; <code>i64</code> 4. extract(<code>component</code>, <code>date</code>): -&gt; <code>i64</code> 5. extract(<code>component</code>, <code>time</code>): -&gt; <code>i64</code> 6. extract(<code>component</code>, <code>indexing</code>, <code>timestamp_tz</code>, <code>string</code>): -&gt; <code>i64</code> 7. extract(<code>component</code>, <code>indexing</code>, <code>precision_timestamp_tz&lt;P&gt;</code>, <code>string</code>): -&gt; <code>i64</code> 8. extract(<code>component</code>, <code>indexing</code>, <code>timestamp</code>): -&gt; <code>i64</code> 9. extract(<code>component</code>, <code>indexing</code>, <code>precision_timestamp&lt;P&gt;</code>): -&gt; <code>i64</code> 10. extract(<code>component</code>, <code>indexing</code>, <code>date</code>): -&gt; <code>i64</code></p> <p>Extract portion of a date/time value. * YEAR Return the year. * ISO_YEAR Return the ISO 8601 week-numbering year. First week of an ISO year has the majority (4 or more) of   its days in January. * US_YEAR Return the US epidemiological year. First week of US epidemiological year has the majority (4 or more)   of its days in January. Last week of US epidemiological year has the year\u2019s last Wednesday in it. US   epidemiological week starts on Sunday. * QUARTER Return the number of the quarter within the year. January 1 through March 31 map to the first quarter,   April 1 through June 30 map to the second quarter, etc. * MONTH Return the number of the month within the year. * DAY Return the number of the day within the month. * DAY_OF_YEAR Return the number of the day within the year. January 1 maps to the first day, February 1 maps to   the thirty-second day, etc. * MONDAY_DAY_OF_WEEK Return the number of the day within the week, from Monday (first day) to Sunday (seventh   day). * SUNDAY_DAY_OF_WEEK Return the number of the day within the week, from Sunday (first day) to Saturday (seventh   day). * MONDAY_WEEK Return the number of the week within the year. First week starts on first Monday of January. * SUNDAY_WEEK Return the number of the week within the year. First week starts on first Sunday of January. * ISO_WEEK Return the number of the ISO week within the ISO year. First ISO week has the majority (4 or more)   of its days in January. ISO week starts on Monday. * US_WEEK Return the number of the US week within the US year. First US week has the majority (4 or more) of   its days in January. US week starts on Sunday. * HOUR Return the hour (0-23). * MINUTE Return the minute (0-59). * SECOND Return the second (0-59). * MILLISECOND Return number of milliseconds since the last full second. * MICROSECOND Return number of microseconds since the last full millisecond. * NANOSECOND Return number of nanoseconds since the last full microsecond. * SUBSECOND Return number of microseconds since the last full second of the given timestamp. * UNIX_TIME Return number of seconds that have elapsed since 1970-01-01 00:00:00 UTC, ignoring leap seconds. * TIMEZONE_OFFSET Return number of seconds of timezone offset to UTC. The range of values returned for QUARTER, MONTH, DAY, DAY_OF_YEAR, MONDAY_DAY_OF_WEEK, SUNDAY_DAY_OF_WEEK, MONDAY_WEEK, SUNDAY_WEEK, ISO_WEEK, and US_WEEK depends on whether counting starts at 1 or 0. This is governed by the indexing option. When indexing is ONE: * QUARTER returns values in range 1-4 * MONTH returns values in range 1-12 * DAY returns values in range 1-31 * DAY_OF_YEAR returns values in range 1-366 * MONDAY_DAY_OF_WEEK and SUNDAY_DAY_OF_WEEK return values in range 1-7 * MONDAY_WEEK, SUNDAY_WEEK, ISO_WEEK, and US_WEEK return values in range 1-53 When indexing is ZERO: * QUARTER returns values in range 0-3 * MONTH returns values in range 0-11 * DAY returns values in range 0-30 * DAY_OF_YEAR returns values in range 0-365 * MONDAY_DAY_OF_WEEK and SUNDAY_DAY_OF_WEEK return values in range 0-6 * MONDAY_WEEK, SUNDAY_WEEK, ISO_WEEK, and US_WEEK return values in range 0-52 The indexing option must be specified when the component is QUARTER, MONTH, DAY, DAY_OF_YEAR, MONDAY_DAY_OF_WEEK, SUNDAY_DAY_OF_WEEK, MONDAY_WEEK, SUNDAY_WEEK, ISO_WEEK, or US_WEEK. The indexing option cannot be specified when the component is YEAR, ISO_YEAR, US_YEAR, HOUR, MINUTE, SECOND, MILLISECOND, MICROSECOND, SUBSECOND, UNIX_TIME, or TIMEZONE_OFFSET. Timezone strings must be as defined by IANA timezone database (https://www.iana.org/time-zones). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown.</p> Options: <li>component ['YEAR', 'ISO_YEAR', 'US_YEAR', 'HOUR', 'MINUTE', 'SECOND', 'MILLISECOND', 'MICROSECOND', 'SUBSECOND', 'UNIX_TIME', 'TIMEZONE_OFFSET'] </li> <li>indexing ['YEAR', 'ISO_YEAR', 'US_YEAR', 'HOUR', 'MINUTE', 'SECOND', 'MILLISECOND', 'MICROSECOND', 'NANOSECOND', 'SUBSECOND', 'UNIX_TIME', 'TIMEZONE_OFFSET'] </li> <li>component ['YEAR', 'ISO_YEAR', 'US_YEAR', 'HOUR', 'MINUTE', 'SECOND', 'MILLISECOND', 'MICROSECOND', 'SUBSECOND', 'UNIX_TIME'] </li> <li>indexing ['YEAR', 'ISO_YEAR', 'US_YEAR', 'HOUR', 'MINUTE', 'SECOND', 'MILLISECOND', 'MICROSECOND', 'NANOSECOND', 'SUBSECOND', 'UNIX_TIME'] </li> <li>component ['YEAR', 'ISO_YEAR', 'US_YEAR', 'UNIX_TIME'] </li> <li>indexing ['HOUR', 'MINUTE', 'SECOND', 'MILLISECOND', 'MICROSECOND', 'SUBSECOND'] </li> <li>component ['QUARTER', 'MONTH', 'DAY', 'DAY_OF_YEAR', 'MONDAY_DAY_OF_WEEK', 'SUNDAY_DAY_OF_WEEK', 'MONDAY_WEEK', 'SUNDAY_WEEK', 'ISO_WEEK', 'US_WEEK'] </li> <li>indexing ['ONE', 'ZERO'] </li>"},{"location":"extensions/functions_datetime/#extract_boolean","title":"extract_boolean","text":"<p>Implementations: extract_boolean(<code>component</code>, <code>x</code>): -&gt; <code>return_type</code>  0. extract_boolean(<code>component</code>, <code>timestamp</code>): -&gt; <code>boolean</code> 1. extract_boolean(<code>component</code>, <code>precision_timestamp&lt;P&gt;</code>): -&gt; <code>boolean</code> 2. extract_boolean(<code>component</code>, <code>timestamp_tz</code>, <code>string</code>): -&gt; <code>boolean</code> 3. extract_boolean(<code>component</code>, <code>precision_timestamp_tz&lt;P&gt;</code>, <code>string</code>): -&gt; <code>boolean</code> 4. extract_boolean(<code>component</code>, <code>date</code>): -&gt; <code>boolean</code></p> <p>*Extract boolean values of a date/time value. * IS_LEAP_YEAR Return true if year of the given value is a leap year and false otherwise. * IS_DST Return true if DST (Daylight Savings Time) is observed at the given value   in the given timezone.</p> <p>Timezone strings must be as defined by IANA timezone database (https://www.iana.org/time-zones). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown.*</p> Options: <li>component ['IS_LEAP_YEAR'] </li> <li>component ['IS_LEAP_YEAR', 'IS_DST'] </li>"},{"location":"extensions/functions_datetime/#add","title":"add","text":"<p>Implementations: add(<code>x</code>, <code>y</code>): -&gt; <code>return_type</code>  0. add(<code>timestamp</code>, <code>interval_year</code>): -&gt; <code>timestamp</code> 1. add(<code>precision_timestamp&lt;P&gt;</code>, <code>interval_year</code>): -&gt; <code>precision_timestamp&lt;P&gt;</code> 2. add(<code>timestamp_tz</code>, <code>interval_year</code>, <code>string</code>): -&gt; <code>timestamp_tz</code> 3. add(<code>precision_timestamp_tz&lt;P&gt;</code>, <code>interval_year</code>, <code>string</code>): -&gt; <code>precision_timestamp_tz&lt;P&gt;</code> 4. add(<code>date</code>, <code>interval_year</code>): -&gt; <code>timestamp</code> 5. add(<code>timestamp</code>, <code>interval_day</code>): -&gt; <code>timestamp</code> 6. add(<code>precision_timestamp&lt;P&gt;</code>, <code>interval_day</code>): -&gt; <code>precision_timestamp&lt;P&gt;</code> 7. add(<code>timestamp_tz</code>, <code>interval_day</code>): -&gt; <code>timestamp_tz</code> 8. add(<code>precision_timestamp_tz&lt;P&gt;</code>, <code>interval_day</code>): -&gt; <code>precision_timestamp_tz&lt;P&gt;</code> 9. add(<code>date</code>, <code>interval_day</code>): -&gt; <code>timestamp</code></p> <p>Add an interval to a date/time type. Timezone strings must be as defined by IANA timezone database (https://www.iana.org/time-zones). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown.</p>"},{"location":"extensions/functions_datetime/#multiply","title":"multiply","text":"<p>Implementations: multiply(<code>x</code>, <code>y</code>): -&gt; <code>return_type</code>  0. multiply(<code>i8</code>, <code>interval_day</code>): -&gt; <code>interval_day</code> 1. multiply(<code>i16</code>, <code>interval_day</code>): -&gt; <code>interval_day</code> 2. multiply(<code>i32</code>, <code>interval_day</code>): -&gt; <code>interval_day</code> 3. multiply(<code>i64</code>, <code>interval_day</code>): -&gt; <code>interval_day</code> 4. multiply(<code>i8</code>, <code>interval_year</code>): -&gt; <code>interval_year</code> 5. multiply(<code>i16</code>, <code>interval_year</code>): -&gt; <code>interval_year</code> 6. multiply(<code>i32</code>, <code>interval_year</code>): -&gt; <code>interval_year</code> 7. multiply(<code>i64</code>, <code>interval_year</code>): -&gt; <code>interval_year</code></p> <p>Multiply an interval by an integral number.</p>"},{"location":"extensions/functions_datetime/#add_intervals","title":"add_intervals","text":"<p>Implementations: add_intervals(<code>x</code>, <code>y</code>): -&gt; <code>return_type</code>  0. add_intervals(<code>interval_day</code>, <code>interval_day</code>): -&gt; <code>interval_day</code> 1. add_intervals(<code>interval_year</code>, <code>interval_year</code>): -&gt; <code>interval_year</code></p> <p>Add two intervals together.</p>"},{"location":"extensions/functions_datetime/#subtract","title":"subtract","text":"<p>Implementations: subtract(<code>x</code>, <code>y</code>): -&gt; <code>return_type</code>  0. subtract(<code>timestamp</code>, <code>interval_year</code>): -&gt; <code>timestamp</code> 1. subtract(<code>precision_timestamp&lt;P&gt;</code>, <code>interval_year</code>): -&gt; <code>precision_timestamp&lt;P&gt;</code> 2. subtract(<code>timestamp_tz</code>, <code>interval_year</code>): -&gt; <code>timestamp_tz</code> 3. subtract(<code>precision_timestamp_tz&lt;P&gt;</code>, <code>interval_year</code>): -&gt; <code>precision_timestamp_tz&lt;P&gt;</code> 4. subtract(<code>timestamp_tz</code>, <code>interval_year</code>, <code>string</code>): -&gt; <code>timestamp_tz</code> 5. subtract(<code>precision_timestamp_tz&lt;P&gt;</code>, <code>interval_year</code>, <code>string</code>): -&gt; <code>precision_timestamp_tz&lt;P&gt;</code> 6. subtract(<code>date</code>, <code>interval_year</code>): -&gt; <code>date</code> 7. subtract(<code>timestamp</code>, <code>interval_day</code>): -&gt; <code>timestamp</code> 8. subtract(<code>precision_timestamp&lt;P&gt;</code>, <code>interval_day</code>): -&gt; <code>precision_timestamp&lt;P&gt;</code> 9. subtract(<code>timestamp_tz</code>, <code>interval_day</code>): -&gt; <code>timestamp_tz</code> 10. subtract(<code>precision_timestamp_tz&lt;P&gt;</code>, <code>interval_day</code>): -&gt; <code>precision_timestamp_tz&lt;P&gt;</code> 11. subtract(<code>date</code>, <code>interval_day</code>): -&gt; <code>date</code></p> <p>Subtract an interval from a date/time type. Timezone strings must be as defined by IANA timezone database (https://www.iana.org/time-zones). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown.</p>"},{"location":"extensions/functions_datetime/#lte","title":"lte","text":"<p>Implementations: lte(<code>x</code>, <code>y</code>): -&gt; <code>return_type</code>  0. lte(<code>timestamp</code>, <code>timestamp</code>): -&gt; <code>boolean</code> 1. lte(<code>precision_timestamp&lt;P&gt;</code>, <code>precision_timestamp&lt;P&gt;</code>): -&gt; <code>boolean</code> 2. lte(<code>timestamp_tz</code>, <code>timestamp_tz</code>): -&gt; <code>boolean</code> 3. lte(<code>precision_timestamp_tz&lt;P&gt;</code>, <code>precision_timestamp_tz&lt;P&gt;</code>): -&gt; <code>boolean</code> 4. lte(<code>date</code>, <code>date</code>): -&gt; <code>boolean</code> 5. lte(<code>interval_day</code>, <code>interval_day</code>): -&gt; <code>boolean</code> 6. lte(<code>interval_year</code>, <code>interval_year</code>): -&gt; <code>boolean</code></p> <p>less than or equal to</p>"},{"location":"extensions/functions_datetime/#lt","title":"lt","text":"<p>Implementations: lt(<code>x</code>, <code>y</code>): -&gt; <code>return_type</code>  0. lt(<code>timestamp</code>, <code>timestamp</code>): -&gt; <code>boolean</code> 1. lt(<code>precision_timestamp&lt;P&gt;</code>, <code>precision_timestamp&lt;P&gt;</code>): -&gt; <code>boolean</code> 2. lt(<code>timestamp_tz</code>, <code>timestamp_tz</code>): -&gt; <code>boolean</code> 3. lt(<code>precision_timestamp_tz&lt;P&gt;</code>, <code>precision_timestamp_tz&lt;P&gt;</code>): -&gt; <code>boolean</code> 4. lt(<code>date</code>, <code>date</code>): -&gt; <code>boolean</code> 5. lt(<code>interval_day</code>, <code>interval_day</code>): -&gt; <code>boolean</code> 6. lt(<code>interval_year</code>, <code>interval_year</code>): -&gt; <code>boolean</code></p> <p>less than</p>"},{"location":"extensions/functions_datetime/#gte","title":"gte","text":"<p>Implementations: gte(<code>x</code>, <code>y</code>): -&gt; <code>return_type</code>  0. gte(<code>timestamp</code>, <code>timestamp</code>): -&gt; <code>boolean</code> 1. gte(<code>precision_timestamp&lt;P&gt;</code>, <code>precision_timestamp&lt;P&gt;</code>): -&gt; <code>boolean</code> 2. gte(<code>timestamp_tz</code>, <code>timestamp_tz</code>): -&gt; <code>boolean</code> 3. gte(<code>precision_timestamp_tz&lt;P&gt;</code>, <code>precision_timestamp_tz&lt;P&gt;</code>): -&gt; <code>boolean</code> 4. gte(<code>date</code>, <code>date</code>): -&gt; <code>boolean</code> 5. gte(<code>interval_day</code>, <code>interval_day</code>): -&gt; <code>boolean</code> 6. gte(<code>interval_year</code>, <code>interval_year</code>): -&gt; <code>boolean</code></p> <p>greater than or equal to</p>"},{"location":"extensions/functions_datetime/#gt","title":"gt","text":"<p>Implementations: gt(<code>x</code>, <code>y</code>): -&gt; <code>return_type</code>  0. gt(<code>timestamp</code>, <code>timestamp</code>): -&gt; <code>boolean</code> 1. gt(<code>precision_timestamp&lt;P&gt;</code>, <code>precision_timestamp&lt;P&gt;</code>): -&gt; <code>boolean</code> 2. gt(<code>timestamp_tz</code>, <code>timestamp_tz</code>): -&gt; <code>boolean</code> 3. gt(<code>precision_timestamp_tz&lt;P&gt;</code>, <code>precision_timestamp_tz&lt;P&gt;</code>): -&gt; <code>boolean</code> 4. gt(<code>date</code>, <code>date</code>): -&gt; <code>boolean</code> 5. gt(<code>interval_day</code>, <code>interval_day</code>): -&gt; <code>boolean</code> 6. gt(<code>interval_year</code>, <code>interval_year</code>): -&gt; <code>boolean</code></p> <p>greater than</p>"},{"location":"extensions/functions_datetime/#assume_timezone","title":"assume_timezone","text":"<p>Implementations: assume_timezone(<code>x</code>, <code>timezone</code>): -&gt; <code>return_type</code> </p> <li>x: Timezone string from IANA tzdb.</li> <p>0. assume_timezone(<code>timestamp</code>, <code>string</code>): -&gt; <code>timestamp_tz</code> 1. assume_timezone(<code>precision_timestamp&lt;P&gt;</code>, <code>string</code>): -&gt; <code>precision_timestamp_tz&lt;P&gt;</code> 2. assume_timezone(<code>date</code>, <code>string</code>): -&gt; <code>timestamp_tz</code></p> <p>Convert local timestamp to UTC-relative timestamp_tz using given local time\u2019s timezone. Timezone strings must be as defined by IANA timezone database (https://www.iana.org/time-zones). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown.</p>"},{"location":"extensions/functions_datetime/#local_timestamp","title":"local_timestamp","text":"<p>Implementations: local_timestamp(<code>x</code>, <code>timezone</code>): -&gt; <code>return_type</code> </p> <li>x: Timezone string from IANA tzdb.</li> <p>0. local_timestamp(<code>timestamp_tz</code>, <code>string</code>): -&gt; <code>timestamp</code> 1. local_timestamp(<code>precision_timestamp_tz&lt;P&gt;</code>, <code>string</code>): -&gt; <code>precision_timestamp&lt;P&gt;</code></p> <p>Convert UTC-relative timestamp_tz to local timestamp using given local time\u2019s timezone. Timezone strings must be as defined by IANA timezone database (https://www.iana.org/time-zones). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown.</p>"},{"location":"extensions/functions_datetime/#strptime_time","title":"strptime_time","text":"<p>Implementations: strptime_time(<code>time_string</code>, <code>format</code>): -&gt; <code>return_type</code>  0. strptime_time(<code>string</code>, <code>string</code>): -&gt; <code>time</code></p> <p>Parse string into time using provided format, see https://man7.org/linux/man-pages/man3/strptime.3.html for reference.</p>"},{"location":"extensions/functions_datetime/#strptime_date","title":"strptime_date","text":"<p>Implementations: strptime_date(<code>date_string</code>, <code>format</code>): -&gt; <code>return_type</code>  0. strptime_date(<code>string</code>, <code>string</code>): -&gt; <code>date</code></p> <p>Parse string into date using provided format, see https://man7.org/linux/man-pages/man3/strptime.3.html for reference.</p>"},{"location":"extensions/functions_datetime/#strptime_timestamp","title":"strptime_timestamp","text":"<p>Implementations: strptime_timestamp(<code>timestamp_string</code>, <code>format</code>, <code>timezone</code>): -&gt; <code>return_type</code> </p> <li>timestamp_string: Timezone string from IANA tzdb.</li> <p>0. strptime_timestamp(<code>string</code>, <code>string</code>, <code>string</code>): -&gt; <code>timestamp_tz</code> 1. strptime_timestamp(<code>string</code>, <code>string</code>): -&gt; <code>timestamp_tz</code></p> <p>Parse string into timestamp using provided format, see https://man7.org/linux/man-pages/man3/strptime.3.html for reference. If timezone is present in timestamp and provided as parameter an error is thrown. Timezone strings must be as defined by IANA timezone database (https://www.iana.org/time-zones). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is supplied as parameter and present in the parsed string the parsed timezone is used. If parameter supplied timezone is invalid an error is thrown.</p>"},{"location":"extensions/functions_datetime/#strftime","title":"strftime","text":"<p>Implementations: strftime(<code>x</code>, <code>format</code>): -&gt; <code>return_type</code>  0. strftime(<code>timestamp</code>, <code>string</code>): -&gt; <code>string</code> 1. strftime(<code>precision_timestamp&lt;P&gt;</code>, <code>string</code>): -&gt; <code>string</code> 2. strftime(<code>timestamp_tz</code>, <code>string</code>, <code>string</code>): -&gt; <code>string</code> 3. strftime(<code>precision_timestamp_tz&lt;P&gt;</code>, <code>string</code>, <code>string</code>): -&gt; <code>string</code> 4. strftime(<code>date</code>, <code>string</code>): -&gt; <code>string</code> 5. strftime(<code>time</code>, <code>string</code>): -&gt; <code>string</code></p> <p>Convert timestamp/date/time to string using provided format, see https://man7.org/linux/man-pages/man3/strftime.3.html for reference. Timezone strings must be as defined by IANA timezone database (https://www.iana.org/time-zones). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown.</p>"},{"location":"extensions/functions_datetime/#round_temporal","title":"round_temporal","text":"<p>Implementations: round_temporal(<code>x</code>, <code>rounding</code>, <code>unit</code>, <code>multiple</code>, <code>origin</code>): -&gt; <code>return_type</code>  0. round_temporal(<code>timestamp</code>, <code>rounding</code>, <code>unit</code>, <code>i64</code>, <code>timestamp</code>): -&gt; <code>timestamp</code> 1. round_temporal(<code>precision_timestamp&lt;P&gt;</code>, <code>rounding</code>, <code>unit</code>, <code>i64</code>, <code>precision_timestamp&lt;P&gt;</code>): -&gt; <code>precision_timestamp&lt;P&gt;</code> 2. round_temporal(<code>timestamp_tz</code>, <code>rounding</code>, <code>unit</code>, <code>i64</code>, <code>string</code>, <code>timestamp_tz</code>): -&gt; <code>timestamp_tz</code> 3. round_temporal(<code>precision_timestamp_tz&lt;P&gt;</code>, <code>rounding</code>, <code>unit</code>, <code>i64</code>, <code>string</code>, <code>precision_timestamp_tz&lt;P&gt;</code>): -&gt; <code>precision_timestamp_tz&lt;P&gt;</code> 4. round_temporal(<code>date</code>, <code>rounding</code>, <code>unit</code>, <code>i64</code>, <code>date</code>): -&gt; <code>date</code> 5. round_temporal(<code>time</code>, <code>rounding</code>, <code>unit</code>, <code>i64</code>, <code>time</code>): -&gt; <code>time</code></p> <p>Round a given timestamp/date/time to a multiple of a time unit. If the given timestamp is not already an exact multiple from the origin in the given timezone, the resulting point is chosen as one of the two nearest multiples. Which of these is chosen is governed by rounding: FLOOR means to use the earlier one, CEIL means to use the later one, ROUND_TIE_DOWN means to choose the nearest and tie to the earlier one if equidistant, ROUND_TIE_UP means to choose the nearest and tie to the later one if equidistant. Timezone strings must be as defined by IANA timezone database (https://www.iana.org/time-zones). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown.</p> Options: <li>rounding ['FLOOR', 'CEIL', 'ROUND_TIE_DOWN', 'ROUND_TIE_UP'] </li> <li>unit ['YEAR', 'MONTH', 'WEEK', 'DAY', 'HOUR', 'MINUTE', 'SECOND', 'MILLISECOND', 'MICROSECOND'] </li> <li>rounding ['YEAR', 'MONTH', 'WEEK', 'DAY'] </li> <li>unit ['HOUR', 'MINUTE', 'SECOND', 'MILLISECOND', 'MICROSECOND'] </li>"},{"location":"extensions/functions_datetime/#round_calendar","title":"round_calendar","text":"<p>Implementations: round_calendar(<code>x</code>, <code>rounding</code>, <code>unit</code>, <code>origin</code>, <code>multiple</code>): -&gt; <code>return_type</code>  0. round_calendar(<code>timestamp</code>, <code>rounding</code>, <code>unit</code>, <code>origin</code>, <code>i64</code>): -&gt; <code>timestamp</code> 1. round_calendar(<code>precision_timestamp&lt;P&gt;</code>, <code>rounding</code>, <code>unit</code>, <code>origin</code>, <code>i64</code>): -&gt; <code>precision_timestamp&lt;P&gt;</code> 2. round_calendar(<code>timestamp_tz</code>, <code>rounding</code>, <code>unit</code>, <code>origin</code>, <code>i64</code>, <code>string</code>): -&gt; <code>timestamp_tz</code> 3. round_calendar(<code>precision_timestamp_tz&lt;P&gt;</code>, <code>rounding</code>, <code>unit</code>, <code>origin</code>, <code>i64</code>, <code>string</code>): -&gt; <code>precision_timestamp_tz&lt;P&gt;</code> 4. round_calendar(<code>date</code>, <code>rounding</code>, <code>unit</code>, <code>origin</code>, <code>i64</code>, <code>date</code>): -&gt; <code>date</code> 5. round_calendar(<code>time</code>, <code>rounding</code>, <code>unit</code>, <code>origin</code>, <code>i64</code>, <code>time</code>): -&gt; <code>time</code></p> <p>Round a given timestamp/date/time to a multiple of a time unit. If the given timestamp is not already an exact multiple from the last origin unit in the given timezone, the resulting point is chosen as one of the two nearest multiples. Which of these is chosen is governed by rounding: FLOOR means to use the earlier one, CEIL means to use the later one, ROUND_TIE_DOWN means to choose the nearest and tie to the earlier one if equidistant, ROUND_TIE_UP means to choose the nearest and tie to the later one if equidistant. Timezone strings must be as defined by IANA timezone database (https://www.iana.org/time-zones). Examples: \u201cPacific/Marquesas\u201d, \u201cEtc/GMT+1\u201d. If timezone is invalid an error is thrown.</p> Options: <li>rounding ['FLOOR', 'CEIL', 'ROUND_TIE_DOWN', 'ROUND_TIE_UP'] </li> <li>unit ['YEAR', 'MONTH', 'WEEK', 'DAY', 'HOUR', 'MINUTE', 'SECOND', 'MILLISECOND', 'MICROSECOND'] </li> <li>origin ['YEAR', 'MONTH', 'MONDAY_WEEK', 'SUNDAY_WEEK', 'ISO_WEEK', 'US_WEEK', 'DAY', 'HOUR', 'MINUTE', 'SECOND', 'MILLISECOND'] </li> <li>rounding ['YEAR', 'MONTH', 'WEEK', 'DAY'] </li> <li>unit ['YEAR', 'MONTH', 'MONDAY_WEEK', 'SUNDAY_WEEK', 'ISO_WEEK', 'US_WEEK', 'DAY'] </li> <li>origin ['DAY', 'HOUR', 'MINUTE', 'SECOND', 'MILLISECOND', 'MICROSECOND'] </li> <li>rounding ['DAY', 'HOUR', 'MINUTE', 'SECOND', 'MILLISECOND'] </li>"},{"location":"extensions/functions_datetime/#aggregate-functions","title":"Aggregate Functions","text":""},{"location":"extensions/functions_datetime/#min","title":"min","text":"<p>Implementations: min(<code>x</code>): -&gt; <code>return_type</code>  0. min(<code>date</code>): -&gt; <code>date?</code> 1. min(<code>time</code>): -&gt; <code>time?</code> 2. min(<code>timestamp</code>): -&gt; <code>timestamp?</code> 3. min(<code>precision_timestamp&lt;P&gt;</code>): -&gt; <code>precision_timestamp?&lt;P&gt;</code> 4. min(<code>timestamp_tz</code>): -&gt; <code>timestamp_tz?</code> 5. min(<code>precision_timestamp_tz&lt;P&gt;</code>): -&gt; <code>precision_timestamp_tz?&lt;P&gt;</code> 6. min(<code>interval_day</code>): -&gt; <code>interval_day?</code> 7. min(<code>interval_year</code>): -&gt; <code>interval_year?</code></p> <p>Min a set of values.</p>"},{"location":"extensions/functions_datetime/#max","title":"max","text":"<p>Implementations: max(<code>x</code>): -&gt; <code>return_type</code>  0. max(<code>date</code>): -&gt; <code>date?</code> 1. max(<code>time</code>): -&gt; <code>time?</code> 2. max(<code>timestamp</code>): -&gt; <code>timestamp?</code> 3. max(<code>timestamp_tz</code>): -&gt; <code>timestamp_tz?</code> 4. max(<code>precision_timestamp_tz&lt;P&gt;</code>): -&gt; <code>precision_timestamp_tz?&lt;P&gt;</code> 5. max(<code>interval_day</code>): -&gt; <code>interval_day?</code> 6. max(<code>interval_year</code>): -&gt; <code>interval_year?</code></p> <p>Max a set of values.</p>"},{"location":"extensions/functions_geometry/","title":"functions_geometry.yaml","text":"<p>This document file is generated for functions_geometry.yaml</p>"},{"location":"extensions/functions_geometry/#data-types","title":"Data Types","text":"<p>name: geometry structure: BINARY</p>"},{"location":"extensions/functions_geometry/#scalar-functions","title":"Scalar Functions","text":""},{"location":"extensions/functions_geometry/#point","title":"point","text":"<p>Implementations: point(<code>x</code>, <code>y</code>): -&gt; <code>return_type</code>  0. point(<code>fp64</code>, <code>fp64</code>): -&gt; <code>u!geometry</code></p> <p>*Returns a 2D point with the given <code>x</code> and <code>y</code> coordinate values. *</p>"},{"location":"extensions/functions_geometry/#make_line","title":"make_line","text":"<p>Implementations: make_line(<code>geom1</code>, <code>geom2</code>): -&gt; <code>return_type</code>  0. make_line(<code>u!geometry</code>, <code>u!geometry</code>): -&gt; <code>u!geometry</code></p> <p>*Returns a linestring connecting the endpoint of geometry <code>geom1</code> to the begin point of geometry <code>geom2</code>. Repeated points at the beginning of input geometries are collapsed to a single point. A linestring can be closed or simple.  A closed linestring starts and ends on the same point. A simple linestring does not cross or touch itself. *</p>"},{"location":"extensions/functions_geometry/#x_coordinate","title":"x_coordinate","text":"<p>Implementations: x_coordinate(<code>point</code>): -&gt; <code>return_type</code>  0. x_coordinate(<code>u!geometry</code>): -&gt; <code>fp64</code></p> <p>*Return the x coordinate of the point.  Return null if not available. *</p>"},{"location":"extensions/functions_geometry/#y_coordinate","title":"y_coordinate","text":"<p>Implementations: y_coordinate(<code>point</code>): -&gt; <code>return_type</code>  0. y_coordinate(<code>u!geometry</code>): -&gt; <code>fp64</code></p> <p>*Return the y coordinate of the point.  Return null if not available. *</p>"},{"location":"extensions/functions_geometry/#num_points","title":"num_points","text":"<p>Implementations: num_points(<code>geom</code>): -&gt; <code>return_type</code>  0. num_points(<code>u!geometry</code>): -&gt; <code>i64</code></p> <p>*Return the number of points in the geometry.  The geometry should be an linestring or circularstring. *</p>"},{"location":"extensions/functions_geometry/#is_empty","title":"is_empty","text":"<p>Implementations: is_empty(<code>geom</code>): -&gt; <code>return_type</code>  0. is_empty(<code>u!geometry</code>): -&gt; <code>boolean</code></p> <p>*Return true is the geometry is an empty geometry. *</p>"},{"location":"extensions/functions_geometry/#is_closed","title":"is_closed","text":"<p>Implementations: is_closed(<code>geom</code>): -&gt; <code>return_type</code>  0. is_closed(<code>geometry</code>): -&gt; <code>boolean</code></p> <p>*Return true if the geometry\u2019s start and end points are the same. *</p>"},{"location":"extensions/functions_geometry/#is_simple","title":"is_simple","text":"<p>Implementations: is_simple(<code>geom</code>): -&gt; <code>return_type</code>  0. is_simple(<code>u!geometry</code>): -&gt; <code>boolean</code></p> <p>*Return true if the geometry does not self intersect. *</p>"},{"location":"extensions/functions_geometry/#is_ring","title":"is_ring","text":"<p>Implementations: is_ring(<code>geom</code>): -&gt; <code>return_type</code>  0. is_ring(<code>u!geometry</code>): -&gt; <code>boolean</code></p> <p>*Return true if the geometry\u2019s start and end points are the same and it does not self intersect. *</p>"},{"location":"extensions/functions_geometry/#geometry_type","title":"geometry_type","text":"<p>Implementations: geometry_type(<code>geom</code>): -&gt; <code>return_type</code>  0. geometry_type(<code>u!geometry</code>): -&gt; <code>string</code></p> <p>*Return the type of geometry as a string. *</p>"},{"location":"extensions/functions_geometry/#envelope","title":"envelope","text":"<p>Implementations: envelope(<code>geom</code>): -&gt; <code>return_type</code>  0. envelope(<code>u!geometry</code>): -&gt; <code>u!geometry</code></p> <p>*Return the minimum bounding box for the input geometry as a geometry. The returned geometry is defined by the corner points of the bounding box.  If the input geometry is a point or a line, the returned geometry can also be a point or line. *</p>"},{"location":"extensions/functions_geometry/#dimension","title":"dimension","text":"<p>Implementations: dimension(<code>geom</code>): -&gt; <code>return_type</code>  0. dimension(<code>u!geometry</code>): -&gt; <code>i8</code></p> <p>*Return the dimension of the input geometry.  If the input is a collection of geometries, return the largest dimension from the collection. Dimensionality is determined by the complexity of the input and not the coordinate system being used. Type dimensions: POINT   - 0 LINE    - 1 POLYGON - 2 *</p>"},{"location":"extensions/functions_geometry/#is_valid","title":"is_valid","text":"<p>Implementations: is_valid(<code>geom</code>): -&gt; <code>return_type</code>  0. is_valid(<code>u!geometry</code>): -&gt; <code>boolean</code></p> <p>*Return true if the input geometry is a valid 2D geometry. For 3 dimensional and 4 dimensional geometries, the validity is still only tested in 2 dimensions. *</p>"},{"location":"extensions/functions_geometry/#collection_extract","title":"collection_extract","text":"<p>Implementations: collection_extract(<code>geom_collection</code>): -&gt; <code>return_type</code>  0. collection_extract(<code>u!geometry</code>): -&gt; <code>u!geometry</code> 1. collection_extract(<code>u!geometry</code>, <code>i8</code>): -&gt; <code>u!geometry</code></p> <p>*Given the input geometry collection, return a homogenous multi-geometry.  All geometries in the multi-geometry will have the same dimension. If type is not specified, the multi-geometry will only contain geometries of the highest dimension.  If type is specified, the multi-geometry will only contain geometries of that type.  If there are no geometries of the specified type, an empty geometry is returned.  Only points, linestrings, and polygons are supported. Type numbers: POINT   - 0 LINE    - 1 POLYGON - 2 *</p>"},{"location":"extensions/functions_geometry/#flip_coordinates","title":"flip_coordinates","text":"<p>Implementations: flip_coordinates(<code>geom_collection</code>): -&gt; <code>return_type</code>  0. flip_coordinates(<code>u!geometry</code>): -&gt; <code>u!geometry</code></p> <p>*Return a version of the input geometry with the X and Y axis flipped. This operation can be performed on geometries with more than 2 dimensions. However, only X and Y axis will be flipped. *</p>"},{"location":"extensions/functions_geometry/#remove_repeated_points","title":"remove_repeated_points","text":"<p>Implementations: remove_repeated_points(<code>geom</code>): -&gt; <code>return_type</code>  0. remove_repeated_points(<code>u!geometry</code>): -&gt; <code>u!geometry</code> 1. remove_repeated_points(<code>u!geometry</code>, <code>fp64</code>): -&gt; <code>u!geometry</code></p> <p>*Return a version of the input geometry with duplicate consecutive points removed. If the <code>tolerance</code> argument is provided, consecutive points within the tolerance distance of one another are considered to be duplicates. *</p>"},{"location":"extensions/functions_geometry/#buffer","title":"buffer","text":"<p>Implementations: buffer(<code>geom</code>, <code>buffer_radius</code>): -&gt; <code>return_type</code>  0. buffer(<code>u!geometry</code>, <code>fp64</code>): -&gt; <code>u!geometry</code></p> <p>*Compute and return an expanded version of the input geometry. All the points of the returned geometry are at a distance of <code>buffer_radius</code> away from the points of the input geometry. If a negative <code>buffer_radius</code> is provided, the geometry will shrink instead of expand.  A negative <code>buffer_radius</code> may shrink the geometry completely, in which case an empty geometry is returned. For input the geometries of points or lines, a negative <code>buffer_radius</code> will always return an emtpy geometry. *</p>"},{"location":"extensions/functions_geometry/#centroid","title":"centroid","text":"<p>Implementations: centroid(<code>geom</code>): -&gt; <code>return_type</code>  0. centroid(<code>u!geometry</code>): -&gt; <code>u!geometry</code></p> <p>*Return a point which is the geometric center of mass of the input geometry. *</p>"},{"location":"extensions/functions_geometry/#minimum_bounding_circle","title":"minimum_bounding_circle","text":"<p>Implementations: minimum_bounding_circle(<code>geom</code>): -&gt; <code>return_type</code>  0. minimum_bounding_circle(<code>u!geometry</code>): -&gt; <code>u!geometry</code></p> <p>*Return the smallest circle polygon that contains the input geometry. *</p>"},{"location":"extensions/functions_logarithmic/","title":"functions_logarithmic.yaml","text":"<p>This document file is generated for functions_logarithmic.yaml</p>"},{"location":"extensions/functions_logarithmic/#scalar-functions","title":"Scalar Functions","text":""},{"location":"extensions/functions_logarithmic/#ln","title":"ln","text":"<p>Implementations: ln(<code>x</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_log_zero</code>): -&gt; <code>return_type</code>  0. ln(<code>i64</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_log_zero</code>): -&gt; <code>fp64</code> 1. ln(<code>fp32</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_log_zero</code>): -&gt; <code>fp32</code> 2. ln(<code>fp64</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_log_zero</code>): -&gt; <code>fp64</code> 3. ln(<code>decimal&lt;P,S&gt;</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_log_zero</code>): -&gt; <code>fp64</code></p> <p>Natural logarithm of the value</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li> <li>on_domain_error ['NAN', 'NULL', 'ERROR'] </li> <li>on_log_zero ['NAN', 'ERROR', 'MINUS_INFINITY'] </li>"},{"location":"extensions/functions_logarithmic/#log10","title":"log10","text":"<p>Implementations: log10(<code>x</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_log_zero</code>): -&gt; <code>return_type</code>  0. log10(<code>i64</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_log_zero</code>): -&gt; <code>fp64</code> 1. log10(<code>fp32</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_log_zero</code>): -&gt; <code>fp32</code> 2. log10(<code>fp64</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_log_zero</code>): -&gt; <code>fp64</code> 3. log10(<code>decimal&lt;P,S&gt;</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_log_zero</code>): -&gt; <code>fp64</code></p> <p>Logarithm to base 10 of the value</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li> <li>on_domain_error ['NAN', 'NULL', 'ERROR'] </li> <li>on_log_zero ['NAN', 'ERROR', 'MINUS_INFINITY'] </li>"},{"location":"extensions/functions_logarithmic/#log2","title":"log2","text":"<p>Implementations: log2(<code>x</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_log_zero</code>): -&gt; <code>return_type</code>  0. log2(<code>i64</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_log_zero</code>): -&gt; <code>fp64</code> 1. log2(<code>fp32</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_log_zero</code>): -&gt; <code>fp32</code> 2. log2(<code>fp64</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_log_zero</code>): -&gt; <code>fp64</code> 3. log2(<code>decimal&lt;P,S&gt;</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_log_zero</code>): -&gt; <code>fp64</code></p> <p>Logarithm to base 2 of the value</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li> <li>on_domain_error ['NAN', 'NULL', 'ERROR'] </li> <li>on_log_zero ['NAN', 'ERROR', 'MINUS_INFINITY'] </li>"},{"location":"extensions/functions_logarithmic/#logb","title":"logb","text":"<p>Implementations: logb(<code>x</code>, <code>base</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_log_zero</code>): -&gt; <code>return_type</code> </p> <li>x: The number `x` to compute the logarithm of</li> <li>base: The logarithm base `b` to use</li> <p>0. logb(<code>i64</code>, <code>i64</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_log_zero</code>): -&gt; <code>fp64</code> 1. logb(<code>fp32</code>, <code>fp32</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_log_zero</code>): -&gt; <code>fp32</code> 2. logb(<code>fp64</code>, <code>fp64</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_log_zero</code>): -&gt; <code>fp64</code> 3. logb(<code>decimal&lt;P1,S1&gt;</code>, <code>decimal&lt;P1,S1&gt;</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_log_zero</code>): -&gt; <code>fp64</code></p> <p>*Logarithm of the value with the given base logb(x, b) =&gt; log_{b} (x) *</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li> <li>on_domain_error ['NAN', 'NULL', 'ERROR'] </li> <li>on_log_zero ['NAN', 'ERROR', 'MINUS_INFINITY'] </li>"},{"location":"extensions/functions_logarithmic/#log1p","title":"log1p","text":"<p>Implementations: log1p(<code>x</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_log_zero</code>): -&gt; <code>return_type</code>  0. log1p(<code>fp32</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_log_zero</code>): -&gt; <code>fp32</code> 1. log1p(<code>fp64</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_log_zero</code>): -&gt; <code>fp64</code> 2. log1p(<code>decimal&lt;P,S&gt;</code>, <code>option:rounding</code>, <code>option:on_domain_error</code>, <code>option:on_log_zero</code>): -&gt; <code>fp64</code></p> <p>*Natural logarithm (base e) of 1 + x log1p(x) =&gt; log(1+x) *</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR'] </li> <li>on_domain_error ['NAN', 'NULL', 'ERROR'] </li> <li>on_log_zero ['NAN', 'ERROR', 'MINUS_INFINITY'] </li>"},{"location":"extensions/functions_rounding/","title":"functions_rounding.yaml","text":"<p>This document file is generated for functions_rounding.yaml</p>"},{"location":"extensions/functions_rounding/#scalar-functions","title":"Scalar Functions","text":""},{"location":"extensions/functions_rounding/#ceil","title":"ceil","text":"<p>Implementations: ceil(<code>x</code>): -&gt; <code>return_type</code>  0. ceil(<code>fp32</code>): -&gt; <code>fp32</code> 1. ceil(<code>fp64</code>): -&gt; <code>fp64</code></p> <p>*Rounding to the ceiling of the value <code>x</code>. *</p>"},{"location":"extensions/functions_rounding/#floor","title":"floor","text":"<p>Implementations: floor(<code>x</code>): -&gt; <code>return_type</code>  0. floor(<code>fp32</code>): -&gt; <code>fp32</code> 1. floor(<code>fp64</code>): -&gt; <code>fp64</code></p> <p>*Rounding to the floor of the value <code>x</code>. *</p>"},{"location":"extensions/functions_rounding/#round","title":"round","text":"<p>Implementations: round(<code>x</code>, <code>s</code>, <code>option:rounding</code>): -&gt; <code>return_type</code> </p> <li>x: Numerical expression to be rounded. </li> <li>s: Number of decimal places to be rounded to. When `s` is a positive number, nothing will happen since `x` is an integer value. When `s` is a negative number, the rounding is performed to the nearest multiple of `10^(-s)`. </li> <p>0. round(<code>i8</code>, <code>i32</code>, <code>option:rounding</code>): -&gt; <code>i8?</code> 1. round(<code>i16</code>, <code>i32</code>, <code>option:rounding</code>): -&gt; <code>i16?</code> 2. round(<code>i32</code>, <code>i32</code>, <code>option:rounding</code>): -&gt; <code>i32?</code> 3. round(<code>i64</code>, <code>i32</code>, <code>option:rounding</code>): -&gt; <code>i64?</code> 4. round(<code>fp32</code>, <code>i32</code>, <code>option:rounding</code>): -&gt; <code>fp32?</code> 5. round(<code>fp64</code>, <code>i32</code>, <code>option:rounding</code>): -&gt; <code>fp64?</code></p> <p>*Rounding the value <code>x</code> to <code>s</code> decimal places. *</p> Options: <li>rounding ['TIE_TO_EVEN', 'TIE_AWAY_FROM_ZERO', 'TRUNCATE', 'CEILING', 'FLOOR', 'AWAY_FROM_ZERO', 'TIE_DOWN', 'TIE_UP', 'TIE_TOWARDS_ZERO', 'TIE_TO_ODD'] </li>"},{"location":"extensions/functions_set/","title":"functions_set.yaml","text":"<p>This document file is generated for functions_set.yaml</p>"},{"location":"extensions/functions_set/#scalar-functions","title":"Scalar Functions","text":""},{"location":"extensions/functions_set/#index_in","title":"index_in","text":"<p>Implementations: index_in(<code>needle</code>, <code>haystack</code>, <code>option:nan_equality</code>): -&gt; <code>return_type</code>  0. index_in(<code>any1</code>, <code>list&lt;any1&gt;</code>, <code>option:nan_equality</code>): -&gt; <code>i64?</code></p> <p>*Checks the membership of a value in a list of values Returns the first 0-based index value of some input <code>needle</code> if <code>needle</code> is equal to any element in <code>haystack</code>.  Returns <code>NULL</code> if not found. If <code>needle</code> is <code>NULL</code>, returns <code>NULL</code>. If <code>needle</code> is <code>NaN</code>:   - Returns 0-based index of <code>NaN</code> in <code>input</code> (default)   - Returns <code>NULL</code> (if <code>NAN_IS_NOT_NAN</code> is specified) *</p> Options: <li>nan_equality ['NAN_IS_NAN', 'NAN_IS_NOT_NAN'] </li>"},{"location":"extensions/functions_string/","title":"functions_string.yaml","text":"<p>This document file is generated for functions_string.yaml</p>"},{"location":"extensions/functions_string/#scalar-functions","title":"Scalar Functions","text":""},{"location":"extensions/functions_string/#concat","title":"concat","text":"<p>Implementations: concat(<code>input</code>, <code>option:null_handling</code>): -&gt; <code>return_type</code>  0. concat(<code>varchar&lt;L1&gt;</code>, <code>option:null_handling</code>): -&gt; <code>varchar&lt;L1&gt;</code> 1. concat(<code>string</code>, <code>option:null_handling</code>): -&gt; <code>string</code></p> <p>Concatenate strings. The <code>null_handling</code> option determines whether or not null values will be recognized by the function. If <code>null_handling</code> is set to <code>IGNORE_NULLS</code>, null value arguments will be ignored when strings are concatenated. If set to <code>ACCEPT_NULLS</code>, the result will be null if any argument passed to the concat function is null.</p> Options: <li>null_handling ['IGNORE_NULLS', 'ACCEPT_NULLS'] </li>"},{"location":"extensions/functions_string/#like","title":"like","text":"<p>Implementations: like(<code>input</code>, <code>match</code>, <code>option:case_sensitivity</code>): -&gt; <code>return_type</code> </p> <li>input: The input string.</li> <li>match: The string to match against the input string.</li> <p>0. like(<code>varchar&lt;L1&gt;</code>, <code>varchar&lt;L2&gt;</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 1. like(<code>string</code>, <code>string</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code></p> <p>Are two strings like each other. The <code>case_sensitivity</code> option applies to the <code>match</code> argument.</p> Options: <li>case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] </li>"},{"location":"extensions/functions_string/#substring","title":"substring","text":"<p>Implementations: substring(<code>input</code>, <code>start</code>, <code>length</code>, <code>option:negative_start</code>): -&gt; <code>return_type</code>  0. substring(<code>varchar&lt;L1&gt;</code>, <code>i32</code>, <code>i32</code>, <code>option:negative_start</code>): -&gt; <code>varchar&lt;L1&gt;</code> 1. substring(<code>string</code>, <code>i32</code>, <code>i32</code>, <code>option:negative_start</code>): -&gt; <code>string</code> 2. substring(<code>fixedchar&lt;l1&gt;</code>, <code>i32</code>, <code>i32</code>, <code>option:negative_start</code>): -&gt; <code>string</code> 3. substring(<code>varchar&lt;L1&gt;</code>, <code>i32</code>, <code>option:negative_start</code>): -&gt; <code>varchar&lt;L1&gt;</code> 4. substring(<code>string</code>, <code>i32</code>, <code>option:negative_start</code>): -&gt; <code>string</code> 5. substring(<code>fixedchar&lt;l1&gt;</code>, <code>i32</code>, <code>option:negative_start</code>): -&gt; <code>string</code></p> <p>Extract a substring of a specified <code>length</code> starting from position <code>start</code>. A <code>start</code> value of 1 refers to the first characters of the string.  When <code>length</code> is not specified the function will extract a substring starting from position <code>start</code> and ending at the end of the string. The <code>negative_start</code> option applies to the <code>start</code> parameter. <code>WRAP_FROM_END</code> means the index will start from the end of the <code>input</code> and move backwards. The last character has an index of -1, the second to last character has an index of -2, and so on. <code>LEFT_OF_BEGINNING</code> means the returned substring will start from the left of the first character.  A <code>start</code> of -1 will begin 2 characters left of the the <code>input</code>, while a <code>start</code> of 0 begins 1 character left of the <code>input</code>.</p> Options: <li>negative_start ['WRAP_FROM_END', 'LEFT_OF_BEGINNING', 'ERROR'] </li> <li>negative_start ['WRAP_FROM_END', 'LEFT_OF_BEGINNING'] </li>"},{"location":"extensions/functions_string/#regexp_match_substring","title":"regexp_match_substring","text":"<p>Implementations: regexp_match_substring(<code>input</code>, <code>pattern</code>, <code>position</code>, <code>occurrence</code>, <code>group</code>, <code>option:case_sensitivity</code>, <code>option:multiline</code>, <code>option:dotall</code>): -&gt; <code>return_type</code>  0. regexp_match_substring(<code>varchar&lt;L1&gt;</code>, <code>varchar&lt;L2&gt;</code>, <code>i64</code>, <code>i64</code>, <code>i64</code>, <code>option:case_sensitivity</code>, <code>option:multiline</code>, <code>option:dotall</code>): -&gt; <code>varchar&lt;L1&gt;</code> 1. regexp_match_substring(<code>string</code>, <code>string</code>, <code>i64</code>, <code>i64</code>, <code>i64</code>, <code>option:case_sensitivity</code>, <code>option:multiline</code>, <code>option:dotall</code>): -&gt; <code>string</code></p> <p>Extract a substring that matches the given regular expression pattern. The regular expression pattern should follow the International Components for Unicode implementation (https://unicode-org.github.io/icu/userguide/strings/regexp.html). The occurrence of the pattern to be extracted is specified using the <code>occurrence</code> argument. Specifying <code>1</code> means the first occurrence will be extracted, <code>2</code> means the second occurrence, and so on. The <code>occurrence</code> argument should be a positive non-zero integer. The number of characters from the beginning of the string to begin starting to search for pattern matches can be specified using the <code>position</code> argument. Specifying <code>1</code> means to search for matches starting at the first character of the input string, <code>2</code> means the second character, and so on. The <code>position</code> argument should be a positive non-zero integer. The regular expression capture group can be specified using the <code>group</code> argument. Specifying <code>0</code> will return the substring matching the full regular expression. Specifying <code>1</code> will return the substring matching only the first capture group, and so on. The <code>group</code> argument should be a non-negative integer. The <code>case_sensitivity</code> option specifies case-sensitive or case-insensitive matching. Enabling the <code>multiline</code> option will treat the input string as multiple lines. This makes the <code>^</code> and <code>$</code> characters match at the beginning and end of any line, instead of just the beginning and end of the input string. Enabling the <code>dotall</code> option makes the <code>.</code> character match line terminator characters in a string. Behavior is undefined if the regex fails to compile, the occurrence value is out of range, the position value is out of range, or the group value is out of range.</p> Options: <li>case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] </li> <li>multiline ['MULTILINE_DISABLED', 'MULTILINE_ENABLED'] </li> <li>dotall ['DOTALL_DISABLED', 'DOTALL_ENABLED'] </li>"},{"location":"extensions/functions_string/#regexp_match_substring_all","title":"regexp_match_substring_all","text":"<p>Implementations: regexp_match_substring_all(<code>input</code>, <code>pattern</code>, <code>position</code>, <code>group</code>, <code>option:case_sensitivity</code>, <code>option:multiline</code>, <code>option:dotall</code>): -&gt; <code>return_type</code>  0. regexp_match_substring_all(<code>varchar&lt;L1&gt;</code>, <code>varchar&lt;L2&gt;</code>, <code>i64</code>, <code>i64</code>, <code>option:case_sensitivity</code>, <code>option:multiline</code>, <code>option:dotall</code>): -&gt; <code>List&lt;varchar&lt;L1&gt;&gt;</code> 1. regexp_match_substring_all(<code>string</code>, <code>string</code>, <code>i64</code>, <code>i64</code>, <code>option:case_sensitivity</code>, <code>option:multiline</code>, <code>option:dotall</code>): -&gt; <code>List&lt;string&gt;</code></p> <p>Extract all substrings that match the given regular expression pattern. This will return a list of extracted strings with one value for each occurrence of a match. The regular expression pattern should follow the International Components for Unicode implementation (https://unicode-org.github.io/icu/userguide/strings/regexp.html). The number of characters from the beginning of the string to begin starting to search for pattern matches can be specified using the <code>position</code> argument. Specifying <code>1</code> means to search for matches starting at the first character of the input string, <code>2</code> means the second character, and so on. The <code>position</code> argument should be a positive non-zero integer. The regular expression capture group can be specified using the <code>group</code> argument. Specifying <code>0</code> will return substrings matching the full regular expression. Specifying <code>1</code> will return substrings matching only the first capture group, and so on. The <code>group</code> argument should be a non-negative integer. The <code>case_sensitivity</code> option specifies case-sensitive or case-insensitive matching. Enabling the <code>multiline</code> option will treat the input string as multiple lines. This makes the <code>^</code> and <code>$</code> characters match at the beginning and end of any line, instead of just the beginning and end of the input string. Enabling the <code>dotall</code> option makes the <code>.</code> character match line terminator characters in a string. Behavior is undefined if the regex fails to compile, the position value is out of range, or the group value is out of range.</p> Options: <li>case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] </li> <li>multiline ['MULTILINE_DISABLED', 'MULTILINE_ENABLED'] </li> <li>dotall ['DOTALL_DISABLED', 'DOTALL_ENABLED'] </li>"},{"location":"extensions/functions_string/#starts_with","title":"starts_with","text":"<p>Implementations: starts_with(<code>input</code>, <code>substring</code>, <code>option:case_sensitivity</code>): -&gt; <code>return_type</code> </p> <li>input: The input string.</li> <li>substring: The substring to search for.</li> <p>0. starts_with(<code>varchar&lt;L1&gt;</code>, <code>varchar&lt;L2&gt;</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 1. starts_with(<code>varchar&lt;L1&gt;</code>, <code>string</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 2. starts_with(<code>varchar&lt;L1&gt;</code>, <code>fixedchar&lt;L2&gt;</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 3. starts_with(<code>string</code>, <code>string</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 4. starts_with(<code>string</code>, <code>varchar&lt;L1&gt;</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 5. starts_with(<code>string</code>, <code>fixedchar&lt;L1&gt;</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 6. starts_with(<code>fixedchar&lt;L1&gt;</code>, <code>fixedchar&lt;L2&gt;</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 7. starts_with(<code>fixedchar&lt;L1&gt;</code>, <code>string</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 8. starts_with(<code>fixedchar&lt;L1&gt;</code>, <code>varchar&lt;L2&gt;</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code></p> <p>Whether the <code>input</code> string starts with the <code>substring</code>. The <code>case_sensitivity</code> option applies to the <code>substring</code> argument.</p> Options: <li>case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] </li>"},{"location":"extensions/functions_string/#ends_with","title":"ends_with","text":"<p>Implementations: ends_with(<code>input</code>, <code>substring</code>, <code>option:case_sensitivity</code>): -&gt; <code>return_type</code> </p> <li>input: The input string.</li> <li>substring: The substring to search for.</li> <p>0. ends_with(<code>varchar&lt;L1&gt;</code>, <code>varchar&lt;L2&gt;</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 1. ends_with(<code>varchar&lt;L1&gt;</code>, <code>string</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 2. ends_with(<code>varchar&lt;L1&gt;</code>, <code>fixedchar&lt;L2&gt;</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 3. ends_with(<code>string</code>, <code>string</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 4. ends_with(<code>string</code>, <code>varchar&lt;L1&gt;</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 5. ends_with(<code>string</code>, <code>fixedchar&lt;L1&gt;</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 6. ends_with(<code>fixedchar&lt;L1&gt;</code>, <code>fixedchar&lt;L2&gt;</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 7. ends_with(<code>fixedchar&lt;L1&gt;</code>, <code>string</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 8. ends_with(<code>fixedchar&lt;L1&gt;</code>, <code>varchar&lt;L2&gt;</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code></p> <p>Whether <code>input</code> string ends with the substring. The <code>case_sensitivity</code> option applies to the <code>substring</code> argument.</p> Options: <li>case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] </li>"},{"location":"extensions/functions_string/#contains","title":"contains","text":"<p>Implementations: contains(<code>input</code>, <code>substring</code>, <code>option:case_sensitivity</code>): -&gt; <code>return_type</code> </p> <li>input: The input string.</li> <li>substring: The substring to search for.</li> <p>0. contains(<code>varchar&lt;L1&gt;</code>, <code>varchar&lt;L2&gt;</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 1. contains(<code>varchar&lt;L1&gt;</code>, <code>string</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 2. contains(<code>varchar&lt;L1&gt;</code>, <code>fixedchar&lt;L2&gt;</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 3. contains(<code>string</code>, <code>string</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 4. contains(<code>string</code>, <code>varchar&lt;L1&gt;</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 5. contains(<code>string</code>, <code>fixedchar&lt;L1&gt;</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 6. contains(<code>fixedchar&lt;L1&gt;</code>, <code>fixedchar&lt;L2&gt;</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 7. contains(<code>fixedchar&lt;L1&gt;</code>, <code>string</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code> 8. contains(<code>fixedchar&lt;L1&gt;</code>, <code>varchar&lt;L2&gt;</code>, <code>option:case_sensitivity</code>): -&gt; <code>boolean</code></p> <p>Whether the <code>input</code> string contains the <code>substring</code>. The <code>case_sensitivity</code> option applies to the <code>substring</code> argument.</p> Options: <li>case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] </li>"},{"location":"extensions/functions_string/#strpos","title":"strpos","text":"<p>Implementations: strpos(<code>input</code>, <code>substring</code>, <code>option:case_sensitivity</code>): -&gt; <code>return_type</code> </p> <li>input: The input string.</li> <li>substring: The substring to search for.</li> <p>0. strpos(<code>string</code>, <code>string</code>, <code>option:case_sensitivity</code>): -&gt; <code>i64</code> 1. strpos(<code>varchar&lt;L1&gt;</code>, <code>varchar&lt;L1&gt;</code>, <code>option:case_sensitivity</code>): -&gt; <code>i64</code> 2. strpos(<code>fixedchar&lt;L1&gt;</code>, <code>fixedchar&lt;L2&gt;</code>, <code>option:case_sensitivity</code>): -&gt; <code>i64</code></p> <p>Return the position of the first occurrence of a string in another string. The first character of the string is at position 1. If no occurrence is found, 0 is returned. The <code>case_sensitivity</code> option applies to the <code>substring</code> argument.</p> Options: <li>case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] </li>"},{"location":"extensions/functions_string/#regexp_strpos","title":"regexp_strpos","text":"<p>Implementations: regexp_strpos(<code>input</code>, <code>pattern</code>, <code>position</code>, <code>occurrence</code>, <code>option:case_sensitivity</code>, <code>option:multiline</code>, <code>option:dotall</code>): -&gt; <code>return_type</code>  0. regexp_strpos(<code>varchar&lt;L1&gt;</code>, <code>varchar&lt;L2&gt;</code>, <code>i64</code>, <code>i64</code>, <code>option:case_sensitivity</code>, <code>option:multiline</code>, <code>option:dotall</code>): -&gt; <code>i64</code> 1. regexp_strpos(<code>string</code>, <code>string</code>, <code>i64</code>, <code>i64</code>, <code>option:case_sensitivity</code>, <code>option:multiline</code>, <code>option:dotall</code>): -&gt; <code>i64</code></p> <p>Return the position of an occurrence of the given regular expression pattern in a string. The first character of the string is at position 1. The regular expression pattern should follow the International Components for Unicode implementation (https://unicode-org.github.io/icu/userguide/strings/regexp.html). The number of characters from the beginning of the string to begin starting to search for pattern matches can be specified using the <code>position</code> argument. Specifying <code>1</code> means to search for matches starting at the first character of the input string, <code>2</code> means the second character, and so on. The <code>position</code> argument should be a positive non-zero integer. Which occurrence to return the position of is specified using the <code>occurrence</code> argument. Specifying <code>1</code> means the position first occurrence will be returned, <code>2</code> means the position of the second occurrence, and so on. The <code>occurrence</code> argument should be a positive non-zero integer. If no occurrence is found, 0 is returned. The <code>case_sensitivity</code> option specifies case-sensitive or case-insensitive matching. Enabling the <code>multiline</code> option will treat the input string as multiple lines. This makes the <code>^</code> and <code>$</code> characters match at the beginning and end of any line, instead of just the beginning and end of the input string. Enabling the <code>dotall</code> option makes the <code>.</code> character match line terminator characters in a string. Behavior is undefined if the regex fails to compile, the occurrence value is out of range, or the position value is out of range.</p> Options: <li>case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] </li> <li>multiline ['MULTILINE_DISABLED', 'MULTILINE_ENABLED'] </li> <li>dotall ['DOTALL_DISABLED', 'DOTALL_ENABLED'] </li>"},{"location":"extensions/functions_string/#count_substring","title":"count_substring","text":"<p>Implementations: count_substring(<code>input</code>, <code>substring</code>, <code>option:case_sensitivity</code>): -&gt; <code>return_type</code> </p> <li>input: The input string.</li> <li>substring: The substring to count.</li> <p>0. count_substring(<code>string</code>, <code>string</code>, <code>option:case_sensitivity</code>): -&gt; <code>i64</code> 1. count_substring(<code>varchar&lt;L1&gt;</code>, <code>varchar&lt;L2&gt;</code>, <code>option:case_sensitivity</code>): -&gt; <code>i64</code> 2. count_substring(<code>fixedchar&lt;L1&gt;</code>, <code>fixedchar&lt;L2&gt;</code>, <code>option:case_sensitivity</code>): -&gt; <code>i64</code></p> <p>Return the number of non-overlapping occurrences of a substring in an input string. The <code>case_sensitivity</code> option applies to the <code>substring</code> argument.</p> Options: <li>case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] </li>"},{"location":"extensions/functions_string/#regexp_count_substring","title":"regexp_count_substring","text":"<p>Implementations: regexp_count_substring(<code>input</code>, <code>pattern</code>, <code>position</code>, <code>option:case_sensitivity</code>, <code>option:multiline</code>, <code>option:dotall</code>): -&gt; <code>return_type</code>  0. regexp_count_substring(<code>string</code>, <code>string</code>, <code>i64</code>, <code>option:case_sensitivity</code>, <code>option:multiline</code>, <code>option:dotall</code>): -&gt; <code>i64</code> 1. regexp_count_substring(<code>varchar&lt;L1&gt;</code>, <code>varchar&lt;L2&gt;</code>, <code>i64</code>, <code>option:case_sensitivity</code>, <code>option:multiline</code>, <code>option:dotall</code>): -&gt; <code>i64</code> 2. regexp_count_substring(<code>fixedchar&lt;L1&gt;</code>, <code>fixedchar&lt;L2&gt;</code>, <code>i64</code>, <code>option:case_sensitivity</code>, <code>option:multiline</code>, <code>option:dotall</code>): -&gt; <code>i64</code></p> <p>Return the number of non-overlapping occurrences of a regular expression pattern in an input string. The regular expression pattern should follow the International Components for Unicode implementation (https://unicode-org.github.io/icu/userguide/strings/regexp.html). The number of characters from the beginning of the string to begin starting to search for pattern matches can be specified using the <code>position</code> argument. Specifying <code>1</code> means to search for matches starting at the first character of the input string, <code>2</code> means the second character, and so on. The <code>position</code> argument should be a positive non-zero integer. The <code>case_sensitivity</code> option specifies case-sensitive or case-insensitive matching. Enabling the <code>multiline</code> option will treat the input string as multiple lines. This makes the <code>^</code> and <code>$</code> characters match at the beginning and end of any line, instead of just the beginning and end of the input string. Enabling the <code>dotall</code> option makes the <code>.</code> character match line terminator characters in a string. Behavior is undefined if the regex fails to compile or the position value is out of range.</p> Options: <li>case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] </li> <li>multiline ['MULTILINE_DISABLED', 'MULTILINE_ENABLED'] </li> <li>dotall ['DOTALL_DISABLED', 'DOTALL_ENABLED'] </li>"},{"location":"extensions/functions_string/#replace","title":"replace","text":"<p>Implementations: replace(<code>input</code>, <code>substring</code>, <code>replacement</code>, <code>option:case_sensitivity</code>): -&gt; <code>return_type</code> </p> <li>input: Input string.</li> <li>substring: The substring to replace.</li> <li>replacement: The replacement string.</li> <p>0. replace(<code>string</code>, <code>string</code>, <code>string</code>, <code>option:case_sensitivity</code>): -&gt; <code>string</code> 1. replace(<code>varchar&lt;L1&gt;</code>, <code>varchar&lt;L2&gt;</code>, <code>varchar&lt;L3&gt;</code>, <code>option:case_sensitivity</code>): -&gt; <code>varchar&lt;L1&gt;</code></p> <p>Replace all occurrences of the substring with the replacement string. The <code>case_sensitivity</code> option applies to the <code>substring</code> argument.</p> Options: <li>case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] </li>"},{"location":"extensions/functions_string/#concat_ws","title":"concat_ws","text":"<p>Implementations: concat_ws(<code>separator</code>, <code>string_arguments</code>): -&gt; <code>return_type</code> </p> <li>separator: Character to separate strings by.</li> <li>string_arguments: Strings to be concatenated.</li> <p>0. concat_ws(<code>string</code>, <code>string</code>): -&gt; <code>string</code> 1. concat_ws(<code>varchar&lt;L2&gt;</code>, <code>varchar&lt;L1&gt;</code>): -&gt; <code>varchar&lt;L1&gt;</code></p> <p>Concatenate strings together separated by a separator.</p>"},{"location":"extensions/functions_string/#repeat","title":"repeat","text":"<p>Implementations: repeat(<code>input</code>, <code>count</code>): -&gt; <code>return_type</code>  0. repeat(<code>string</code>, <code>i64</code>): -&gt; <code>string</code> 1. repeat(<code>varchar&lt;L1&gt;</code>, <code>i64</code>, <code>i64</code>): -&gt; <code>varchar&lt;L1&gt;</code></p> <p>Repeat a string <code>count</code> number of times.</p>"},{"location":"extensions/functions_string/#reverse","title":"reverse","text":"<p>Implementations: reverse(<code>input</code>): -&gt; <code>return_type</code>  0. reverse(<code>string</code>): -&gt; <code>string</code> 1. reverse(<code>varchar&lt;L1&gt;</code>): -&gt; <code>varchar&lt;L1&gt;</code> 2. reverse(<code>fixedchar&lt;L1&gt;</code>): -&gt; <code>fixedchar&lt;L1&gt;</code></p> <p>Returns the string in reverse order.</p>"},{"location":"extensions/functions_string/#replace_slice","title":"replace_slice","text":"<p>Implementations: replace_slice(<code>input</code>, <code>start</code>, <code>length</code>, <code>replacement</code>): -&gt; <code>return_type</code> </p> <li>input: Input string.</li> <li>start: The position in the string to start deleting/inserting characters.</li> <li>length: The number of characters to delete from the input string.</li> <li>replacement: The new string to insert at the start position.</li> <p>0. replace_slice(<code>string</code>, <code>i64</code>, <code>i64</code>, <code>string</code>): -&gt; <code>string</code> 1. replace_slice(<code>varchar&lt;L1&gt;</code>, <code>i64</code>, <code>i64</code>, <code>varchar&lt;L2&gt;</code>): -&gt; <code>varchar&lt;L1&gt;</code></p> <p>Replace a slice of the input string.  A specified \u2018length\u2019 of characters will be deleted from the input string beginning at the \u2018start\u2019 position and will be replaced by a new string.  A start value of 1 indicates the first character of the input string. If start is negative or zero, or greater than the length of the input string, a null string is returned. If \u2018length\u2019 is negative, a null string is returned.  If \u2018length\u2019 is zero, inserting of the new string occurs at the specified \u2018start\u2019 position and no characters are deleted. If \u2018length\u2019 is greater than the input string, deletion will occur up to the last character of the input string.</p>"},{"location":"extensions/functions_string/#lower","title":"lower","text":"<p>Implementations: lower(<code>input</code>, <code>option:char_set</code>): -&gt; <code>return_type</code>  0. lower(<code>string</code>, <code>option:char_set</code>): -&gt; <code>string</code> 1. lower(<code>varchar&lt;L1&gt;</code>, <code>option:char_set</code>): -&gt; <code>varchar&lt;L1&gt;</code> 2. lower(<code>fixedchar&lt;L1&gt;</code>, <code>option:char_set</code>): -&gt; <code>fixedchar&lt;L1&gt;</code></p> <p>Transform the string to lower case characters. Implementation should follow the utf8_unicode_ci collations according to the Unicode Collation Algorithm described at http://www.unicode.org/reports/tr10/.</p> Options: <li>char_set ['UTF8', 'ASCII_ONLY'] </li>"},{"location":"extensions/functions_string/#upper","title":"upper","text":"<p>Implementations: upper(<code>input</code>, <code>option:char_set</code>): -&gt; <code>return_type</code>  0. upper(<code>string</code>, <code>option:char_set</code>): -&gt; <code>string</code> 1. upper(<code>varchar&lt;L1&gt;</code>, <code>option:char_set</code>): -&gt; <code>varchar&lt;L1&gt;</code> 2. upper(<code>fixedchar&lt;L1&gt;</code>, <code>option:char_set</code>): -&gt; <code>fixedchar&lt;L1&gt;</code></p> <p>Transform the string to upper case characters. Implementation should follow the utf8_unicode_ci collations according to the Unicode Collation Algorithm described at http://www.unicode.org/reports/tr10/.</p> Options: <li>char_set ['UTF8', 'ASCII_ONLY'] </li>"},{"location":"extensions/functions_string/#swapcase","title":"swapcase","text":"<p>Implementations: swapcase(<code>input</code>, <code>option:char_set</code>): -&gt; <code>return_type</code>  0. swapcase(<code>string</code>, <code>option:char_set</code>): -&gt; <code>string</code> 1. swapcase(<code>varchar&lt;L1&gt;</code>, <code>option:char_set</code>): -&gt; <code>varchar&lt;L1&gt;</code> 2. swapcase(<code>fixedchar&lt;L1&gt;</code>, <code>option:char_set</code>): -&gt; <code>fixedchar&lt;L1&gt;</code></p> <p>Transform the string\u2019s lowercase characters to uppercase and uppercase characters to lowercase. Implementation should follow the utf8_unicode_ci collations according to the Unicode Collation Algorithm described at http://www.unicode.org/reports/tr10/.</p> Options: <li>char_set ['UTF8', 'ASCII_ONLY'] </li>"},{"location":"extensions/functions_string/#capitalize","title":"capitalize","text":"<p>Implementations: capitalize(<code>input</code>, <code>option:char_set</code>): -&gt; <code>return_type</code>  0. capitalize(<code>string</code>, <code>option:char_set</code>): -&gt; <code>string</code> 1. capitalize(<code>varchar&lt;L1&gt;</code>, <code>option:char_set</code>): -&gt; <code>varchar&lt;L1&gt;</code> 2. capitalize(<code>fixedchar&lt;L1&gt;</code>, <code>option:char_set</code>): -&gt; <code>fixedchar&lt;L1&gt;</code></p> <p>Capitalize the first character of the input string. Implementation should follow the utf8_unicode_ci collations according to the Unicode Collation Algorithm described at http://www.unicode.org/reports/tr10/.</p> Options: <li>char_set ['UTF8', 'ASCII_ONLY'] </li>"},{"location":"extensions/functions_string/#title","title":"title","text":"<p>Implementations: title(<code>input</code>, <code>option:char_set</code>): -&gt; <code>return_type</code>  0. title(<code>string</code>, <code>option:char_set</code>): -&gt; <code>string</code> 1. title(<code>varchar&lt;L1&gt;</code>, <code>option:char_set</code>): -&gt; <code>varchar&lt;L1&gt;</code> 2. title(<code>fixedchar&lt;L1&gt;</code>, <code>option:char_set</code>): -&gt; <code>fixedchar&lt;L1&gt;</code></p> <p>Converts the input string into titlecase. Capitalize the first character of each word in the input string except for articles (a, an, the). Implementation should follow the utf8_unicode_ci collations according to the Unicode Collation Algorithm described at http://www.unicode.org/reports/tr10/.</p> Options: <li>char_set ['UTF8', 'ASCII_ONLY'] </li>"},{"location":"extensions/functions_string/#initcap","title":"initcap","text":"<p>Implementations: initcap(<code>input</code>, <code>option:char_set</code>): -&gt; <code>return_type</code>  0. initcap(<code>string</code>, <code>option:char_set</code>): -&gt; <code>string</code> 1. initcap(<code>varchar&lt;L1&gt;</code>, <code>option:char_set</code>): -&gt; <code>varchar&lt;L1&gt;</code> 2. initcap(<code>fixedchar&lt;L1&gt;</code>, <code>option:char_set</code>): -&gt; <code>fixedchar&lt;L1&gt;</code></p> <p>Capitalizes the first character of each word in the input string, including articles, and lowercases the rest. Implementation should follow the utf8_unicode_ci collations according to the Unicode Collation Algorithm described at http://www.unicode.org/reports/tr10/.</p> Options: <li>char_set ['UTF8', 'ASCII_ONLY'] </li>"},{"location":"extensions/functions_string/#char_length","title":"char_length","text":"<p>Implementations: char_length(<code>input</code>): -&gt; <code>return_type</code>  0. char_length(<code>string</code>): -&gt; <code>i64</code> 1. char_length(<code>varchar&lt;L1&gt;</code>): -&gt; <code>i64</code> 2. char_length(<code>fixedchar&lt;L1&gt;</code>): -&gt; <code>i64</code></p> <p>Return the number of characters in the input string.  The length includes trailing spaces.</p>"},{"location":"extensions/functions_string/#bit_length","title":"bit_length","text":"<p>Implementations: bit_length(<code>input</code>): -&gt; <code>return_type</code>  0. bit_length(<code>string</code>): -&gt; <code>i64</code> 1. bit_length(<code>varchar&lt;L1&gt;</code>): -&gt; <code>i64</code> 2. bit_length(<code>fixedchar&lt;L1&gt;</code>): -&gt; <code>i64</code></p> <p>Return the number of bits in the input string.</p>"},{"location":"extensions/functions_string/#octet_length","title":"octet_length","text":"<p>Implementations: octet_length(<code>input</code>): -&gt; <code>return_type</code>  0. octet_length(<code>string</code>): -&gt; <code>i64</code> 1. octet_length(<code>varchar&lt;L1&gt;</code>): -&gt; <code>i64</code> 2. octet_length(<code>fixedchar&lt;L1&gt;</code>): -&gt; <code>i64</code></p> <p>Return the number of bytes in the input string.</p>"},{"location":"extensions/functions_string/#regexp_replace","title":"regexp_replace","text":"<p>Implementations: regexp_replace(<code>input</code>, <code>pattern</code>, <code>replacement</code>, <code>position</code>, <code>occurrence</code>, <code>option:case_sensitivity</code>, <code>option:multiline</code>, <code>option:dotall</code>): -&gt; <code>return_type</code> </p> <li>input: The input string.</li> <li>pattern: The regular expression to search for within the input string.</li> <li>replacement: The replacement string.</li> <li>position: The position to start the search.</li> <li>occurrence: Which occurrence of the match to replace.</li> <p>0. regexp_replace(<code>string</code>, <code>string</code>, <code>string</code>, <code>i64</code>, <code>i64</code>, <code>option:case_sensitivity</code>, <code>option:multiline</code>, <code>option:dotall</code>): -&gt; <code>string</code> 1. regexp_replace(<code>varchar&lt;L1&gt;</code>, <code>varchar&lt;L2&gt;</code>, <code>varchar&lt;L3&gt;</code>, <code>i64</code>, <code>i64</code>, <code>option:case_sensitivity</code>, <code>option:multiline</code>, <code>option:dotall</code>): -&gt; <code>varchar&lt;L1&gt;</code></p> <p>Search a string for a substring that matches a given regular expression pattern and replace it with a replacement string. The regular expression pattern should follow the International Components for Unicode implementation (https://unicode-org.github .io/icu/userguide/strings/regexp.html). The occurrence of the pattern to be replaced is specified using the <code>occurrence</code> argument. Specifying <code>1</code> means only the first occurrence will be replaced, <code>2</code> means the second occurrence, and so on. Specifying <code>0</code> means all occurrences will be replaced. The number of characters from the beginning of the string to begin starting to search for pattern matches can be specified using the <code>position</code> argument. Specifying <code>1</code> means to search for matches starting at the first character of the input string, <code>2</code> means the second character, and so on. The <code>position</code> argument should be a positive non-zero integer. The replacement string can capture groups using numbered backreferences. The <code>case_sensitivity</code> option specifies case-sensitive or case-insensitive matching. Enabling the <code>multiline</code> option will treat the input string as multiple lines.  This makes the <code>^</code> and <code>$</code> characters match at the beginning and end of any line, instead of just the beginning and end of the input string. Enabling the <code>dotall</code> option makes the <code>.</code> character match line terminator characters in a string. Behavior is undefined if the regex fails to compile, the replacement contains an illegal back-reference, the occurrence value is out of range, or the position value is out of range.</p> Options: <li>case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] </li> <li>multiline ['MULTILINE_DISABLED', 'MULTILINE_ENABLED'] </li> <li>dotall ['DOTALL_DISABLED', 'DOTALL_ENABLED'] </li>"},{"location":"extensions/functions_string/#ltrim","title":"ltrim","text":"<p>Implementations: ltrim(<code>input</code>, <code>characters</code>): -&gt; <code>return_type</code> </p> <li>input: The string to remove characters from.</li> <li>characters: The set of characters to remove.</li> <p>0. ltrim(<code>varchar&lt;L1&gt;</code>, <code>varchar&lt;L2&gt;</code>): -&gt; <code>varchar&lt;L1&gt;</code> 1. ltrim(<code>string</code>, <code>string</code>): -&gt; <code>string</code></p> <p>Remove any occurrence of the characters from the left side of the string. If no characters are specified, spaces are removed.</p>"},{"location":"extensions/functions_string/#rtrim","title":"rtrim","text":"<p>Implementations: rtrim(<code>input</code>, <code>characters</code>): -&gt; <code>return_type</code> </p> <li>input: The string to remove characters from.</li> <li>characters: The set of characters to remove.</li> <p>0. rtrim(<code>varchar&lt;L1&gt;</code>, <code>varchar&lt;L2&gt;</code>): -&gt; <code>varchar&lt;L1&gt;</code> 1. rtrim(<code>string</code>, <code>string</code>): -&gt; <code>string</code></p> <p>Remove any occurrence of the characters from the right side of the string. If no characters are specified, spaces are removed.</p>"},{"location":"extensions/functions_string/#trim","title":"trim","text":"<p>Implementations: trim(<code>input</code>, <code>characters</code>): -&gt; <code>return_type</code> </p> <li>input: The string to remove characters from.</li> <li>characters: The set of characters to remove.</li> <p>0. trim(<code>varchar&lt;L1&gt;</code>, <code>varchar&lt;L2&gt;</code>): -&gt; <code>varchar&lt;L1&gt;</code> 1. trim(<code>string</code>, <code>string</code>): -&gt; <code>string</code></p> <p>Remove any occurrence of the characters from the left and right sides of the string. If no characters are specified, spaces are removed.</p>"},{"location":"extensions/functions_string/#lpad","title":"lpad","text":"<p>Implementations: lpad(<code>input</code>, <code>length</code>, <code>characters</code>): -&gt; <code>return_type</code> </p> <li>input: The string to pad.</li> <li>length: The length of the output string.</li> <li>characters: The string of characters to use for padding.</li> <p>0. lpad(<code>varchar&lt;L1&gt;</code>, <code>i32</code>, <code>varchar&lt;L2&gt;</code>): -&gt; <code>varchar&lt;L1&gt;</code> 1. lpad(<code>string</code>, <code>i32</code>, <code>string</code>): -&gt; <code>string</code></p> <p>Left-pad the input string with the string of \u2018characters\u2019 until the specified length of the string has been reached. If the input string is longer than \u2018length\u2019, remove characters from the right-side to shorten it to \u2018length\u2019 characters. If the string of \u2018characters\u2019 is longer than the remaining \u2018length\u2019 needed to be filled, only pad until \u2018length\u2019 has been reached. If \u2018characters\u2019 is not specified, the default value is a single space.</p>"},{"location":"extensions/functions_string/#rpad","title":"rpad","text":"<p>Implementations: rpad(<code>input</code>, <code>length</code>, <code>characters</code>): -&gt; <code>return_type</code> </p> <li>input: The string to pad.</li> <li>length: The length of the output string.</li> <li>characters: The string of characters to use for padding.</li> <p>0. rpad(<code>varchar&lt;L1&gt;</code>, <code>i32</code>, <code>varchar&lt;L2&gt;</code>): -&gt; <code>varchar&lt;L1&gt;</code> 1. rpad(<code>string</code>, <code>i32</code>, <code>string</code>): -&gt; <code>string</code></p> <p>Right-pad the input string with the string of \u2018characters\u2019 until the specified length of the string has been reached. If the input string is longer than \u2018length\u2019, remove characters from the left-side to shorten it to \u2018length\u2019 characters. If the string of \u2018characters\u2019 is longer than the remaining \u2018length\u2019 needed to be filled, only pad until \u2018length\u2019 has been reached. If \u2018characters\u2019 is not specified, the default value is a single space.</p>"},{"location":"extensions/functions_string/#center","title":"center","text":"<p>Implementations: center(<code>input</code>, <code>length</code>, <code>character</code>, <code>option:padding</code>): -&gt; <code>return_type</code> </p> <li>input: The string to pad.</li> <li>length: The length of the output string.</li> <li>character: The character to use for padding.</li> <p>0. center(<code>varchar&lt;L1&gt;</code>, <code>i32</code>, <code>varchar&lt;L1&gt;</code>, <code>option:padding</code>): -&gt; <code>varchar&lt;L1&gt;</code> 1. center(<code>string</code>, <code>i32</code>, <code>string</code>, <code>option:padding</code>): -&gt; <code>string</code></p> <p>Center the input string by padding the sides with a single <code>character</code> until the specified <code>length</code> of the string has been reached. By default, if the <code>length</code> will be reached with an uneven number of padding, the extra padding will be applied to the right side. The side with extra padding can be controlled with the <code>padding</code> option. Behavior is undefined if the number of characters passed to the <code>character</code> argument is not 1.</p> Options: <li>padding ['RIGHT', 'LEFT'] </li>"},{"location":"extensions/functions_string/#left","title":"left","text":"<p>Implementations: left(<code>input</code>, <code>count</code>): -&gt; <code>return_type</code>  0. left(<code>varchar&lt;L1&gt;</code>, <code>i32</code>): -&gt; <code>varchar&lt;L1&gt;</code> 1. left(<code>string</code>, <code>i32</code>): -&gt; <code>string</code></p> <p>Extract <code>count</code> characters starting from the left of the string.</p>"},{"location":"extensions/functions_string/#right","title":"right","text":"<p>Implementations: right(<code>input</code>, <code>count</code>): -&gt; <code>return_type</code>  0. right(<code>varchar&lt;L1&gt;</code>, <code>i32</code>): -&gt; <code>varchar&lt;L1&gt;</code> 1. right(<code>string</code>, <code>i32</code>): -&gt; <code>string</code></p> <p>Extract <code>count</code> characters starting from the right of the string.</p>"},{"location":"extensions/functions_string/#string_split","title":"string_split","text":"<p>Implementations: string_split(<code>input</code>, <code>separator</code>): -&gt; <code>return_type</code> </p> <li>input: The input string.</li> <li>separator: A character used for splitting the string.</li> <p>0. string_split(<code>varchar&lt;L1&gt;</code>, <code>varchar&lt;L2&gt;</code>): -&gt; <code>List&lt;varchar&lt;L1&gt;&gt;</code> 1. string_split(<code>string</code>, <code>string</code>): -&gt; <code>List&lt;string&gt;</code></p> <p>Split a string into a list of strings, based on a specified <code>separator</code> character.</p>"},{"location":"extensions/functions_string/#regexp_string_split","title":"regexp_string_split","text":"<p>Implementations: regexp_string_split(<code>input</code>, <code>pattern</code>, <code>option:case_sensitivity</code>, <code>option:multiline</code>, <code>option:dotall</code>): -&gt; <code>return_type</code> </p> <li>input: The input string.</li> <li>pattern: The regular expression to search for within the input string.</li> <p>0. regexp_string_split(<code>varchar&lt;L1&gt;</code>, <code>varchar&lt;L2&gt;</code>, <code>option:case_sensitivity</code>, <code>option:multiline</code>, <code>option:dotall</code>): -&gt; <code>List&lt;varchar&lt;L1&gt;&gt;</code> 1. regexp_string_split(<code>string</code>, <code>string</code>, <code>option:case_sensitivity</code>, <code>option:multiline</code>, <code>option:dotall</code>): -&gt; <code>List&lt;string&gt;</code></p> <p>Split a string into a list of strings, based on a regular expression pattern.  The substrings matched by the pattern will be used as the separators to split the input string and will not be included in the resulting list. The regular expression pattern should follow the International Components for Unicode implementation (https://unicode-org.github.io/icu/userguide/strings/regexp.html). The <code>case_sensitivity</code> option specifies case-sensitive or case-insensitive matching. Enabling the <code>multiline</code> option will treat the input string as multiple lines. This makes the <code>^</code> and <code>$</code> characters match at the beginning and end of any line, instead of just the beginning and end of the input string. Enabling the <code>dotall</code> option makes the <code>.</code> character match line terminator characters in a string.</p> Options: <li>case_sensitivity ['CASE_SENSITIVE', 'CASE_INSENSITIVE', 'CASE_INSENSITIVE_ASCII'] </li> <li>multiline ['MULTILINE_DISABLED', 'MULTILINE_ENABLED'] </li> <li>dotall ['DOTALL_DISABLED', 'DOTALL_ENABLED'] </li>"},{"location":"extensions/functions_string/#aggregate-functions","title":"Aggregate Functions","text":""},{"location":"extensions/functions_string/#string_agg","title":"string_agg","text":"<p>Implementations: string_agg(<code>input</code>, <code>separator</code>): -&gt; <code>return_type</code> </p> <li>input: Column of string values.</li> <li>separator: Separator for concatenated strings</li> <p>0. string_agg(<code>string</code>, <code>string</code>): -&gt; <code>string</code></p> <p>Concatenates a column of string values with a separator.</p>"},{"location":"relations/basics/","title":"Basics","text":"<p>Substrait is designed to allow a user to describe arbitrarily complex data transformations.  These transformations are composed of one or more relational operations.  Relational operations are well-defined transformation operations that work by taking zero or more input datasets and transforming them into zero or more output transformations.  Substrait defines a core set of transformations, but users are also able to extend the operations with their own specialized operations.</p>"},{"location":"relations/basics/#plans","title":"Plans","text":"<p>A plan is a tree of relations.  The root of the tree is the final output of the plan.  Each node in the tree is a relational operation.  The children of a node are the inputs to the operation.  The leaves of the tree are the input datasets to the plan.</p> <p>Plans can be composed together using reference relations.  This allows for the construction of common plans that can be reused in multiple places.  If a plan has no cycles (there is only one plan or each reference relation only references later plans) then the plan will form a  DAG (Directed Acyclic Graph).</p>"},{"location":"relations/basics/#relational-operators","title":"Relational Operators","text":"<p>Each relational operation is composed of several properties. Common properties for relational operations include the following:</p> Property Description Type Emit The set of columns output from this operation and the order of those columns. Logical &amp; Physical Hints A set of optionally provided, optionally consumed information about an operation that better informs execution. These might include estimated number of input and output records, estimated record size, likely filter reduction, estimated dictionary size, etc. These can also include implementation specific pieces of execution information. Physical Constraint A set of runtime constraints around the operation, limiting its consumption based on real-world resources (CPU, memory) as well as virtual resources like number of records produced, the largest record size, etc. Physical"},{"location":"relations/basics/#relational-signatures","title":"Relational Signatures","text":"<p>In functions, function signatures are declared externally to the use of those signatures (function bindings). In the case of relational operations, signatures are declared directly in the specification. This is due to the speed of change and number of total operations. Relational operations in the specification are expected to be &lt;100 for several years with additions being infrequent. On the other hand, there is an expectation of both a much larger number of functions (1,000s) and a much higher velocity of additions.</p> <p>Each relational operation must declare the following:</p> <ul> <li>Transformation logic around properties of the data. For example, does a relational operation maintain sortedness of a field? Does an operation change the distribution of data? </li> <li>How many input relations does an operation require?</li> <li>Does the operator produce an output (by specification, we limit relational operations to a single output at this time)</li> <li>What is the schema and field ordering of an output (see emit below)?</li> </ul>"},{"location":"relations/basics/#emit-output-ordering","title":"Emit: Output Ordering","text":"<p>A relational operation uses field references to access specific fields of the input stream. Field references are always ordinal based on the order of the incoming streams. Each relational operation must declare the order of its output data. To simplify things, each relational operation can be in one of two modes: </p> <ol> <li>Direct output: The order of outputs is based on the definition declared by the relational operation.</li> <li>Remap: A listed ordering of the direct outputs. This remapping can be also used to drop columns no longer used (such as a filter field or join keys after a join). Note that remapping/exclusion can only be done at the outputs root struct. Filtering of compound values or extracting subsets must be done through other operation types (e.g. projection).</li> </ol>"},{"location":"relations/basics/#relation-properties","title":"Relation Properties","text":"<p>There are a number of predefined properties that exist in Substrait relations. These include the following.</p>"},{"location":"relations/basics/#distribution","title":"Distribution","text":"<p>When data is partitioned across multiple sibling sets, distribution describes that set of properties that apply to any one partition. This is based on a set of distribution expression properties. A distribution is declared as a set of one or more fields and a distribution type across all fields.</p> Property Description Required Distribution Fields List of fields references that describe distribution (e.g. [0,2:4,5:0:0]). The order of these references do not impact results. Required for partitioned distribution type. Disallowed for singleton distribution type. Distribution Type PARTITIONED: For a discrete tuple of values for the declared distribution fields, all records with that tuple are located in the same partition. SINGLETON: there will only be a single partition for this operation. Required"},{"location":"relations/basics/#orderedness","title":"Orderedness","text":"<p>A guarantee that data output from this operation is provided with a sort order. The sort order will be declared based on a set of sort field definitions based on the emitted output of this operation.</p> Property Description Required Sort Fields A list of fields that the data are ordered by. The list is in order of the sort. If we sort by [0,1] then this means we only consider the data for field 1 to be ordered within each discrete value of field 0. At least one required. Per - Sort Field A field reference that the data is sorted by. Required Per - Sort Direction The direction of the data. See direction options below. Required"},{"location":"relations/basics/#ordering-directions","title":"Ordering Directions","text":"Direction Descriptions Nulls Position Ascending Returns data in ascending order based on the quality function associated with the type. Nulls are included before any values. First Descending Returns data in descending order based on the quality function associated with the type. Nulls are included before any values. First Ascending Returns data in ascending order based on the quality function associated with the type. Nulls are included after any values. Last Descending Returns data in descending order based on the quality function associated with the type. Nulls are included after any values. Last Custom function identifier Returns data using a custom function that returns -1, 0, or 1 depending on the order of the data. Per Function Clustered Ensures that all equal values are coalesced (but no ordering between values is defined). E.g. for values 1,2,3,1,2,3, output could be any of the following: 1,1,2,2,3,3 or 1,1,3,3,2,2 or 2,2,1,1,3,3 or 2,2,3,3,1,1 or 3,3,1,1,2,2 or 3,3,2,2,1,1. N/A, may appear anywhere but will be coalesced. Discussion Points <ul> <li>Should read definition types be more extensible in the same way that function signatures are? Are extensible read definition types necessary if we have custom relational operators?</li> <li>How are decomposed reads expressed? For example, the Iceberg type above is for early logical planning. Once we do some operations, it may produce a list of Iceberg file reads. This is likely a secondary type of object.</li> </ul>"},{"location":"relations/embedded_relations/","title":"Embedded Relations","text":"<p>Pending.</p> <p>Embedded relations allow a Substrait producer to define a set operation that will be embedded in the plan.</p> <p>TODO: define lots of details about what interfaces, languages, formats, etc. Should reasonably be an extension of embedded user defined table functions.</p>"},{"location":"relations/logical_relations/","title":"Logical Relations","text":""},{"location":"relations/logical_relations/#read-operator","title":"Read Operator","text":"<p>The read operator is an operator that produces one output. A simple example would be the reading of a Parquet file. It is expected that many types of reads will be added over time.</p> Signature Value Inputs 0 Outputs 1 Property Maintenance N/A (no inputs) Direct Output Order Defaults to the schema of the data read after the optional projection (masked complex expression) is applied."},{"location":"relations/logical_relations/#read-properties","title":"Read Properties","text":"Property Description Required Definition The contents of the read property definition. Required Direct Schema Defines the schema of the output of the read (before any projection or emit remapping/hiding). Required Filter A boolean Substrait expression that describes a filter that must be applied to the data. The filter should be interpreted against the direct schema. Optional, defaults to none. Best Effort Filter A boolean Substrait expression that describes a filter that may be applied to the data.  The filter should be interpreted against the direct schema. Optional, defaults to none. Projection A masked complex expression describing the portions of the content that should be read Optional, defaults to all of schema Output Properties Declaration of orderedness and/or distribution properties this read produces. Optional, defaults to no properties. Properties A list of name/value pairs associated with the read. Optional, defaults to empty"},{"location":"relations/logical_relations/#read-filtering","title":"Read Filtering","text":"<p>The read relation has two different filter properties.  A filter, which must be satisfied by the operator and a best effort filter, which does not have to be satisfied.  This reflects the way that consumers are often implemented.  A consumer is often only able to fully apply a limited set of operations in the scan.  There can then be an extended set of operations which a consumer can apply in a best effort fashion.  A producer, when setting these two fields, should take care to only use expressions that the consumer is capable of handling.</p> <p>As an example, a consumer may only be able to fully apply (in the read relation) &lt;, =, and &gt; on integral types.  The consumer may be able to apply &lt;, =, and &gt; in a best effort fashion on decimal and string types.  Consider the filter expression <code>my_int &lt; 10 &amp;&amp; my_string &lt; \"x\" &amp;&amp; upper(my_string) &gt; \"B\"</code>.  In this case the <code>filter</code> should be set to <code>my_int &lt; 10</code> and the <code>best_effort_filter</code> should be set to <code>my_string &lt; \"x\"</code> and the remaining portion (<code>upper(my_string) &gt; \"B\"</code>) should be put into a filter relation.</p> <p>A filter expression must be interpreted against the direct schema before the projection expression has been applied. As a result, fields may be referenced by the filter expression which are not included in the relation\u2019s output.</p>"},{"location":"relations/logical_relations/#read-definition-types","title":"Read Definition Types","text":"Adding new Read Definition Types <p>If you have a read definition that\u2019s not covered here, see the process for adding new read definition types.</p> <p>Read definition types (like the rest of the features in Substrait) are built by the community and added to the specification.</p>"},{"location":"relations/logical_relations/#virtual-table","title":"Virtual Table","text":"<p>A virtual table is a table whose contents are embedded in the plan itself.  The table data is encoded as records consisting of literal values.</p> Property Description Required Data Required Required"},{"location":"relations/logical_relations/#named-table","title":"Named Table","text":"<p>A named table is a reference to data defined elsewhere.  For example, there may be a catalog of tables with unique names that both the producer and consumer agree on.  This catalog would provide the consumer with more information on how to retrieve the data.</p> Property Description Required Names A list of namespaced strings that, together, form the table name Required (at least one)"},{"location":"relations/logical_relations/#files-type","title":"Files Type","text":"Property Description Required Items An array of Items (path or path glob) associated with the read. Required Format per item Enumeration of available formats. Only current option is PARQUET. Required Slicing parameters per item Information to use when reading a slice of a file. Optional"},{"location":"relations/logical_relations/#slicing-files","title":"Slicing Files","text":"<p>A read operation is allowed to only read part of a file. This is convenient, for example, when distributing a read operation across several nodes. The slicing parameters are specified as byte offsets into the file.</p> <p>Many file formats consist of indivisible \u201cchunks\u201d of data (e.g. Parquet row groups). If this happens the consumer can determine which slice a particular chunk belongs to. For example, one possible approach is that a chunk should only be read if the midpoint of the chunk (dividing by 2 and rounding down) is contained within the asked-for byte range.</p> ReadRel Message <pre><code>message ReadRel {\n  RelCommon common = 1;\n  NamedStruct base_schema = 2;\n  Expression filter = 3;\n  Expression best_effort_filter = 11;\n  Expression.MaskExpression projection = 4;\n  substrait.extensions.AdvancedExtension advanced_extension = 10;\n\n  // Definition of which type of scan operation is to be performed\n  oneof read_type {\n    VirtualTable virtual_table = 5;\n    LocalFiles local_files = 6;\n    NamedTable named_table = 7;\n    ExtensionTable extension_table = 8;\n  }\n\n  // A base table. The list of string is used to represent namespacing (e.g., mydb.mytable).\n  // This assumes shared catalog between systems exchanging a message.\n  message NamedTable {\n    repeated string names = 1;\n    substrait.extensions.AdvancedExtension advanced_extension = 10;\n  }\n\n  // A table composed of literals.\n  message VirtualTable {\n    repeated Expression.Literal.Struct values = 1;\n  }\n\n  // A stub type that can be used to extend/introduce new table types outside\n  // the specification.\n  message ExtensionTable {\n    google.protobuf.Any detail = 1;\n  }\n\n  // Represents a list of files in input of a scan operation\n  message LocalFiles {\n    repeated FileOrFiles items = 1;\n    substrait.extensions.AdvancedExtension advanced_extension = 10;\n\n    // Many files consist of indivisible chunks (e.g. parquet row groups\n    // or CSV rows).  If a slice partially selects an indivisible chunk\n    // then the consumer should employ some rule to decide which slice to\n    // include the chunk in (e.g. include it in the slice that contains\n    // the midpoint of the chunk)\n    message FileOrFiles {\n      oneof path_type {\n        // A URI that can refer to either a single folder or a single file\n        string uri_path = 1;\n        // A URI where the path portion is a glob expression that can\n        // identify zero or more paths.\n        // Consumers should support the POSIX syntax.  The recursive\n        // globstar (**) may not be supported.\n        string uri_path_glob = 2;\n        // A URI that refers to a single file\n        string uri_file = 3;\n        // A URI that refers to a single folder\n        string uri_folder = 4;\n      }\n\n      // Original file format enum, superseded by the file_format oneof.\n      reserved 5;\n      reserved \"format\";\n\n      // The index of the partition this item belongs to\n      uint64 partition_index = 6;\n\n      // The start position in byte to read from this item\n      uint64 start = 7;\n\n      // The length in byte to read from this item\n      uint64 length = 8;\n\n      message ParquetReadOptions {}\n      message ArrowReadOptions {}\n      message OrcReadOptions {}\n      message DwrfReadOptions {}\n\n      // The format of the files.\n      oneof file_format {\n        ParquetReadOptions parquet = 9;\n        ArrowReadOptions arrow = 10;\n        OrcReadOptions orc = 11;\n        google.protobuf.Any extension = 12;\n        DwrfReadOptions dwrf = 13;\n      }\n    }\n  }\n\n}\n</code></pre>"},{"location":"relations/logical_relations/#filter-operation","title":"Filter Operation","text":"<p>The filter operator eliminates one or more records from the input data based on a boolean filter expression.</p> Signature Value Inputs 1 Outputs 1 Property Maintenance Orderedness, Distribution, remapped by emit Direct Output Order The field order as the input."},{"location":"relations/logical_relations/#filter-properties","title":"Filter Properties","text":"Property Description Required Input The relational input. Required Expression A boolean expression which describes which records are included/excluded. Required FilterRel Message <pre><code>message FilterRel {\n  RelCommon common = 1;\n  Rel input = 2;\n  Expression condition = 3;\n  substrait.extensions.AdvancedExtension advanced_extension = 10;\n\n}\n</code></pre>"},{"location":"relations/logical_relations/#sort-operation","title":"Sort Operation","text":"<p>The sort operator reorders a dataset based on one or more identified sort fields and a sorting function for each.</p> Signature Value Inputs 1 Outputs 1 Property Maintenance Will update orderedness property to the output of the sort operation. Distribution property only remapped based on emit. Direct Output Order The field order of the input."},{"location":"relations/logical_relations/#sort-properties","title":"Sort Properties","text":"Property Description Required Input The relational input. Required Sort Fields List of one or more fields to sort by. Uses the same properties as the orderedness property. One sort field required SortRel Message <pre><code>message SortRel {\n  RelCommon common = 1;\n  Rel input = 2;\n  repeated SortField sorts = 3;\n  substrait.extensions.AdvancedExtension advanced_extension = 10;\n\n}\n</code></pre>"},{"location":"relations/logical_relations/#project-operation","title":"Project Operation","text":"<p>The project operation will produce one or more additional expressions based on the inputs of the dataset.</p> Signature Value Inputs 1 Outputs 1 Property Maintenance Distribution maintained, mapped by emit. Orderedness: Maintained if no window operations. Extended to include projection fields if fields are direct references. If window operations are present, no orderedness is maintained. Direct Output Order The field order of the input + the list of new expressions in the order they are declared in the expressions list."},{"location":"relations/logical_relations/#project-properties","title":"Project Properties","text":"Property Description Required Input The relational input. Required Expressions List of one or more expressions to add to the input. At least one expression required ProjectRel Message <pre><code>message ProjectRel {\n  RelCommon common = 1;\n  Rel input = 2;\n  repeated Expression expressions = 3;\n  substrait.extensions.AdvancedExtension advanced_extension = 10;\n\n}\n</code></pre>"},{"location":"relations/logical_relations/#cross-product-operation","title":"Cross Product Operation","text":"<p>The cross product operation will combine two separate inputs into a single output. It pairs every record from the left input with every record of the right input.</p> Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness is empty post operation. Direct Output Order The emit order of the left input followed by the emit order of the right input."},{"location":"relations/logical_relations/#cross-product-properties","title":"Cross Product Properties","text":"Property Description Required Left Input A relational input. Required Right Input A relational input. Required CrossRel Message <pre><code>message CrossRel {\n  RelCommon common = 1;\n  Rel left = 2;\n  Rel right = 3;\n\n  substrait.extensions.AdvancedExtension advanced_extension = 10;\n\n}\n</code></pre>"},{"location":"relations/logical_relations/#join-operation","title":"Join Operation","text":"<p>The join operation will combine two separate inputs into a single output, based on a join expression. A common subtype of joins is an equality join where the join expression is constrained to a list of equality (or equality + null equality) conditions between the two inputs of the join.</p> Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness is empty post operation. Physical relations may provide better property maintenance. Direct Output Order The emit order of the left input followed by the emit order of the right input."},{"location":"relations/logical_relations/#join-properties","title":"Join Properties","text":"Property Description Required Left Input A relational input. Required Right Input A relational input. Required Join Expression A boolean condition that describes whether each record from the left set \u201cmatch\u201d the record from the right set. Field references correspond to the direct output order of the data. Required. Can be the literal True. Post-Join Filter A boolean condition to be applied to each result record after the inputs have been joined, yielding only the records that satisfied the condition. Optional Join Type One of the join types defined below. Required"},{"location":"relations/logical_relations/#join-types","title":"Join Types","text":"Type Description Inner Return records from the left side only if they match the right side. Return records from the right side only when they match the left side. For each cross input match, return a record including the data from both sides. Non-matching records are ignored. Outer Return all records from both the left and right inputs. For each cross input match, return a record including the data from both sides. For any remaining non-match records, return the record from the corresponding input along with nulls for the opposite input. Left Return all records from the left input. For each cross input match, return a record including the data from both sides. For any remaining non-matching records from the left input, return the left record along with nulls for the right input. Right Return all records from the right input. For each cross input match, return a record including the data from both sides. For any remaining non-matching records from the right input, return the right record along with nulls for the left input. Semi Returns records from the left input. These are returned only if the records have a join partner on the right side. Anti Return records from the left input. These are returned only if the records do not have a join partner on the right side. Single Returns one join partner per entry on the left input. If more than one join partner exists, there are two valid semantics. 1) Only the first match is returned. 2) The system throws an error. If there is no match between the left and right inputs, NULL is returned. JoinRel Message <pre><code>message JoinRel {\n  RelCommon common = 1;\n  Rel left = 2;\n  Rel right = 3;\n  Expression expression = 4;\n  Expression post_join_filter = 5;\n\n  JoinType type = 6;\n\n  enum JoinType {\n    JOIN_TYPE_UNSPECIFIED = 0;\n    JOIN_TYPE_INNER = 1;\n    JOIN_TYPE_OUTER = 2;\n    JOIN_TYPE_LEFT = 3;\n    JOIN_TYPE_RIGHT = 4;\n    JOIN_TYPE_SEMI = 5;\n    JOIN_TYPE_ANTI = 6;\n    // This join is useful for nested sub-queries where we need exactly one record in output (or throw exception)\n    // See Section 3.2 of https://15721.courses.cs.cmu.edu/spring2018/papers/16-optimizer2/hyperjoins-btw2017.pdf\n    JOIN_TYPE_SINGLE = 7;\n  }\n\n  substrait.extensions.AdvancedExtension advanced_extension = 10;\n\n}\n</code></pre>"},{"location":"relations/logical_relations/#set-operation","title":"Set Operation","text":"<p>The set operation encompasses several set-level operations that support combining datasets, possibly excluding records based on various types of record level matching.</p> Signature Value Inputs 2 or more Outputs 1 Property Maintenance Maintains distribution if all inputs have the same ordinal distribution. Orderedness is not maintained. Direct Output Order The field order of the inputs. All inputs must have identical field types, but field nullabilities may vary."},{"location":"relations/logical_relations/#set-properties","title":"Set Properties","text":"Property Description Required Primary Input The primary input of the dataset. Required Secondary Inputs One or more relational inputs. At least one required Set Operation Type From list below. Required"},{"location":"relations/logical_relations/#set-operation-types","title":"Set Operation Types","text":"<p>The set operation type determines both the records that are emitted and the type of the output record.</p> Property Description Output Nullability Minus (Primary) Returns all records from the primary input excluding any matching records from secondary inputs. The same as the primary input. Minus (Multiset) Returns all records from the primary input excluding any records that are included in all secondary inputs. The same as the primary input. Intersection (Primary) Returns all records from the primary input that match at least one record from any secondary inputs. If a field is nullable in the primary input and in any of the secondary inputs, it is nullable in the output. Intersection (Multiset) Returns all records from the primary input that match at least one record from all secondary inputs. If a field is required in any of the inputs, it is required in the output. Union Distinct Returns all the records from each set, removing any rows that are duplicated (within or across sets). If a field is nullable in any of the inputs, it is nullable in the output. Union All Returns all records from each set, allowing duplicates. If a field is nullable in any of the inputs, it is nullable in the output. <p>Note that for set operations, NULL matches NULL. That is <pre><code>{NULL, 1, 3} MINUS          {NULL, 2, 4} === (1), (3)\n{NULL, 1, 3} INTERSECTION   {NULL, 2, 3} === (NULL)\n{NULL, 1, 3} UNION DISTINCT {NULL, 2, 4} === (NULL), (1), (2), (3), (4)\n</code></pre></p>"},{"location":"relations/logical_relations/#output-type-derivation-examples","title":"Output Type Derivation Examples","text":"<p>Given the following inputs, where R is Required and N is Nullable: <pre><code>Input 1: (R, R, R, R, N, N, N, N)  Primary Input\nInput 2: (R, R, N, N, R, R, N, N)  Secondary Input\nInput 3: (R, N, R, N, R, N, R, N)  Secondary Input\n</code></pre></p> <p>The output type is as follows for the various operations</p> Property Output Type Minus (Primary) (R, R, R, R, N, N, N, N) Minus (Multiset) (R, R, R, R, N, N, N, N) Intersection (Primary) (R, R, R, R, R, N, N, N) Intersection (Multiset) (R, R, R, R, R, R, R, N) Union Distinct (R, N, N, N, N, N, N, N) Union All (R, N, N, N, N, N, N, N) SetRel Message <pre><code>message SetRel {\n  RelCommon common = 1;\n  // The first input is the primary input, the remaining are secondary\n  // inputs.  There must be at least two inputs.\n  repeated Rel inputs = 2;\n  SetOp op = 3;\n  substrait.extensions.AdvancedExtension advanced_extension = 10;\n\n  enum SetOp {\n    SET_OP_UNSPECIFIED = 0;\n    SET_OP_MINUS_PRIMARY = 1;\n    SET_OP_MINUS_MULTISET = 2;\n    SET_OP_INTERSECTION_PRIMARY = 3;\n    SET_OP_INTERSECTION_MULTISET = 4;\n    SET_OP_UNION_DISTINCT = 5;\n    SET_OP_UNION_ALL = 6;\n  }\n\n}\n</code></pre>"},{"location":"relations/logical_relations/#fetch-operation","title":"Fetch Operation","text":"<p>The fetch operation eliminates records outside a desired window. Typically corresponds to a fetch/offset SQL clause. Will only returns records between the start offset and the end offset.</p> Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution and orderedness. Direct Output Order Unchanged from input."},{"location":"relations/logical_relations/#fetch-properties","title":"Fetch Properties","text":"Property Description Required Input A relational input, typically with a desired orderedness property. Required Offset A non-negative integer. Declares the offset for retrieval of records. Optional, defaults to 0. Count A non-negative integer or -1. Declares the number of records that should be returned. -1 signals that ALL records should be returned. Required FetchRel Message <pre><code>message FetchRel {\n  RelCommon common = 1;\n  Rel input = 2;\n  // the offset expressed in number of records\n  int64 offset = 3;\n  // the amount of records to return\n  // use -1 to signal that ALL records should be returned\n  int64 count = 4;\n  substrait.extensions.AdvancedExtension advanced_extension = 10;\n\n}\n</code></pre>"},{"location":"relations/logical_relations/#aggregate-operation","title":"Aggregate Operation","text":"<p>The aggregate operation groups input data on one or more sets of grouping keys, calculating each measure for each combination of grouping key.</p> Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution if all distribution fields are contained in every grouping set. No orderedness guaranteed. Direct Output Order The list of distinct columns from each grouping set (ordered by their first appearance) followed by the list of measures in declaration order, followed by an <code>i32</code> describing the associated particular grouping set the value is derived from (if applicable). <p>In its simplest form, an aggregation has only measures. In this case, all records are folded into one, and a column is returned for each aggregate expression in the measures list.</p> <p>Grouping sets can be used for finer-grained control over which records are folded. Within a grouping set, two records will be folded together if and only if each expressions in the grouping set yields the same value for each. The values returned by the grouping sets will be returned as columns to the left of the columns for the aggregate expressions. If a grouping set contains no grouping expressions, all rows will be folded for that grouping set.</p> <p>It\u2019s possible to specify multiple grouping sets in a single aggregate operation. The grouping sets behave more or less independently, with each returned record belonging to one of the grouping sets. The values for the grouping expression columns that are not part of the grouping set for a particular record will be set to null. Two grouping expressions will be returned using the same column if they represent the protobuf messages describing the expressions are equal. The columns for grouping expressions that do not appear in all grouping sets will be nullable (regardless of the nullability of the type returned by the grouping expression) to accomodate the null insertion.</p> <p>To further disambiguate which record belongs to which grouping set, an aggregate relation with more than one grouping set receives an extra <code>i32</code> column on the right-hand side. The value of this field will be the zero-based index of the grouping set that yielded the record.</p> <p>If at least one grouping expression is present, the aggregation is allowed to not have any aggregate expressions. An aggregate relation is invalid if it would yield zero columns.</p>"},{"location":"relations/logical_relations/#aggregate-properties","title":"Aggregate Properties","text":"Property Description Required Input The relational input. Required Grouping Sets One or more grouping sets. Optional, required if no measures. Per Grouping Set A list of expression grouping that the aggregation measured should be calculated for. Optional. Measures A list of one or more aggregate expressions along with an optional filter. Optional, required if no grouping sets. AggregateRel Message <pre><code>message AggregateRel {\n  RelCommon common = 1;\n\n  // Input of the aggregation\n  Rel input = 2;\n\n  // A list of one or more grouping expression sets that the aggregation measures should be calculated for.\n  // Required if there are no measures.\n  repeated Grouping groupings = 3;\n\n  // A list of one or more aggregate expressions along with an optional filter.\n  // Required if there are no groupings.\n  repeated Measure measures = 4;\n\n  substrait.extensions.AdvancedExtension advanced_extension = 10;\n\n  message Grouping {\n    repeated Expression grouping_expressions = 1;\n  }\n\n  message Measure {\n    AggregateFunction measure = 1;\n\n    // An optional boolean expression that acts to filter which records are\n    // included in the measure. True means include this record for calculation\n    // within the measure.\n    // Helps to support SUM(&lt;c&gt;) FILTER(WHERE...) syntax without masking opportunities for optimization\n    Expression filter = 2;\n  }\n\n}\n</code></pre>"},{"location":"relations/logical_relations/#reference-operator","title":"Reference Operator","text":"<p>The reference operator is used to construct DAGs of operations. In a <code>Plan</code> we can have multiple Rel representing various computations with potentially multiple outputs. The <code>ReferenceRel</code> is used to express the fact that multiple <code>Rel</code> might be sharing subtrees of computation. This can be used to express arbitrary DAGs as well as represent multi-query optimizations.</p> <p>As a concrete example think about two queries <code>SELECT * FROM A JOIN B JOIN C</code> and <code>SELECT * FROM A JOIN B JOIN D</code>, We could use the <code>ReferenceRel</code> to highlight the shared <code>A JOIN B</code> between the two queries, by creating a plan with 3 <code>Rel</code>. One expressing <code>A JOIN B</code> (in position 0 in the plan), one using reference as follows: <code>ReferenceRel(0) JOIN C</code> and a third one doing <code>ReferenceRel(0) JOIN D</code>. This allows to avoid the redundancy of <code>A JOIN B</code>.</p> Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains all properties of the input Direct Output Order Maintains order"},{"location":"relations/logical_relations/#reference-properties","title":"Reference Properties","text":"Property Description Required Referred Rel A zero-indexed positional reference to a <code>Rel</code> defined within the same <code>Plan</code>. Required ReferenceRel Message <pre><code>message ReferenceRel {\n  int32 subtree_ordinal = 1;\n\n}\n</code></pre>"},{"location":"relations/logical_relations/#write-operator","title":"Write Operator","text":"<p>The write operator is an operator that consumes one input and writes it to storage. This can range from writing to a Parquet file, to INSERT/DELETE/UPDATE in a database.</p> Signature Value Inputs 1 Outputs 1 Property Maintenance Output depends on OutputMode (none, or modified records) Direct Output Order Unchanged from input"},{"location":"relations/logical_relations/#write-properties","title":"Write Properties","text":"Property Description Required Write Type Definition of which object we are operating on (e.g., a fully-qualified table name). Required CTAS Schema The names of all the columns and their type for a CREATE TABLE AS. Required only for CTAS Write Operator Which type of operation we are performing (INSERT/DELETE/UPDATE/CTAS). Required Rel Input The Rel representing which records we will be operating on (e.g., VALUES for an INSERT, or which records to DELETE, or records and after-image of their values for UPDATE). Required Output Mode For views that modify a DB it is important to control which records to \u201creturn\u201d. Common default is NO_OUTPUT where we return nothing. Alternatively, we can return MODIFIED_RECORDS, that can be further manipulated by layering more rels ontop of this WriteRel (e.g., to \u201ccount how many records were updated\u201d). This also allows to return the after-image of the change. To return before-image (or both) one can use the reference mechanisms and have multiple return values. Required for VIEW CREATE/CREATE_OR_REPLACE/ALTER"},{"location":"relations/logical_relations/#write-definition-types","title":"Write Definition Types","text":"Adding new Write Definition Types <p>If you have a write definition that\u2019s not covered here, see the process for adding new write definition types.</p> <p>Write definition types are built by the community and added to the specification.</p> WriteRel Message <pre><code>message WriteRel {\n  // Definition of which TABLE we are operating on\n  oneof write_type {\n    NamedObjectWrite named_table = 1;\n    ExtensionObject extension_table = 2;\n  }\n\n  // The schema of the table (must align with Rel input (e.g., number of leaf fields must match))\n  NamedStruct table_schema = 3;\n\n  // The type of operation to perform\n  WriteOp op = 4;\n\n  // The relation that determines the records to add/remove/modify\n  // the schema must match with table_schema. Default values must be explicitly stated\n  // in a ProjectRel at the top of the input. The match must also\n  // occur in case of DELETE to ensure multi-engine plans are unequivocal.\n  Rel input = 5;\n\n  // Output mode determines what is the output of executing this rel\n  OutputMode output = 6;\n  RelCommon common = 7;\n\n  enum WriteOp {\n    WRITE_OP_UNSPECIFIED = 0;\n    // The insert of new records in a table\n    WRITE_OP_INSERT = 1;\n    // The removal of records from a table\n    WRITE_OP_DELETE = 2;\n    // The modification of existing records within a table\n    WRITE_OP_UPDATE = 3;\n    // The Creation of a new table, and the insert of new records in the table\n    WRITE_OP_CTAS = 4;\n  }\n\n  enum OutputMode {\n    OUTPUT_MODE_UNSPECIFIED = 0;\n    // return no records at all\n    OUTPUT_MODE_NO_OUTPUT = 1;\n    // this mode makes the operator return all the record INSERTED/DELETED/UPDATED by the operator.\n    // The operator returns the AFTER-image of any change. This can be further manipulated by operators upstreams\n    // (e.g., retunring the typical \"count of modified records\").\n    // For scenarios in which the BEFORE image is required, the user must implement a spool (via references to\n    // subplans in the body of the Rel input) and return those with anounter PlanRel.relations.\n    OUTPUT_MODE_MODIFIED_RECORDS = 2;\n  }\n\n}\n</code></pre>"},{"location":"relations/logical_relations/#virtual-table_1","title":"Virtual Table","text":"Property Description Required Name The in-memory name to give the dataset. Required Pin Whether it is okay to remove this dataset from memory or it should be kept in memory. Optional, defaults to false."},{"location":"relations/logical_relations/#files-type_1","title":"Files Type","text":"Property Description Required Path A URI to write the data to. Supports the inclusion of field references that are listed as available in properties as a \u201crotation description field\u201d. Required Format Enumeration of available formats. Only current option is PARQUET. Required"},{"location":"relations/logical_relations/#ddl-data-definition-language-operator","title":"DDL (Data Definition Language) Operator","text":"<p>The operator that defines modifications of a database schema (CREATE/DROP/ALTER for TABLE and VIEWS).</p> Signature Value Inputs 1 Outputs 0 Property Maintenance N/A (no output) Direct Output Order N/A"},{"location":"relations/logical_relations/#ddl-properties","title":"DDL Properties","text":"Property Description Required Write Type Definition of which type of object we are operating on. Required Table Schema The names of all the columns and their type. Required (except for DROP operations) Table Defaults The set of default values for this table. Required (except for DROP operations) DDL Object Which type of object we are operating on (e.g., TABLE or VIEW). Required DDL Operator The operation to be performed (e.g., CREATE/ALTER/DROP). Required View Definition A Rel representing the \u201cbody\u201d of a VIEW. Required for VIEW CREATE/CREATE_OR_REPLACE/ALTER DdlRel Message <pre><code>message DdlRel {\n  // Definition of which type of object we are operating on\n  oneof write_type {\n    NamedObjectWrite named_object = 1;\n    ExtensionObject extension_object = 2;\n  }\n\n  // The columns that will be modified (representing after-image of a schema change)\n  NamedStruct table_schema = 3;\n  // The default values for the columns (representing after-image of a schema change)\n  // E.g., in case of an ALTER TABLE that changes some of the column default values, we expect\n  // the table_defaults Struct to report a full list of default values reflecting the result of applying\n  // the ALTER TABLE operator successfully\n  Expression.Literal.Struct table_defaults = 4;\n\n  // Which type of object we operate on\n  DdlObject object = 5;\n\n  // The type of operation to perform\n  DdlOp op = 6;\n\n  // The body of the CREATE VIEW\n  Rel view_definition = 7;\n  RelCommon common = 8;\n\n  enum DdlObject {\n    DDL_OBJECT_UNSPECIFIED = 0;\n    // A Table object in the system\n    DDL_OBJECT_TABLE = 1;\n    // A View object in the system\n    DDL_OBJECT_VIEW = 2;\n  }\n\n  enum DdlOp {\n    DDL_OP_UNSPECIFIED = 0;\n    // A create operation (for any object)\n    DDL_OP_CREATE = 1;\n    // A create operation if the object does not exist, or replaces it (equivalent to a DROP + CREATE) if the object already exists\n    DDL_OP_CREATE_OR_REPLACE = 2;\n    // An operation that modifies the schema (e.g., column names, types, default values) for the target object\n    DDL_OP_ALTER = 3;\n    // An operation that removes an object from the system\n    DDL_OP_DROP = 4;\n    // An operation that removes an object from the system (without throwing an exception if the object did not exist)\n    DDL_OP_DROP_IF_EXIST = 5;\n  }\n  //TODO add PK/constraints/indexes/etc..?\n\n}\n</code></pre> Discussion Points <ul> <li>How should correlated operations be handled?</li> </ul>"},{"location":"relations/physical_relations/","title":"Physical Relations","text":"<p>There is no true distinction between logical and physical operations in Substrait. By convention, certain operations are classified as physical, but all operations can be potentially used in any kind of plan. A particular set of transformations or target operators may (by convention) be considered the \u201cphysical plan\u201d but this is a characteristic of the system consuming substrait as opposed to a definition within Substrait.</p>"},{"location":"relations/physical_relations/#hash-equijoin-operator","title":"Hash Equijoin Operator","text":"<p>The hash equijoin join operator will build a hash table out of the right input based on a set of join keys. It will then probe that hash table for incoming inputs, finding matches. </p> Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness of the left set is maintained in INNER join cases, otherwise it is eliminated. Direct Output Order Same as the Join operator."},{"location":"relations/physical_relations/#hash-equijoin-properties","title":"Hash Equijoin Properties","text":"Property Description Required Left Input A relational input.(Probe-side) Required Right Input A relational input.(Build-side) Required Left Keys References to the fields to join on in the left input. Required Right Keys References to the fields to join on in the right input. Required Post Join Predicate An additional expression that can be used to reduce the output of the join operation post the equality condition. Minimizes the overhead of secondary join conditions that cannot be evaluated using the equijoin keys. Optional, defaults true. Join Type One of the join types defined in the Join operator. Required"},{"location":"relations/physical_relations/#nlj-nested-loop-join-operator","title":"NLJ (Nested Loop Join) Operator","text":"<p>The nested loop join operator does a join by holding the entire right input and then iterating over it using the left input, evaluating the join expression on the Cartesian product of all rows, only outputting rows where the expression is true. Will also include non-matching rows in the OUTER, LEFT and RIGHT operations per the join type requirements.</p> Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness is eliminated. Direct Output Order Same as the Join operator."},{"location":"relations/physical_relations/#nlj-properties","title":"NLJ Properties","text":"Property Description Required Left Input A relational input. Required Right Input A relational input. Required Join Expression A boolean condition that describes whether each record from the left set \u201cmatch\u201d the record from the right set. Optional. Defaults to true (a Cartesian join). Join Type One of the join types defined in the Join operator. Required"},{"location":"relations/physical_relations/#merge-equijoin-operator","title":"Merge Equijoin Operator","text":"<p>The merge equijoin does a join by taking advantage of two sets that are sorted on the join keys. This allows the join operation to be done in a streaming fashion.</p> Signature Value Inputs 2 Outputs 1 Property Maintenance Distribution is maintained. Orderedness is eliminated. Direct Output Order Same as the Join operator."},{"location":"relations/physical_relations/#merge-join-properties","title":"Merge Join Properties","text":"Property Description Required Left Input A relational input. Required Right Input A relational input. Required Left Keys References to the fields to join on in the left input. Required Right Keys References to the fields to join on in the right input. Reauired Post Join Predicate An additional expression that can be used to reduce the output of the join operation post the equality condition. Minimizes the overhead of secondary join conditions that cannot be evaluated using the equijoin keys. Optional, defaults true. Join Type One of the join types defined in the Join operator. Required"},{"location":"relations/physical_relations/#exchange-operator","title":"Exchange Operator","text":"<p>The exchange operator will redistribute data based on an exchange type definition. Applying this operation will lead to an output that presents the desired distribution.</p> Signature Value Inputs 1 Outputs 1 Property Maintenance Orderedness is maintained. Distribution is overwritten based on configuration. Direct Output Order Order of the input."},{"location":"relations/physical_relations/#exchange-types","title":"Exchange Types","text":"Type Description Scatter Distribute data using a system defined hashing function that considers one or more fields. For the same type of fields and same ordering of values, the same partition target should be identified for different ExchangeRels Single Bucket Define an expression that provides a single <code>i32</code> bucket number. Optionally define whether the expression will only return values within the valid number of partition counts. If not, the system should modulo the return value to determine a target partition. Multi Bucket Define an expression that provides a <code>List&lt;i32&gt;</code> of bucket numbers. Optionally define whether the expression will only return values within the valid number of partition counts. If not, the system should modulo the return value to determine a target partition. The records should be sent to all bucket numbers provided by the expression. Broadcast Send all records to all partitions. Round Robin Send records to each target in sequence. Can follow either exact or approximate behavior. Approximate will attempt to balance the number of records sent to each destination but may not exactly distribute evenly and may send batches of records to each target before moving to the next."},{"location":"relations/physical_relations/#exchange-properties","title":"Exchange Properties","text":"Property Description Required Input The relational input. Required. Distribution Type One of the distribution types defined above. Required. Partition Count The number of partitions targeted for output. Optional. If not defined, implementation system should decide the number of partitions. Note that when not defined, single or multi bucket expressions should not be constrained to count. Expression Mapping Describes a relationship between each partition ID and the destination that partition should be sent to. Optional. A partition may be sent to 0..N locations. Value can either be a URI or arbitrary value."},{"location":"relations/physical_relations/#merging-capture","title":"Merging Capture","text":"<p>A receiving operation that will merge multiple ordered streams to maintain orderedness.</p> Signature Value Inputs 1 Outputs 1 Property Maintenance Orderedness and distribution are maintained. Direct Output Order Order of the input."},{"location":"relations/physical_relations/#merging-capture-properties","title":"Merging Capture Properties","text":"Property Description Required Blocking Whether the merging should block incoming data. Blocking should be used carefully, based on whether a deadlock can be produced. Optional, defaults to false"},{"location":"relations/physical_relations/#simple-capture","title":"Simple Capture","text":"<p>A receiving operation that will merge multiple streams in an arbitrary order.</p> Signature Value Inputs 1 Outputs 1 Property Maintenance Orderness is empty after this operation. Distribution are maintained. Direct Output Order Order of the input."},{"location":"relations/physical_relations/#naive-capture-properties","title":"Naive Capture Properties","text":"Property Description Required Input The relational input. Required"},{"location":"relations/physical_relations/#top-n-operation","title":"Top-N Operation","text":"<p>The top-N operator reorders a dataset based on one or more identified sort fields as well as a sorting function. Rather than sort the entire dataset, the top-N will only maintain the total number of records required to ensure a limited output. A top-n is a combination of a logical sort and logical fetch operations.</p> Signature Value Inputs 1 Outputs 1 Property Maintenance Will update orderedness property to the output of the sort operation. Distribution property only remapped based on emit. Direct Output Order The field order of the input."},{"location":"relations/physical_relations/#top-n-properties","title":"Top-N Properties","text":"Property Description Required Input The relational input. Required Sort Fields List of one or more fields to sort by. Uses the same properties as the orderedness property. One sort field required Offset A positive integer. Declares the offset for retrieval of records. Optional, defaults to 0. Count A positive integer. Declares the number of records that should be returned. Required"},{"location":"relations/physical_relations/#hash-aggregate-operation","title":"Hash Aggregate Operation","text":"<p>The hash aggregate operation maintains a hash table for each grouping set to coalesce equivalent tuples.</p> Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution if all distribution fields are contained in every grouping set. No orderness guaranteed. Direct Output Order Same as defined by Aggregate operation."},{"location":"relations/physical_relations/#hash-aggregate-properties","title":"Hash Aggregate Properties","text":"Property Description Required Input The relational input. Required Grouping Sets One or more grouping sets. Optional, required if no measures. Per Grouping Set A list of expression grouping that the aggregation measured should be calculated for. Optional, defaults to 0. Measures A list of one or more aggregate expressions. Implementations may or may not support aggregate ordering expressions. Optional, required if no grouping sets."},{"location":"relations/physical_relations/#streaming-aggregate-operation","title":"Streaming Aggregate Operation","text":"<p>The streaming aggregate operation leverages data ordered by the grouping expressions to calculate data each grouping set tuple-by-tuple in streaming fashion. All grouping sets and orderings requested on each aggregate must be compatible to allow multiple grouping sets or aggregate orderings.</p> Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution if all distribution fields are contained in every grouping set. Maintains input ordering. Direct Output Order Same as defined by Aggregate operation."},{"location":"relations/physical_relations/#streaming-aggregate-properties","title":"Streaming Aggregate Properties","text":"Property Description Required Input The relational input. Required Grouping Sets One or more grouping sets. If multiple grouping sets are declared, sets must all be compatible with the input sortedness. Optional, required if no measures. Per Grouping Set A list of expression grouping that the aggregation measured should be calculated for. Optional, defaults to 0. Measures A list of one or more aggregate expressions. Aggregate expressions ordering requirements must be compatible with expected ordering. Optional, required if no grouping sets."},{"location":"relations/physical_relations/#consistent-partition-window-operation","title":"Consistent Partition Window Operation","text":"<p>A consistent partition window operation is a special type of project operation where every function is a window function and all of the window functions share the same sorting and partitioning. This allows for the sort and partition to be calculated once and shared between the various function evaluations.</p> Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution and ordering. Direct Output Order Same as Project operator (input followed by each window expression)."},{"location":"relations/physical_relations/#window-properties","title":"Window Properties","text":"Property Description Required Input The relational input. Required Window Functions One or more window functions. At least one required."},{"location":"relations/physical_relations/#expand-operation","title":"Expand Operation","text":"<p>The expand operation creates duplicates of input records based on the Expand Fields. Each Expand Field can be a Switching Field or an expression. Switching Fields are described below.  If an Expand Field is an expression then its value is consistent across all duplicate rows.</p> Signature Value Inputs 1 Outputs 1 Property Maintenance Distribution is maintained if all the distribution fields are consistent fields with direct references. Ordering can only be maintained down to the level of consistent fields that are kept. Direct Output Order The expand fields followed by an i32 column describing the index of the duplicate that the row is derived from."},{"location":"relations/physical_relations/#expand-properties","title":"Expand Properties","text":"Property Description Required Input The relational input. Required Direct Fields Expressions describing the output fields.  These refer to the schema of the input.  Each Direct Field must be an expression or a Switching Field Required"},{"location":"relations/physical_relations/#switching-field-properties","title":"Switching Field Properties","text":"<p>A switching field is a field whose value is different in each duplicated row.  All switching fields in an Expand Operation must have the same number of duplicates.</p> Property Description Required Duplicates List of one or more expressions.  The output will contain a row for each expression. Required"},{"location":"relations/physical_relations/#hashing-window-operation","title":"Hashing Window Operation","text":"<p>A window aggregate operation that will build hash tables for each distinct partition expression.</p> Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution. Eliminates ordering. Direct Output Order Same as Project operator (input followed by each window expression)."},{"location":"relations/physical_relations/#hashing-window-properties","title":"Hashing Window Properties","text":"Property Description Required Input The relational input. Required Window Expressions One or more window expressions. At least one required."},{"location":"relations/physical_relations/#streaming-window-operation","title":"Streaming Window Operation","text":"<p>A window aggregate operation that relies on a partition/ordering sorted input.</p> Signature Value Inputs 1 Outputs 1 Property Maintenance Maintains distribution. Eliminates ordering. Direct Output Order Same as Project operator (input followed by each window expression)."},{"location":"relations/physical_relations/#streaming-window-properties","title":"Streaming Window Properties","text":"Property Description Required Input The relational input. Required Window Expressions One or more window expressions. Must be supported by the sortedness of the input. At least one required."},{"location":"relations/user_defined_relations/","title":"User Defined Relations","text":"<p>Pending</p>"},{"location":"serialization/basics/","title":"Basics","text":"<p>Substrait is designed to be serialized into various different formats. Currently we support a binary serialization for transmission of plans between programs (e.g. IPC or network communication) and a text serialization for debugging and human readability. Other formats may be added in the future.</p> <p>These formats serialize a collection of plans. Substrait does not define how a collection of plans is to be interpreted. For example, the following scenarios are all valid uses of a collection of plans:</p> <ul> <li>A query engine receives a plan and executes it. It receives a collection of plans with a single root plan. The   top-level node of the root plan defines the output of the query. Non-root plans may be included as common subplans   which are referenced from the root plan.</li> <li>A transpiler may convert plans from one dialect to another. It could take, as input, a single root plan. Then   it could output a serialized binary containing multiple root plans. Each root plan is a representation of the   input plan in a different dialect.</li> <li>A distributed scheduler might expect 1+ root plans. Each root plan describes a different stage of computation.</li> </ul> <p>Libraries should make sure to thoroughly describe the way plan collections will be produced or consumed.</p>"},{"location":"serialization/basics/#root-plans","title":"Root plans","text":"<p>We often refer to query plans as a graph of nodes (typically a DAG unless the query is recursive). However, we encode this graph as a collection of trees with a single root tree that references other trees (which may also transitively reference other trees). Plan serializations all have some way to indicate which plan(s) are \u201croot\u201d plans. Any plan that is not a root plan and is not referenced (directly or transitively) by some root plan can safely be ignored.</p>"},{"location":"serialization/binary_serialization/","title":"Binary Serialization","text":"<p>Substrait can be serialized into a protobuf-based binary representation. The proto schema/IDL files can be found on GitHub. Proto files are place in the <code>io.substrait</code> namespace for C++/Java and the <code>Substrait.Protobuf</code> namespace for C#.</p>"},{"location":"serialization/binary_serialization/#plan","title":"Plan","text":"<p>The main top-level object used to communicate a Substrait plan using protobuf is a Plan message (see the ExtendedExpression for an alternative other top-level object). The plan message is composed of a set of data structures that minimize repetition in the serialization along with one (or more) Relation trees. </p> Plan Message <pre><code>message Plan {\n  // Substrait version of the plan. Optional up to 0.17.0, required for later\n  // versions.\n  Version version = 6;\n\n  // a list of yaml specifications this plan may depend on\n  repeated substrait.extensions.SimpleExtensionURI extension_uris = 1;\n\n  // a list of extensions this plan may depend on\n  repeated substrait.extensions.SimpleExtensionDeclaration extensions = 2;\n\n  // one or more relation trees that are associated with this plan.\n  repeated PlanRel relations = 3;\n\n  // additional extensions associated with this plan.\n  substrait.extensions.AdvancedExtension advanced_extensions = 4;\n\n  // A list of com.google.Any entities that this plan may use. Can be used to\n  // warn if some embedded message types are unknown. Note that this list may\n  // include message types that are ignorable (optimizations) or that are\n  // unused. In many cases, a consumer may be able to work with a plan even if\n  // one or more message types defined here are unknown.\n  repeated string expected_type_urls = 5;\n\n}\n</code></pre>"},{"location":"serialization/binary_serialization/#extensions","title":"Extensions","text":"<p>Protobuf supports both simple and advanced extensions. Simple extensions are declared at the plan level and advanced extensions are declared at multiple levels of messages within the plan.</p>"},{"location":"serialization/binary_serialization/#simple-extensions","title":"Simple Extensions","text":"<p>For simple extensions, a plan references the URIs associated with the simple extensions to provide additional plan capabilities. These URIs will list additional relevant information for the plan. </p> <p>Simple extensions within a plan are split into three components: an extension URI, an extension declaration and a number of references.</p> <ul> <li>Extension URI: A unique identifier for the extension pointing to a YAML document specifying one or more specific extensions. Declares an anchor that can be used in extension declarations.  </li> <li>Extension Declaration: A specific extension within a single YAML document. The declaration combines a reference to the associated Extension URI along with a unique key identifying the specific item within that YAML document (see Function Signature Compound Names). It also defines a declaration anchor. The anchor is a plan-specific unique value that the producer creates as a key to be referenced elsewhere.</li> <li>Extension Reference: A specific instance or use of an extension declaration within the plan body.</li> </ul> <p>Extension URIs and declarations are encapsulated in the top level of the plan. Extension declarations are then referenced throughout the body of the plan itself. The exact structure of these references will depend on the extension point being used, but they will always include the extension\u2019s anchor (or key). For example, all scalar function expressions contain references to an extension declaration which defines the semantics of the function.</p> Simple Extension URI <pre><code>message SimpleExtensionURI {\n  // A surrogate key used in the context of a single plan used to reference the\n  // URI associated with an extension.\n  uint32 extension_uri_anchor = 1;\n\n  // The URI where this extension YAML can be retrieved. This is the \"namespace\"\n  // of this extension.\n  string uri = 2;\n\n}\n</code></pre> <p>Once the YAML file URI anchor is defined, the anchor will be referenced by zero or more <code>SimpleExtensionDefinition</code>s. For each simple extension definition, an anchor is defined for that specific extension entity. This anchor is then referenced to within lower-level primitives (functions, etc.) to reference that specific extension. Message properties are named <code>*_anchor</code> where the anchor is defined and <code>*_reference</code> when referencing the anchor. For example <code>function_anchor</code> and <code>function_reference</code>.</p> Simple Extension Declaration <pre><code>message SimpleExtensionDeclaration {\n  oneof mapping_type {\n    ExtensionType extension_type = 1;\n    ExtensionTypeVariation extension_type_variation = 2;\n    ExtensionFunction extension_function = 3;\n  }\n\n  // Describes a Type\n  message ExtensionType {\n    // references the extension_uri_anchor defined for a specific extension URI.\n    uint32 extension_uri_reference = 1;\n\n    // A surrogate key used in the context of a single plan to reference a\n    // specific extension type\n    uint32 type_anchor = 2;\n\n    // the name of the type in the defined extension YAML.\n    string name = 3;\n  }\n\n  message ExtensionTypeVariation {\n    // references the extension_uri_anchor defined for a specific extension URI.\n    uint32 extension_uri_reference = 1;\n\n    // A surrogate key used in the context of a single plan to reference a\n    // specific type variation\n    uint32 type_variation_anchor = 2;\n\n    // the name of the type in the defined extension YAML.\n    string name = 3;\n  }\n\n  message ExtensionFunction {\n    // references the extension_uri_anchor defined for a specific extension URI.\n    uint32 extension_uri_reference = 1;\n\n    // A surrogate key used in the context of a single plan to reference a\n    // specific function\n    uint32 function_anchor = 2;\n\n    // A function signature compound name\n    string name = 3;\n  }\n\n}\n</code></pre> <p>Note</p> <p>Anchors only have meaning within a single plan and exist simply to reduce plan size. They are not some form of global identifier. Different plans may use different anchors for the same specific functions, types, type variations, etc.</p> <p>Note</p> <p>It is valid for a plan to include <code>SimpleExtensionURI</code>s and/or <code>SimpleExtensionDeclaration</code>s that are not referenced directly.</p>"},{"location":"serialization/binary_serialization/#advanced-extensions","title":"Advanced Extensions","text":"<p>Substrait protobuf exposes a special object in multiple places in the representation to expose extension capabilities. Extensions are done via this object. Extensions are separated into main concepts: </p> Advanced Extension Type Description Optimization A change to the plan that may help some consumers work more efficiently with the plan. These properties should be propagated through plan pipelines where possible but do not impact the meaning of the plan. A consumer can safely ignore these properties. Enhancement A change to the plan that functionally changes the behavior of the plan. Use these sparingly as they will impact plan interoperability. Advanced Extension Protobuf <pre><code>message AdvancedExtension {\n  // An optimization is helpful information that don't influence semantics. May\n  // be ignored by a consumer.\n  repeated google.protobuf.Any optimization = 1;\n\n  // An enhancement alter semantics. Cannot be ignored by a consumer.\n  google.protobuf.Any enhancement = 2;\n\n}\n</code></pre>"},{"location":"serialization/binary_serialization/#capabilities","title":"Capabilities","text":"<p>When two systems exchanging Substrait plans want to understand each other\u2019s capabilities, they may exchange a <code>Capabilities</code> message. The capabilities message provides information on the set of simple and advanced extensions that the system supports.</p> Capabilities Message <pre><code>message Capabilities {\n  // List of Substrait versions this system supports\n  repeated string substrait_versions = 1;\n\n  // list of com.google.Any message types this system supports for advanced\n  // extensions.\n  repeated string advanced_extension_type_urls = 2;\n\n  // list of simple extensions this system supports.\n  repeated SimpleExtension simple_extensions = 3;\n\n  message SimpleExtension {\n    string uri = 1;\n    repeated string function_keys = 2;\n    repeated string type_keys = 3;\n    repeated string type_variation_keys = 4;\n  }\n\n}\n</code></pre>"},{"location":"serialization/binary_serialization/#protobuf-rationale","title":"Protobuf Rationale","text":"<p>The binary format of Substrait is designed to be easy to work with in many languages. A key requirement is that someone can take the binary format IDL and use standard tools to build a set of primitives that are easy to work with in any of a number of languages. This allows communities to build and use Substrait using only a binary IDL and the specification (and allows the Substrait project to avoid being required to build libraries for each language to work with the specification).</p> <p>There are several binary IDLs that exist today. The key requirements for Substrait are the following:</p> <ul> <li>Strongly typed IDL schema language</li> <li>High-quality well-supported and idiomatic bindings/compilers for key languages (Python, Javascript, C++, Go, Rust, Java)</li> <li>Compact serial representation</li> </ul> <p>The primary formats that exist that roughly qualify under these requirements include: Protobuf, Thrift, Flatbuf, Avro, Cap\u2019N\u2019Proto. Protobuf was chosen due to its clean typing system and large number of high quality language bindings. </p> <p>The binary serialization IDLs can be found on GitHub and are sampled throughout the documentation.</p>"},{"location":"serialization/text_serialization/","title":"Text Serialization","text":"<p>To maximize the new user experience, it is important for Substrait to have a text representation of plans. This allows people to experiment with basic tooling. Building simple CLI tools that do things like SQL &gt; Plan and Plan &gt; SQL or REPL plan construction can all be done relatively straightforwardly with a text representation.</p> <p>The recommended text serialization format is JSON. Since the text format is not designed for performance, the format can be produced to maximize readability. This also allows nice symmetry between the construction of plans and the configuration of various extensions such as function signatures and user defined types.</p> <p>To ensure the JSON is valid, the object will be defined using the OpenApi 3.1 specification. This not only allows strong validation, the OpenApi specification enables code generators to be easily used to produce plans in many languages.</p> <p>While JSON will be used for much of the plan serialization, Substrait uses a custom simplistic grammar for record level expressions. While one can construct an equation such as <code>(10 + 5)/2</code> using a tree of function and literal objects, it is much more human-readable to consume a plan when the information is written similarly to the way one typically consumes scalar expressions. This grammar will be maintained in an ANTLR grammar (targetable to multiple programming languages) and is also planned to be supported via JSON schema definition format tag so that the grammar can be validated as part of the schema validation.</p>"},{"location":"spec/extending/","title":"Extending","text":"<p>Substrait is a community project and requires consensus about new additions to the specification in order to maintain consistency.  The best way to get consensus is to discuss ideas.  The main ways to communicate are:</p> <ul> <li>Substrait Mailing List</li> <li>Substrait Slack</li> <li>Community Meeting</li> </ul>"},{"location":"spec/extending/#minor-changes","title":"Minor changes","text":"<p>Simple changes like typos and bug fixes do not require as much effort.  File an issue or send a PR and we can discuss it there.</p>"},{"location":"spec/extending/#complex-changes","title":"Complex changes","text":"<p>For complex features it is useful to discuss the change first.  It will be useful to gather some background information to help get everyone on the same page.</p>"},{"location":"spec/extending/#outline-the-issue","title":"Outline the issue","text":""},{"location":"spec/extending/#language","title":"Language","text":"<p>Every engine has its own terminology.  Every Spark user probably knows what an \u201cattribute\u201d is.  Velox users will know what a \u201cRowVector\u201d means.  Etc.  However, Substrait is used by people that come from a variety of backgrounds and you should generally assume that its users do not know anything about your own implementation.  As a result, all PRs and discussion should endeavor to use Substrait terminology wherever possible.</p>"},{"location":"spec/extending/#motivation","title":"Motivation","text":"<p>What problems does this relation solve?  If it is a more logical relation then how does it allow users to express new capabilities?  If it is more of an internal relation then how does it map to existing logical relations?  How is it different than other existing relations?  Why do we need this?</p>"},{"location":"spec/extending/#examples","title":"Examples","text":"<p>Provide example input and output for the relation.  Show example plans.  Try and motivate your examples, as best as possible, with something that looks like a real world problem.  These will go a long ways towards helping others understand the purpose of a relation.</p>"},{"location":"spec/extending/#alternatives","title":"Alternatives","text":"<p>Discuss what alternatives are out there.  Are there other ways to achieve similar results?  Do some systems handle this problem differently?</p>"},{"location":"spec/extending/#survey-existing-implementation","title":"Survey existing implementation","text":"<p>It\u2019s unlikely that this is the first time that this has been done.  Figuring out</p>"},{"location":"spec/extending/#prototype-the-feature","title":"Prototype the feature","text":"<p>Novel approaches should be implemented as an extension first.  </p>"},{"location":"spec/extending/#substrait-design-principles","title":"Substrait design principles","text":"<p>Substrait is designed around interoperability so a feature only used by a single system may not be accepted.  But don\u2019t dispair!  Substrait has a highly developed extension system for this express purpose.</p>"},{"location":"spec/extending/#you-dont-have-to-do-it-alone","title":"You don\u2019t have to do it alone","text":"<p>If you are hoping to add a feature and these criteria seem intimidating then feel free to start a mailing list discussion before you have all the information and ask for help.  Investigating other implementations, in particular, is something that can be quite difficult to do on your own.</p>"},{"location":"spec/specification/","title":"Specification","text":""},{"location":"spec/specification/#status","title":"Status","text":"<p>The specification has passed the initial design phase and is now in the final stages of being fleshed out.  The community is encouraged to identify (and address) any perceived gaps in functionality using GitHub issues and PRs.  Once all of the planned implementations have been completed all deprecated fields will be eliminated and version 1.0 will be released.</p>"},{"location":"spec/specification/#components-complete","title":"Components (Complete)","text":"Section Description Simple Types A way to describe the set of basic types that will be operated on within a plan. Only includes simple types such as integers and doubles (nothing configurable or compound). Compound Types Expression of types that go beyond simple scalar values. Key concepts here include: configurable types such as fixed length and numeric types as well as compound types such as structs, maps, lists, etc. Type Variations Physical variations to base types. User Defined Types Extensions that can be defined for specific IR producers/consumers. Field References Expressions to identify which portions of a record should be operated on. Scalar Functions Description of how functions are specified. Concepts include arguments, variadic functions, output type derivation, etc. Scalar Function List A list of well-known canonical functions in YAML format. Specialized Record Expressions Specialized expression types that are more naturally expressed outside the function paradigm. Examples include items such as if/then/else and switch statements. Aggregate Functions Functions that are expressed in aggregation operations. Examples include things such as SUM, COUNT, etc. Operations take many records and collapse them into a single (possibly compound) value. Window Functions Functions that relate a record to a set of encompassing records. Examples in SQL include RANK, NTILE, etc. User Defined Functions Reusable named functions that are built beyond the core specification. Implementations are typically registered thorough external means (drop a file in a directory, send a special command with implementation, etc.) Embedded Functions Functions implementations embedded directly within the plan. Frequently used in data science workflows where business logic is interspersed with standard operations. Relation Basics Basic concepts around relational algebra, record emit and properties. Logical Relations Common relational operations used in compute plans including project, join, aggregation, etc. Text Serialization A human producible &amp; consumable representation of the plan specification. Binary Serialization A high performance &amp; compact binary representation of the plan specification."},{"location":"spec/specification/#components-designed-but-not-implemented","title":"Components (Designed but not Implemented)","text":"Section Description Table Functions Functions that convert one or more values from an input record into 0..N output records. Example include operations such as explode, pos-explode, etc. User Defined Relations Installed and reusable relational operations customized to a particular platform. Embedded Relations Relational operations where plans contain the \u201cmachine code\u201d to directly execute the necessary operations. Physical Relations Specific execution sub-variations of common relational operations that describe have multiple unique physical variants associated with a single logical operation. Examples include hash join, merge join, nested loop join, etc."},{"location":"spec/technology_principles/","title":"Technology Principles","text":"<ul> <li>Provide a good suite of well-specified common functionality in databases and data science applications.</li> <li>Make it easy for users to privately or publicly extend the representation to support specialized/custom operations.</li> <li>Produce something that is language agnostic and requires minimal work to start developing against in a new language.</li> <li>Drive towards a common format that avoids specialization for single favorite producer or consumer.</li> <li>Establish clear delineation between specifications that MUST be respected to and those that can be optionally ignored.</li> <li>Establish a forgiving compatibility approach and versioning scheme that supports cross-version compatibility in maximum number of cases.</li> <li>Minimize the need for consumer intelligence by excluding concepts like overloading, type coercion, implicit casting, field name handling, etc. (Note: this is weak and should be better stated.)</li> <li>Decomposability/severability: A particular producer or consumer should be able to produce or consume only a subset of the specification and interact well with any other Substrait system as long the specific operations requested fit within the subset of specification supported by the counter system.</li> </ul>"},{"location":"spec/versioning/","title":"Versioning","text":"<p>As an interface specification, the goal of Substrait is to reach a point where (breaking) changes will never need to happen again, or at least be few and far between. By analogy, Apache Arrow\u2019s in-memory format specification has stayed functionally constant, despite many major library versions being released. However, we\u2019re not there yet. When we believe that we\u2019ve reached this point, we will signal this by releasing version 1.0.0. Until then, we will remain in the 0.x.x version regime.</p> <p>Despite this, we strive to maintain backward compatibility for both the binary representation and the text representation by means of deprecation. When a breaking change cannot be reasonably avoided, we may remove previously deprecated fields. All deprecated fields will be removed for the 1.0.0 release.</p> <p>Substrait uses semantic versioning for its version numbers, with the addition that, during 0.x.y, we increment the x digit for breaking changes and new features, and the y digit for fixes and other nonfunctional changes. The release process is currently automated and makes a new release every week, provided something has changed on the main branch since the previous release. This release cadence will likely be slowed down as stability increases over time. Conventional commits are used to distinguish between breaking changes, new features, and fixes, and GitHub actions are used to verify that there are indeed no breaking protobuf changes in a commit, unless the commit message states this.</p>"},{"location":"tools/producer_tools/","title":"Producer Tools","text":""},{"location":"tools/producer_tools/#isthmus","title":"Isthmus","text":"<p>Isthmus is an application that serializes SQL to Substrait Protobuf  via the Calcite SQL compiler.</p>"},{"location":"tools/substrait_validator/","title":"Substrait Validator","text":"<p>The Substrait Validator is a tool  used to validate substrait plans as well as print diagnostics information regarding the plan validity.</p>"},{"location":"tools/third_party_tools/","title":"Third Party Tools","text":""},{"location":"tools/third_party_tools/#substrait-tools","title":"Substrait-tools","text":"<p>The substrait-tools python package provides  a command line interface for producing/consuming substrait plans by leveraging the APIs from different producers and consumers.</p>"},{"location":"tools/third_party_tools/#substrait-fiddle","title":"Substrait Fiddle","text":"<p>Substrait Fiddle is an online tool to share, debug, and prototype Substrait plans.</p> <p>The Substrait Fiddle Source is available allowing it to be run in any environment.</p>"},{"location":"tutorial/sql_to_substrait/","title":"SQL to Substrait tutorial","text":"<p>This is an introductory tutorial to learn the basics of Substrait for readers already familiar with SQL. We will look at how to construct a Substrait plan from an example query.</p> <p>We\u2019ll present the Substrait in JSON form to make it relatively readable to newcomers. Typically Substrait is exchanged as a protobuf message, but for debugging purposes it is often helpful to look at a serialized form. Plus, it\u2019s not uncommon for unit tests to represent plans as JSON strings. So if you are developing with Substrait, it\u2019s useful to have experience reading them.</p> <p>Note</p> <p>Substrait is currently only defined with Protobuf. The JSON provided here is the Protobuf JSON output, but it is not the official Substrait text format. Eventually, Substrait will define it\u2019s own human-readable text format, but for now this tutorial will make due with what Protobuf provides.</p> <p>Substrait is designed to communicate plans (mostly logical plans). Those plans contain types, schemas, expressions, extensions, and relations. We\u2019ll look at  them in that order, going from simplest to most complex until we can construct full plans.</p> <p></p> <p>This tutorial won\u2019t cover all the details of each piece, but it will give you an idea of how they connect together. For a detailed reference of each individual  field, the best place to look is reading the  protobuf definitions. They represent the source-of-truth of the spec and are well-commented to address ambiguities.</p>"},{"location":"tutorial/sql_to_substrait/#problem-set-up","title":"Problem Set up","text":"<p>To learn Substrait, we\u2019ll build up to a specific query. We\u2019ll be using the tables:</p> <pre><code>CREATE TABLE orders (\n  product_id: i64 NOT NULL,\n  quantity: i32 NOT NULL,\n  order_date: date NOT NULL,\n  price: decimal(10, 2)\n);\n</code></pre> <pre><code>CREATE TABLE products (\n  product_id: i64 NOT NULL,\n  categories: list&lt;string NOT NULL&gt; NOT NULL,\n  details: struct&lt;manufacturer: string, year_created: int32&gt;,\n  product_name: string\n);\n</code></pre> <p>This <code>orders</code> table represents events where products were sold, recording how many (<code>quantity</code>) and at what price (<code>price</code>). The <code>products</code> table provides details for each product, with <code>product_id</code> as the primary key.</p> <p>And we\u2019ll try to create the query:</p> <pre><code>SELECT\n  product_name,\n  product_id,\n  sum(quantity * price) as sales\nFROM\n  orders\nINNER JOIN\n  products\nON\n  orders.product_id = products.product_id\nWHERE\n  -- categories does not contain \"Computers\"\n  INDEX_IN(\"Computers\", categories) IS NULL\nGROUP BY\n  product_name,\n  product_id\n</code></pre> <p>The query asked the question: For products that aren\u2019t in the <code>\"Computer\"</code> category, how much has each product generated in sales?</p> <p>However, Substrait doesn\u2019t correspond to SQL as much as it does to logical plans. So to be less ambiguous, the plan we are aiming for looks like:</p> <pre><code>|-+ Aggregate({sales = sum(quantity_price)}, group_by=(product_name, product_id))\n  |-+ InnerJoin(on=orders.product_id = products.product_id)\n    |- ReadTable(orders)\n    |-+ Filter(INDEX_IN(\"Computers\", categories) IS NULL)\n      |- ReadTable(products)\n</code></pre>"},{"location":"tutorial/sql_to_substrait/#types-and-schemas","title":"Types and Schemas","text":"<p>As part of the Substrait plan, we\u2019ll need to embed the data types of the input tables. In Substrait, each type is a distinct message, which at a minimum  contains a field for nullability. For example, a string field looks like:</p> <pre><code>{\n  \"string\": {\n    \"nullability\": \"NULLABILITY_NULLABLE\"\n  }\n}\n</code></pre> <p>Nullability is an enum not a boolean, since Substrait allows  <code>NULLABILITY_UNSPECIFIED</code> as an option, in addition to <code>NULLABILITY_NULLABLE</code> (nullable) and <code>NULLABILITY_REQUIRED</code> (not nullable).</p> <p>Other types such as <code>VarChar</code> and <code>Decimal</code> have other parameters. For example, our <code>orders.price</code> column will be represented as:</p> <pre><code>{\n  \"decimal\": {\n    \"precision\": 10,\n    \"scale\": 2,\n    \"nullability\": \"NULLABILITY_NULLABLE\"\n  }\n}\n</code></pre> <p>Finally, there are nested compound types such as structs and list types that  have other types as parameters. For example, the <code>products.categories</code> column is a list of strings, so can be represented as:</p> <pre><code>{\n  \"list\": {\n    \"type\": {\n      \"string\": {\n        \"nullability\": \"NULLABILITY_REQUIRED\"\n      }\n    },\n    \"nullability\": \"NULLABILITY_REQUIRED\"\n  }\n}\n</code></pre> <p>To know what parameters each type can take, refer to the Protobuf definitions in type.proto.</p> <p>Schemas of tables can be represented with a <code>NamedStruct</code> message, which is the combination of a struct type containing all the columns and a list of column names. For the <code>orders</code> table, this will look like:</p> <pre><code>{\n  \"names\": [\n    \"product_id\",\n    \"quantity\",\n    \"order_date\",\n    \"price\"\n  ],\n  \"struct\": {\n    \"types\": [\n      {\n        \"i64\": {\n          \"nullability\": \"NULLABILITY_REQUIRED\"\n        }\n      },\n      {\n        \"i32\": {\n          \"nullability\": \"NULLABILITY_REQUIRED\"\n        }\n      },\n      {\n        \"date\": {\n          \"nullability\": \"NULLABILITY_REQUIRED\"\n        }\n      },\n      {\n        \"decimal\": {\n          \"precision\": 10,\n          \"scale\": 2,\n          \"nullability\": \"NULLABILITY_NULLABLE\"\n        }\n      }\n    ],\n    \"nullability\": \"NULLABILITY_REQUIRED\"\n  }\n}\n</code></pre> <p>Here, <code>names</code> is the names of all fields. In nested schemas, this includes the names of subfields in depth-first order. So for the <code>products</code> table, the  <code>details</code> struct field will be included as well as the two subfields (<code>manufacturer</code> and <code>year_created</code>) right after. And because it\u2019s depth first, these subfields appear before <code>product_name</code>. The full schema looks like:</p> <pre><code>{\n  \"names\": [\n    \"product_id\",\n    \"categories\",\n    \"details\",\n    \"manufacturer\",\n    \"year_created\",\n    \"product_name\"\n  ],\n  \"struct\": {\n    \"types\": [\n      {\n        \"i64\": {\n          \"nullability\": \"NULLABILITY_REQUIRED\"\n        }\n      },\n      {\n        \"list\": {\n          \"type\": {\n            \"string\": {\n              \"nullability\": \"NULLABILITY_REQUIRED\"\n            }\n          },\n          \"nullability\": \"NULLABILITY_REQUIRED\"\n        }\n      },\n      {\n        \"struct\": {\n          \"types\": [\n            {\n              \"string\": {\n                \"nullability\": \"NULLABILITY_NULLABLE\"\n              },\n              \"i32\": {\n                \"nullability\": \"NULLABILITY_NULLABLE\"\n              }\n            }\n          ],\n          \"nullability\": \"NULLABILITY_NULLABLE\"\n        }\n      },\n      {\n        \"string\": {\n          \"nullability\": \"NULLABILITY_NULLABLE\"\n        }\n      }\n    ],\n    \"nullability\": \"NULLABILITY_REQUIRED\"\n  }\n}\n</code></pre>"},{"location":"tutorial/sql_to_substrait/#expressions","title":"Expressions","text":"<p>The next basic building block we will need is expressions. Expressions can be one of several things, including:</p> <ul> <li>Field references</li> <li>Literal values</li> <li>Functions</li> <li>Subqueries</li> <li>Window Functions</li> </ul> <p>Since some expressions such as functions can contain other expressions, expressions can be represented as a tree. Literal values and field references typically are the leaf nodes.</p> <p>For the expression <code>INDEX_IN(categories, \"Computers\") IS NULL</code>, we have a  field reference <code>categories</code>, a literal string <code>\"Computers\"</code>, and two functions\u2014 <code>INDEX_IN</code> and <code>IS NULL</code>.</p> <p></p> <p>The field reference for <code>categories</code> is represented by:</p> <pre><code>{\n  \"selection\": {\n    \"directReference\": {\n      \"structField\": {\n        \"field\": 1\n      }\n    },\n    \"rootReference\": {}\n  }\n}\n</code></pre> <p>Whereas SQL references field by names, Substrait always references fields  numerically. This means that a Substrait expression only makes sense relative to a certain schema. As we\u2019ll see later when we discuss relations, for a filter relation this will be relative to the input schema, so the <code>1</code> here is referring  to the second field of <code>products</code>.</p> <p>Note</p> <p>Protobuf may not serialize fields with integer type and value 0, since 0 is the default. So if you instead saw <code>\"structField\": {}</code>, know that is is equivalent to  <code>\"structField\": { \"field\": 0 }</code>.</p> <p><code>\"Computers\"</code> will be translated to a literal expression:</p> <pre><code>{\n  \"literal\": {\n    \"string\": \"Computers\"\n  }\n}\n</code></pre> <p>Both <code>IS NULL</code> and <code>INDEX_IN</code> will be scalar function expressions. Available  functions in Substrait are defined in extension YAML files contained in  https://github.com/substrait-io/substrait/tree/main/extensions. Additional extensions may be created elsewhere. <code>IS NULL</code> is defined as a <code>is_null</code> function in  functions_comparison.yaml and <code>INDEX_IN</code> is defined as <code>index_in</code> function in functions_set.yaml.</p> <p>First, the expression for <code>INDEX_IN(\"Computers\", categories)</code> is:</p> <pre><code>{\n  \"scalarFunction\": {\n    \"functionReference\": 1,\n    \"outputType\": {\n      \"i64\": {\n        \"nullability\": \"NULLABILITY_NULLABLE\"\n      }\n    },\n    \"arguments\": [\n      {\n        \"value\": {\n          \"literal\": {\n            \"string\": \"Computers\"\n          }\n        }\n      },\n      {\n        \"value\": {\n          \"selection\": {\n            \"directReference\": {\n              \"structField\": {\n                \"field\": 1\n              }\n            },\n            \"rootReference\": {}\n          }\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p><code>functionReference</code> will be explained later in the plans section. For now, understand that it\u2019s a ID that corresponds to an entry in a list of function definitions that we will create later.</p> <p><code>outputType</code> defines the type the function outputs. We know this is a nullable <code>i64</code> type since that is what the function definition declares in the YAML file.</p> <p><code>arguments</code> defines the arguments being passed into the function, which are all done positionally based on the function definition in the YAML file. The two  arguments will be familiar as the literal and the field reference we constructed earlier.</p> <p>To create the final expression, we just need to wrap this in another scalar function expression for <code>IS NULL</code>.</p> <pre><code>{\n  \"scalarFunction\": {\n    \"functionReference\": 2,\n    \"outputType\": {\n      \"bool\": {\n        \"nullability\": \"NULLABILITY_REQUIRED\"\n      }\n    },\n    \"arguments\": [\n      {\n        \"value\": {\n          \"scalarFunction\": {\n            \"functionReference\": 1,\n            \"outputType\": {\n              \"i64\": {\n                \"nullability\": \"NULLABILITY_NULLABLE\"\n              }\n            },\n            \"arguments\": [\n              {\n                \"value\": {\n                  \"literal\": {\n                    \"string\": \"Computers\"\n                  }\n                }\n              },\n              {\n                \"value\": {\n                  \"selection\": {\n                    \"directReference\": {\n                      \"structField\": {\n                        \"field\": 1\n                      }\n                    },\n                    \"rootReference\": {}\n                  }\n                }\n              }\n            ]\n          }\n        }\n      }\n    ]\n  }\n}\n</code></pre> <p>To see what other types of expressions are available and what fields they take, see the <code>Expression</code> proto definition in  algebra.proto.</p>"},{"location":"tutorial/sql_to_substrait/#relations","title":"Relations","text":"<p>In most SQL engines, a logical or physical plan is represented as a tree of  nodes, such as filter, project, scan, or join. The left diagram below may be a  familiar representation of our plan, where nodes feed data into each other moving from left to right. In Substrait, each of these nodes is a Relation.</p> <p></p> <p>A relation that takes another relation as input will contain (or refer to) that relation. This is usually a field called <code>input</code>, but sometimes different names are used in relations that take multiple inputs. For example, join relations take two inputs, with field names <code>left</code> and <code>right</code>. In JSON, the rough  layout for the relations in our plan will look like:</p> <pre><code>{\n    \"aggregate\": {\n        \"input\": {\n            \"join\": {\n                \"left\": {\n                    \"filter\": {\n                        \"input\": {\n                            \"read\": {\n                                ...\n                            }\n                        },\n                        ...\n                    }\n                },\n                \"right\": {\n                    \"read\": {\n                        ...\n                    }\n                },\n                ...\n            }\n        },\n        ...\n    }\n}\n</code></pre> <p>For our plan, we need to define the read relations for each table, a filter  relation to exclude the <code>\"Computer\"</code> category from the <code>products</code> table, a join relation to perform the inner join, and finally an aggregate relation to compute the total sales.</p> <p>The read relations are composed of a <code>baseSchema</code> and a <code>namedTable</code> field. The type of read is a named table, so the <code>namedTable</code> field is present with  <code>names</code> containing the list of name segments (<code>my_database.my_table</code>). Other types of reads include virtual tables (a table of literal values embedded in the plan) and a list of files. See Read Definition Types for more details. The <code>baseSchema</code> is the schemas we defined earlier and <code>namedTable</code> are just the names of the tables. So for reading the <code>orders</code> table, the relation looks like:</p> <pre><code>{\n  \"read\": {\n    \"namedTable\": {\n      \"names\": [\n        \"orders\"\n      ]\n    },\n    \"baseSchema\": {\n      \"names\": [\n        \"product_id\",\n        \"quantity\",\n        \"order_date\",\n        \"price\"\n      ],\n      \"struct\": {\n        \"types\": [\n          {\n            \"i64\": {\n              \"nullability\": \"NULLABILITY_REQUIRED\"\n            }\n          },\n          {\n            \"i32\": {\n              \"nullability\": \"NULLABILITY_REQUIRED\"\n            }\n          },\n          {\n            \"date\": {\n              \"nullability\": \"NULLABILITY_REQUIRED\"\n            }\n          },\n          {\n            \"decimal\": {\n              \"scale\": 10,\n              \"precision\": 2,\n              \"nullability\": \"NULLABILITY_NULLABLE\"\n            }\n          }\n        ],\n        \"nullability\": \"NULLABILITY_REQUIRED\"\n      }\n    }\n  }\n}\n</code></pre> <p>Read relations are leaf nodes. Leaf nodes don\u2019t depend on any other node for data and usually represent a source of data in our plan. Leaf nodes are then typically used as input for other nodes that manipulate the data. For example, our filter node will take the <code>products</code> read relation as an input.</p> <p>The filter node will also take a <code>condition</code> field, which will just be the expression we constructed earlier.</p> <pre><code>{\n  \"filter\": {\n    \"input\": {\n      \"read\": { ... }\n    },\n    \"condition\": {\n      \"scalarFunction\": {\n        \"functionReference\": 2,\n        \"outputType\": {\n          \"bool\": {\n            \"nullability\": \"NULLABILITY_REQUIRED\"\n          }\n        },\n        \"arguments\": [\n          {\n            \"value\": {\n              \"scalarFunction\": {\n                \"functionReference\": 1,\n                \"outputType\": {\n                  \"i64\": {\n                    \"nullability\": \"NULLABILITY_NULLABLE\"\n                  }\n                },\n                \"arguments\": [\n                  {\n                    \"value\": {\n                      \"literal\": {\n                        \"string\": \"Computers\"\n                      }\n                    }\n                  },\n                  {\n                    \"value\": {\n                      \"selection\": {\n                        \"directReference\": {\n                          \"structField\": {\n                            \"field\": 1\n                          }\n                        },\n                        \"rootReference\": {}\n                      }\n                    }\n                  }\n                ]\n              }\n            }\n          }\n        ]\n      }\n    }\n  }\n}\n</code></pre> <p>The join relation will take two inputs. In the <code>left</code> field will be the read relation for <code>orders</code> and in the <code>right</code> field will be the filter relation (from <code>products</code>). The <code>type</code> field is an enum that allows us to specify we want an inner join. Finally, the <code>expression</code> field contains the expression to use in the join. Since we haven\u2019t used the <code>equals()</code> function yet, we use the reference number 3 here. (Again, we\u2019ll see at the end with plans how these functions are resolved.) The arguments refer to fields 0 and 4, which are indices into the combined schema formed from the left and right inputs. We\u2019ll discuss later in Field Indices where these come from.</p> <pre><code>{\n  \"join\": {\n    \"left\": { ... },\n    \"right\": { ... },\n    \"type\": \"JOIN_TYPE_INNER\",\n    \"expression\": {\n      \"scalarFunction\": {\n        \"functionReference\": 3,\n        \"outputType\": {\n          \"bool\": {\n            \"nullability\": \"NULLABILITY_NULLABLE\"\n          }\n        },\n        \"arguments\": [\n          {\n            \"value\": {\n              \"selection\": {\n                \"directReference\": {\n                  \"structField\": {\n                    \"field\": 0\n                  }\n                },\n                \"rootReference\": {}\n              }\n            }\n          },\n          {\n            \"value\": {\n              \"selection\": {\n                \"directReference\": {\n                  \"structField\": {\n                    \"field\": 4\n                  }\n                },\n                \"rootReference\": {}\n              }\n            }\n          }\n        ]\n      }\n    }\n  }\n}\n</code></pre> <p>The final aggregation requires two things, other than the input. First is the groupings. We\u2019ll use a single grouping expression containing the references to the fields <code>product_name</code> and <code>product_id</code>. (Multiple grouping expressions can be used to do cube aggregations.)</p> <p>For <code>measures</code>, we\u2019ll need to define <code>sum(quantity * price) as sales</code>. Substrait is stricter about data types, and quantity is an integer while price is a decimal. So we\u2019ll first need to cast <code>quantity</code> to a decimal, making the Substrait expression more like <code>sum(multiply(cast(decimal(10, 2), quantity), price))</code>. Both <code>sum()</code> and <code>multiply()</code> are functions, defined in  functions_arithmetic_demical.yaml. However <code>cast()</code> is a special expression type in Substrait, rather than a function.</p> <p>Finally, the naming with <code>as sales</code> will be handled at the end as part of the plan, so that\u2019s not part of the relation. Since we are always using field  indices to refer to fields, Substrait doesn\u2019t record any intermediate field names.</p> <pre><code>{\n  \"aggregate\": {\n    \"input\": { ... },\n    \"groupings\": [\n      {\n        \"groupingExpressions\": [\n          {\n            \"value\": {\n              \"selection\": {\n                \"directReference\": {\n                  \"structField\": {\n                    \"field\": 0\n                  }\n                },\n                \"rootReference\": {}\n              }\n            }\n          },\n          {\n            \"value\": {\n              \"selection\": {\n                \"directReference\": {\n                  \"structField\": {\n                    \"field\": 7\n                  }\n                },\n                \"rootReference\": {}\n              }\n            }\n          },\n        ]\n      }\n    ],\n    \"measures\": [\n      {\n        \"measure\": {\n          \"functionReference\": 4,\n          \"outputType\": {\n            \"decimal\": {\n              \"precision\": 38,\n              \"scale\": 2,\n              \"nullability\": \"NULLABILITY_NULLABLE\"\n            }\n          },\n          \"arguments\": [\n            {\n              \"value\": {\n                \"scalarFunction\": {\n                  \"functionReference\": 5,\n                  \"outputType\": {\n                    \"decimal\": {\n                      \"precision\": 38,\n                      \"scale\": 2,\n                      \"nullability\": \"NULLABILITY_NULLABLE\"\n                    }\n                  },\n                  \"arguments\": [\n                    {\n                      \"value\": {\n                        \"cast\": {\n                          \"type\": {\n                            \"decimal\": {\n                              \"precision\": 10,\n                              \"scale\": 2,\n                              \"nullability\": \"NULLABILITY_REQUIRED\"\n                            }\n                          },\n                          \"input\": {\n                            \"selection\": {\n                              \"directReference\": {\n                                \"structField\": {\n                                  \"field\": 1\n                                }\n                              },\n                              \"rootReference\": {}\n                            }\n                          }\n                        }\n                      }\n                    },\n                    {\n                      \"value\": {\n                        \"selection\": {\n                          \"directReference\": {\n                            \"structField\": {\n                              \"field\": 3\n                            }\n                          },\n                          \"rootReference\": {}\n                        }\n                      }\n                    }\n                  ]\n                }\n              }\n            }\n          ]\n        }\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"tutorial/sql_to_substrait/#field-indices","title":"Field indices","text":"<p>So far, we have glossed over the field indices. Now that we\u2019ve built up each of the relations, it will be a bit easier to explain them.</p> <p>Throughout the plan, data always has some implicit schema, which is modified by each relation. Often, the schema can change within a relation\u2013we\u2019ll discuss an example in the next section. Each relation has it\u2019s own rules in how schemas are modified, called the output order or emit order. For the purposes of our  query, the relevant rules are:</p> <ul> <li>For Read relations, their output schema is the schema of the table.</li> <li>For Filter relations, the output schema is the same as in the input schema.</li> <li>For Joins relations, the input schema is the concatenation of the left and then the   right schemas. The output schema is the same.</li> <li>For Aggregate relations, the output schema is the group by fields followed by   the measures.</li> </ul> <p>Note</p> <p>Sometimes it can be hard to tell what the implicit schema is. For help determining that, consider using the substrait-validator tool, described in Next Steps.</p> <p>The diagram below shows the mapping of field indices within each relation and how each of the field references show up in each relations properties.</p> <p></p>"},{"location":"tutorial/sql_to_substrait/#column-selection-and-emit","title":"Column selection and emit","text":"<p>As written, the aggregate output schema will be:</p> <pre><code>0: product_id: i64\n1: product_name: string\n2: sales: decimal(32, 8)\n</code></pre> <p>But we want <code>product_name</code> to come before <code>product_id</code> in our output. How do we reorder those columns?</p> <p>You might be tempted to add a Project relation  at the end. However, the project relation only adds columns; it is not responsible for subsetting or reordering columns.</p> <p>Instead, any relation can reorder or subset columns through the <code>emit</code> property. By default, it is set to <code>direct</code>, which outputs all columns \u201cas is\u201d. But it can also be specified as a sequence of field indices.</p> <p>For simplicity, we will add this to the final aggregate relation. We could also add it to all relations, only selecting the fields we strictly need in later relations. Indeed, a good optimizer would probably do that to our plan. And for some engines, the emit property is only valid within a project relation, so in those cases we would need to add that relation in combination with emit. But to keep things simple, we\u2019ll limit the columns at the end within the aggregation relation.</p> <p>For our final column selection, we\u2019ll modify the top-level relation to be:</p> <pre><code>{\n  \"aggregate\": {\n    \"input\": { ... },\n    \"groupings\": [ ... ],\n    \"measures\": [ ... ],\n    \"common\": {\n      \"emit\": {\n        \"outputMapping\": [1, 0, 2]\n      }\n    }\n}\n</code></pre>"},{"location":"tutorial/sql_to_substrait/#plans","title":"Plans","text":"<p>Now that we\u2019ve constructed our relations, we can put it all into a plan. Substrait plans are the only messages that can be sent and received on their own. Recall that earlier, we had function references to those YAML files, but so far there\u2019s been no place to tell a consumer what those function reference IDs mean or which extensions we are using. That information belongs at the plan level.</p> <p>The overall layout for a plan is</p> <pre><code>{\n  \"extensionUris\": [ ... ],\n  \"extensions\": [ ... ],\n  \"relations\": [\n    {\n      \"root\": {\n        \"names\": [\n          \"product_name\",\n          \"product_id\",\n          \"sales\"\n        ],\n        \"input\": { ... }\n      }\n    }\n  ]\n}\n</code></pre> <p>The <code>relations</code> field is a list of Root relations. Most queries only have one  root relation, but the spec allows for multiple so a common plan could be referenced by other plans, sort of like a CTE (Common Table Expression) from SQL. The root relation provides the final column names for our query. The input to this relation is our aggregate relation (which contains all the other relations as children).</p> <p>For extensions, we need to provide <code>extensionUris</code> with the locations of the  YAML files we used and <code>extensions</code> with the list of functions we used and which extension they come from.</p> <p>In our query, we used:</p> <ul> <li><code>index_in</code> (1), from <code>functions_set.yaml</code>,</li> <li><code>is_null</code> (2), from <code>functions_comparison.yaml</code>,</li> <li><code>equal</code> (3), from <code>functions_comparison.yaml</code>,</li> <li><code>sum</code> (4), from <code>functions_arithmetic_decimal.yaml</code>,</li> <li><code>multiply</code> (5), from <code>functions_arithmetic_decimal.yaml</code>.</li> </ul> <p>So first we can create the three extension uris:</p> <pre><code>[\n  {\n    \"extensionUriAnchor\": 1,\n    \"uri\": \"https://github.com/substrait-io/substrait/blob/main/extensions/functions_set.yaml\"\n  },\n  {\n    \"extensionUriAnchor\": 2,\n    \"uri\": \"https://github.com/substrait-io/substrait/blob/main/extensions/functions_comparison.yaml\"\n  },\n  {\n    \"extensionUriAnchor\": 3,\n    \"uri\": \"https://github.com/substrait-io/substrait/blob/main/extensions/functions_arithmetic_decimal.yaml\"\n  }\n]\n</code></pre> <p>Then we can create the extensions:</p> <pre><code>[\n  {\n    \"extensionFunction\": {\n      \"extensionUriReference\": 1,\n      \"functionAnchor\": 1,\n      \"name\": \"index_in\"\n    }\n  },\n  {\n    \"extensionFunction\": {\n      \"extensionUriReference\": 2,\n      \"functionAnchor\": 2,\n      \"name\": \"is_null\"\n    }\n  },\n  {\n    \"extensionFunction\": {\n      \"extensionUriReference\": 2,\n      \"functionAnchor\": 3,\n      \"name\": \"equal\"\n    }\n  },\n  {\n    \"extensionFunction\": {\n      \"extensionUriReference\": 3,\n      \"functionAnchor\": 4,\n      \"name\": \"sum\"\n    }\n  },\n  {\n    \"extensionFunction\": {\n      \"extensionUriReference\": 3,\n      \"functionAnchor\": 5,\n      \"name\": \"multiply\"\n    }\n  }\n]\n</code></pre> <p>Once we\u2019ve added our extensions, the plan is complete. Our plan outputted in full is: final_plan.json.</p>"},{"location":"tutorial/sql_to_substrait/#next-steps","title":"Next steps","text":"<p>Validate and introspect plans using  substrait-validator. Amongst other things, this tool can show what the current schema and column indices are at each point in the plan. Try downloading the final plan JSON above and generating an HTML report on the plan with:</p> <pre><code>substrait-validator final_plan.json --out-file output.html\n</code></pre>"},{"location":"types/type_classes/","title":"Type Classes","text":"<p>In Substrait, the \u201cclass\u201d of a type, not to be confused with the concept from object-oriented programming, defines the set of non-null values that instances of a type may assume.</p> <p>Implementations of a Substrait type must support at least this set of values, but may include more; for example, an <code>i8</code> could be represented using the same in-memory format as an <code>i32</code>, as long as functions operating on <code>i8</code> values within [-128..127] behave as specified (in this case, this means 8-bit overflow must work as expected). Operating on values outside the specified range is unspecified behavior.</p>"},{"location":"types/type_classes/#simple-types","title":"Simple Types","text":"<p>Simple type classes are those that don\u2019t support any form of configuration. For simplicity, any generic type that has only a small number of discrete implementations is declared directly, as opposed to via configuration.</p> Type Name Description Protobuf representation for literals boolean A value that is either True or False. <code>bool</code> i8 A signed integer within [-128..127], typically represented as an 8-bit two\u2019s complement number. <code>int32</code> i16 A signed integer within [-32,768..32,767], typically represented as a 16-bit two\u2019s complement number. <code>int32</code> i32 A signed integer within [-2147483648..2,147,483,647], typically represented as a 32-bit two\u2019s complement number. <code>int32</code> i64 A signed integer within [\u22129,223,372,036,854,775,808..9,223,372,036,854,775,807], typically represented as a 64-bit two\u2019s complement number. <code>int64</code> fp32 A 4-byte single-precision floating point number with the same range and precision as defined for the IEEE 754 32-bit floating-point format. <code>float</code> fp64 An 8-byte double-precision floating point number with the same range and precision as defined for the IEEE 754 64-bit floating-point format. <code>double</code> string A unicode string of text, [0..2,147,483,647] UTF-8 bytes in length. <code>string</code> binary A binary value, [0..2,147,483,647] bytes in length. <code>binary</code> timestamp A naive timestamp with microsecond precision. Does not include timezone information and can thus not be unambiguously mapped to a moment on the timeline without context. Similar to naive datetime in Python. <code>int64</code> microseconds since 1970-01-01 00:00:00.000000 (in an unspecified timezone) timestamp_tz A timezone-aware timestamp with microsecond precision. Similar to aware datetime in Python. <code>int64</code> microseconds since 1970-01-01 00:00:00.000000 UTC date A date within [1000-01-01..9999-12-31]. <code>int32</code> days since <code>1970-01-01</code> time A time since the beginning of any day. Range of [0..86,399,999,999] microseconds; leap seconds need not be supported. <code>int64</code> microseconds past midnight interval_year Interval year to month. Supports a range of [-10,000..10,000] years with month precision (= [-120,000..120,000] months). Usually stored as separate integers for years and months, but only the total number of months is significant, i.e. <code>1y 0m</code> is considered equal to <code>0y 12m</code> or <code>1001y -12000m</code>. <code>int32</code> years and <code>int32</code> months, with the added constraint that each component can never independently specify more than 10,000 years, even if the components have opposite signs (e.g. <code>-10000y 200000m</code> is not allowed) interval_day Interval day to second. Supports a range of [-3,650,000..3,650,000] days with microsecond precision (= [-315,360,000,000,000,000..315,360,000,000,000,000] microseconds). Usually stored as separate integers for various components, but only the total number of microseconds is significant, i.e. <code>1d 0s</code> is considered equal to <code>0d 86400s</code>. <code>int32</code> days, <code>int32</code> seconds, and <code>int32</code> microseconds, with the added constraint that each component can never independently specify more than 10,000 years, even if the components have opposite signs (e.g. <code>3650001d -86400s 0us</code> is not allowed) uuid A universally-unique identifier composed of 128 bits. Typically presented to users in the following hexadecimal format: <code>c48ffa9e-64f4-44cb-ae47-152b4e60e77b</code>. Any 128-bit value is allowed, without specific adherence to RFC4122. 16-byte <code>binary</code>"},{"location":"types/type_classes/#compound-types","title":"Compound Types","text":"<p>Compound type classes are type classes that need to be configured by means of a parameter pack.</p> Type Name Description Protobuf representation for literals FIXEDCHAR&lt;L&gt; A fixed-length unicode string of L characters. L must be within [1..2,147,483,647]. L-character <code>string</code> VARCHAR&lt;L&gt; A unicode string of at most L characters.L must be within [1..2,147,483,647]. <code>string</code> with at most L characters FIXEDBINARY&lt;L&gt; A binary string of L bytes. When casting, values shorter than L are padded with zeros, and values longer than L are right-trimmed. L-byte <code>bytes</code> DECIMAL&lt;P, S&gt; A fixed-precision decimal value having precision (P, number of digits) &lt;= 38 and scale (S, number of fractional digits) 0 &lt;= S &lt;= P. 16-byte <code>bytes</code> representing a little-endian 128-bit integer, to be divided by 10^S to get the decimal value STRUCT&lt;T1,\u2026,Tn&gt; A list of types in a defined order. <code>repeated Literal</code>, types matching T1..Tn NSTRUCT&lt;N:T1,\u2026,N:Tn&gt; Pseudo-type: A struct that maps unique names to value types. Each name is a UTF-8-encoded string. Each value can have a distinct type. Note that NSTRUCT is actually a pseudo-type, because Substrait\u2019s core type system is based entirely on ordinal positions, not named fields. Nonetheless, when working with systems outside Substrait, names are important. n/a LIST&lt;T&gt; A list of values of type T. The list can be between [0..2,147,483,647] values in length. <code>repeated Literal</code>, all types matching T MAP&lt;K, V&gt; An unordered list of type K keys with type V values. Keys may be repeated. While the key type could be nullable, keys may not be null. <code>repeated KeyValue</code> (in turn two <code>Literal</code>s), all key types matching K and all value types matching V PRECISIONTIMESTAMP&lt;P&gt; A timestamp with fractional second precision (P, number of digits) 0 &lt;= P &lt;= 9. Does not include timezone information and can thus not be unambiguously mapped to a moment on the timeline without context. Similar to naive datetime in Python. <code>int64</code> seconds, milliseconds, microseconds or nanoseconds since 1970-01-01 00:00:00.000000000 (in an unspecified timezone) PRECISIONTIMESTAMPTZ&lt;P&gt; A timezone-aware timestamp, with fractional second precision (P, number of digits) 0 &lt;= P &lt;= 9. Similar to aware datetime in Python. <code>int64</code> seconds, milliseconds, microseconds or nanoseconds since 1970-01-01 00:00:00.000000000 UTC"},{"location":"types/type_classes/#user-defined-types","title":"User-Defined Types","text":"<p>User-defined type classes are defined as part of simple extensions. An extension can declare an arbitrary number of user-defined extension types. Once a type has been declared, it can be used in function declarations.</p> <p>For example, the following declares a type named <code>point</code> (namespaced to the associated YAML file) and two scalar functions that operate on it.</p> <pre><code>types:\n  - name: \"point\"\n\nscalar_functions:\n  - name: \"lat\"\n    impls:\n      - args:\n        - name: p\n        - value: u!point\n    return: fp64\n  - name: \"lon\"\n    impls:\n      - args:\n        - name: p\n        - value: u!point\n    return: fp64\n</code></pre>"},{"location":"types/type_classes/#handling-user-defined-types","title":"Handling User-Defined Types","text":"<p>Systems without support for a specific user-defined type: * Cannot generate values of the type. * Cannot implement functions operating on the type. * May support consuming and emitting values of the type without modifying them.</p>"},{"location":"types/type_classes/#communicating-user-defined-types","title":"Communicating User-Defined Types","text":"<p>Specifiers of user-defined types may provide additional structure information for the type to assist in communicating values of the type to and from systems without built-in support.</p> <p>For example, the following declares a <code>point</code> type with two <code>i32</code> values named longitude and latitude:</p> <pre><code>types:\n  - name: point\n    structure:\n      longitude: i32\n      latitude: i32\n</code></pre> <p>The name-type object notation used above is syntactic sugar for <code>NSTRUCT&lt;longitude: i32, latitude: i32&gt;</code>. The following means the same thing:</p> <pre><code>name: point\nstructure: \"NSTRUCT&lt;longitude: i32, latitude: i32&gt;\"\n</code></pre> <p>The structure field of a type is only intended to inform systems that don\u2019t have built-in support for the type about how they can create and transfer values of that type to systems that do support the type.</p> <p>The structure field does not restrict or bind the internal representation of the type in any system.</p> <p>As such, it\u2019s currently not possible to \u201cunpack\u201d a user-defined type into its structure type or components thereof using <code>FieldReference</code>s or any other specialized record expression; if support for this is desired for a particular type, this can be accomplished with an extension function.</p>"},{"location":"types/type_classes/#literals","title":"Literals","text":"<p>Literals for user-defined types can be represented in one of two ways: * Using protobuf Any messages. * Using the structure representation of the type.</p>"},{"location":"types/type_classes/#compound-user-defined-types","title":"Compound User-Defined Types","text":"<p>User-defined types may be turned into compound types by requiring parameters to be passed to them. The supported \u201cmeta-types\u201d for parameters are data types (like those used in <code>LIST</code>, <code>MAP</code>, and <code>STRUCT</code>), booleans, integers, enumerations, and strings. Using parameters, we could redefine \u201cpoint\u201d with different types of coordinates. For example:</p> <pre><code>name: point\nparameters:\n  - name: T\n    description: |\n      The type used for the longitude and latitude\n      components of the point.\n    type: dataType\n</code></pre> <p>or:</p> <pre><code>name: point\nparameters:\n  - name: coordinate_type\n    type: enumeration\n    options:\n      - integer\n      - double\n</code></pre> <p>or:</p> <pre><code>name: point\nparameters:\n  - name: LONG\n    type: dataType\n  - name: LAT\n    type: dataType\n</code></pre> <p>We can\u2019t specify the internal structure in this case, because there is currently no support for derived types in the structure.</p> <p>The allowed range can be limited for integer parameters. For example:</p> <pre><code>name: vector\nparameters:\n  - name: T\n    type: dataType\n  - name: dimensions\n    type: integer\n    min: 2\n    max: 3\n</code></pre> <p>This specifies a vector that can be either 2- or 3-dimensional. Note however that it\u2019s not currently possible to put constraints on data type, string, or (technically) boolean parameters.</p> <p>Similar to function arguments, the last parameter may be specified to be variadic, allowing it to be specified one or more times instead of only once. For example:</p> <pre><code>name: union\nparameters:\n  - name: T\n    type: dataType\nvariadic: true\n</code></pre> <p>This defines a type that can be parameterized with one or more other data types, for example <code>union&lt;i32, i64&gt;</code> but also <code>union&lt;bool&gt;</code>. Zero or more is also possible, by making the last argument optional:</p> <pre><code>name: tuple\nparameters:\n  - name: T\n    type: dataType\n    optional: true\nvariadic: true\n</code></pre> <p>This would also allow for <code>tuple&lt;&gt;</code>, to define a zero-tuple.</p>"},{"location":"types/type_parsing/","title":"Type Syntax Parsing","text":"<p>In many places, it is useful to have a human-readable string representation of data types. Substrait has a custom syntax for type declaration. The basic structure of a type declaration is:</p> <pre><code>name?[variation]&lt;param0,...,paramN&gt;\n</code></pre> <p>The components of this expression are:</p> Component Description Required Name Each type has a name. A type is expressed by providing a name. This name can be expressed in arbitrary case (e.g. <code>varchar</code> and <code>vArChAr</code> are equivalent) although lowercase is preferred. Nullability indicator A type is either non-nullable or nullable. To express nullability, a question mark is added after the type name (before any parameters). Optional, defaults to non-nullable Variation When expressing a type, a user can define the type based on a type variation. Some systems use type variations to describe different underlying representations of the same data type. This is expressed as a bracketed integer such as [2]. Optional, defaults to [0] Parameters Compound types may have one or more configurable properties. The two main types of properties are integer and type properties. The parameters for each type correspond to a list of known properties associated with a type as declared in the order defined in the type specification. For compound types (types that contain types), the data type syntax will include nested type declarations. The one exception is structs, which are further outlined below. Required where parameters are defined"},{"location":"types/type_parsing/#grammars","title":"Grammars","text":"<p>It is relatively easy in most languages to produce simple parser &amp; emitters for the type syntax. To make that easier, Substrait also includes an ANTLR grammar to ease consumption and production of types.  (The grammar also supports an entire language for representing plans as text.)</p>"},{"location":"types/type_parsing/#structs-named-structs","title":"Structs &amp; Named Structs","text":"<p>Structs are unique from other types because they have an arbitrary number of parameters. The parameters are recursive and may include their own subproperties. Struct parsing is declared in the following two ways:</p> YAMLText Format Examples <pre><code># Struct\nstruct?[variation]&lt;type0, type1,..., typeN&gt;\n\n# Named Struct\nnstruct?[variation]&lt;name0:type0, name1:type1,..., nameN:typeN&gt;\n</code></pre> <pre><code>// Struct\nstruct?&lt;string, i8, i32?, timestamp_tz&gt;\n\n// Named structs are not yet supported in the text format.\n</code></pre> <p>In the normal (non-named) form, struct declares a set of types that are fields within that struct. In the named struct form, the parameters are formed by tuples of names + types, delineated by a colon. Names that are composed only of numbers and letters can be left unquoted. For other characters, names should be quoted with double quotes and use backslash for double-quote escaping.</p> <p>Note, in core Substrait algebra, fields are unnamed and references are always based on zero-index ordinal positions. However, data inputs must declare name-to-ordinal mappings and outputs must declare ordinal-to-name mappings. As such, Substrait also provides a named struct which is a pseudo-type that is useful for human consumption. Outside these places, most structs in a Substrait plan are structs, not named-structs. The two cannot be used interchangeably.</p>"},{"location":"types/type_parsing/#other-complex-types","title":"Other Complex Types","text":"<p>Similar to structs, maps and lists can also have a type as one of their parameters. Type references may be recursive. The key for a map is typically a simple type but it is not required.</p> YAMLText Format Examples <pre><code>list?&lt;type&gt;&gt;\nmap&lt;type0, type1&gt;\n</code></pre> <pre><code>list?&lt;list&lt;string&gt;&gt;\nlist&lt;struct&lt;string, i32&gt;&gt;\nmap&lt;i32?, list&lt;map&lt;i32, string?&gt;&gt;&gt;\n</code></pre>"},{"location":"types/type_system/","title":"Type System","text":"<p>Substrait tries to cover the most common types used in data manipulation. Types beyond this common core may be represented using simple extensions.</p> <p>Substrait types fundamentally consist of four components:</p> Component Condition Examples Description Class Always <code>i8</code>, <code>string</code>, <code>STRUCT</code>, extensions Together with the parameter pack, describes the set of non-null values supported by the type. Subdivided into simple and compound type classes. Nullability Always Either <code>NULLABLE</code> (<code>?</code> suffix) or <code>REQUIRED</code> (no suffix) Describes whether values of this type can be null. Note that null is considered to be a special value of a nullable type, rather than the only value of a special null type. Variation Always No suffix or explicitly <code>[0]</code> (system-preferred), or an extension Allows different variations of the same type class to exist in a system at a time, usually distinguished by in-memory format. Parameters Compound types only <code>&lt;10, 2&gt;</code> (for <code>DECIMAL</code>), <code>&lt;i32, string&gt;</code> (for <code>STRUCT</code>) Some combination of zero or more data types or integers. The expected set of parameters and the significance of each parameter depends on the type class. <p>Refer to Type Parsing for a description of the syntax used to describe types.</p> <p>Note</p> <p>Substrait employs a strict type system without any coercion rules. All changes in types must be made explicit via cast expressions.</p>"},{"location":"types/type_variations/","title":"Type Variations","text":"<p>Type variations may be used to represent differences in representation between different consumers. For example, an engine might support dictionary encoding for a string, or could be using either a row-wise or columnar representation of a struct. All variations of a type are expected to have the same semantics when operated on by functions or other expressions.</p> <p>All variations except the \u201csystem-preferred\u201d variation (a.k.a. <code>[0]</code>, see Type Parsing) must be defined using simple extensions. The key properties of these variations are:</p> Property Description Base Type Class The type class that this variation belongs to. Name The name used to reference this type. Should be unique within type variations for this parent type within a simple extension. Description A human description of the purpose of this type variation. Function Behavior INHERITS or SEPARATE: whether functions that support the system-preferred variation implicitly also support this variation, or whether functions should be resolved independently. For example, if one has the function <code>add(i8,i8)</code> defined and then defines an <code>i8</code> variation, this determines whether the <code>i8</code> variation can be bound to the base <code>add</code> operation (inherits) or whether a specialized version of <code>add</code> needs to be defined specifically for this variation (separate). Defaults to inherits."}]}